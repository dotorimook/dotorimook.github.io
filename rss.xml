<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://gatsby-starter-blog-demo.netlify.com</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 20 Jun 2021 05:32:47 GMT</lastBuildDate><item><title><![CDATA[맥에서 vscode auto import가 되지 않을 때]]></title><description><![CDATA[잘되던 Auto Import가 왜 갑자기?! 맥환경 vscode에서 갑자기 auto import가 이상하리만큼 잘 안되기 시작했다..?! 다른 많은 유/무료 IDE를 제치고 vscode를 메인 IDE로 사용하고 있는 점 중 하나가 가벼움과 ts…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2021-06-20-mac-auto-import-fail/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2021-06-20-mac-auto-import-fail/</guid><pubDate>Sun, 20 Jun 2021 14:07:19 GMT</pubDate><content:encoded>&lt;h1&gt;잘되던 Auto Import가 왜 갑자기?!&lt;/h1&gt;
&lt;p&gt;맥환경 vscode에서 갑자기 auto import가 이상하리만큼 잘 안되기 시작했다..?! 다른 많은 유/무료 IDE를 제치고 vscode를 메인 IDE로 사용하고 있는 점 중 하나가 가벼움과 ts와의 궁합으로 auto complete과 auto import를 강력하게 지원한다는 것이었는데.. 대체 이유가 뭘까? 몇가지 환경 체크를 했다.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;tsconfig.json&lt;/strong&gt; (혹은 &lt;strong&gt;jsconfig&lt;/strong&gt;)의 설정은 올바른가?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;tsconfig.json&lt;/strong&gt; 의 &lt;code class=&quot;language-text&quot;&gt;compilerOptions&lt;/code&gt; 에 인덱싱돼어야할 path나 설정들이 올바르게 설정되어있는지 확인한다. 해당 설정에 따라 파일을 읽지 못하는 경우도 발생한다.&lt;/p&gt;
&lt;h2&gt;typescript version 체크&lt;/h2&gt;
&lt;p&gt;vscode창 우측 하단에 보면 typescript의 버전이 나오는데, 버전을 누르면 Typescript의 버전을 선택할 수가 있다. workspace 버전으로 맞춰보지.&lt;/p&gt;
&lt;h2&gt;Auto Import 확장 사용하기&lt;/h2&gt;
&lt;p&gt;딱히 별 차도가 없다? &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=NuclleaR.vscode-extension-auto-import&quot;&gt;Auto Import&lt;/a&gt;라는 익스텐션을 사용해보자. 사실 위 문제들은 없었던 것 같고, &lt;strong&gt;Auto Import&lt;/strong&gt; 설치로 한방에 해결했다.&lt;/p&gt;
&lt;p&gt;vscode는 기본 기능도 좋지만 잘 찾아보면 개발환경을 훨씬 강력하게 만드는 익스텐션들이 꽤 있는 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[NextJS + Typescript + ESLint + Capacitor 세팅을 해보자]]></title><description><![CDATA[Background  사실상 Capacitor가 ionic과 궁합이 좋다지만.. 꼭 ionic을 위해 만들어진 것도 아니다?! 라는 생각이 들어서. 그렇다면 NextJS 세팅에선 어떨까? 하는 생각이 들었다. 그래서 한 번 테스트 해보았다. What…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2021-06-13-next-js-with-capacitor/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2021-06-13-next-js-with-capacitor/</guid><pubDate>Sun, 13 Jun 2021 21:34:49 GMT</pubDate><content:encoded>&lt;h1&gt;Background&lt;/h1&gt;
&lt;p&gt; 사실상 Capacitor가 ionic과 궁합이 좋다지만.. 꼭 ionic을 위해 만들어진 것도 아니다?! 라는 생각이 들어서. 그렇다면 NextJS 세팅에선 어떨까? 하는 생각이 들었다. 그래서 한 번 테스트 해보았다.&lt;/p&gt;
&lt;h1&gt;What is Capacitor?&lt;/h1&gt;
&lt;p&gt;Capacitor는 웹플랫폼에서 네이티브 기능을 사용해 줄 수 있는 플러그인들을 제공하는 라이브러리다.  크로스플랫폼 네이티브 런타임이라고 스스로 표방한다. 이전 Cordova와 PhoneGap을 계승하여, 모던 웹 앱을 메이저 플랫폼에서 쉽게 돌아가게 하도록 한다. 아이오닉에서 만들어진 만큼 아이오닉 프레임워크와 가장 궁합이 좋다. &lt;/p&gt;
&lt;h1&gt;Next JS + Typescript + ESLint 세팅&lt;/h1&gt;
&lt;p&gt;NextJS Typescript 세팅은 이미 create next-app에서 간단하게 제공하고 있다. &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;bash&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;yarn create next-app --example with-typescript-eslint-jest project-name&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h1&gt;Capacitor 끼얹기&lt;/h1&gt;
&lt;h2&gt;Capacitor 설치&lt;/h2&gt;
&lt;p&gt;우선 capacitor에 필요한 &lt;code class=&quot;language-text&quot;&gt;@capacitor/core&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;@capacitor/cli&lt;/code&gt;를 설치한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;bash&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;yarn add @capacitor/core @capacitor/cli&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;Capacitor 초기화&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;bash&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;npx cap init --web-dir=out&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;실행하면 초기화하기 위한 옵션들을 물어보는데 맞게 입력하고 넘어가면 된다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;--web-dir=out&lt;/code&gt; 옵션이 중요한데, next가 빌드되면 결과물이 &lt;code class=&quot;language-text&quot;&gt;out&lt;/code&gt; 에 생성 되기 때문이다.&lt;/p&gt;
&lt;p&gt;대략 물어보는 정보는 다음과 같다:&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;bash&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;[?] What is the name of your app?
    This should be a human-friendly app name, like what you&amp;#39;d see in the App Store.
✔ Name … project-name
[?] What should be the Package ID for your app?
    Package IDs (aka Bundle ID in iOS and Application ID in Android) are unique identifiers for apps. They must be in
    reverse domain name notation, generally representing a domain name that you or your company owns.
✔ Package ID … com.example.app
✔ Creating capacitor.config.ts in /Users/jihoyeom/Documents/Projects/playground/next-with-capacitor in 8.51ms
[success] capacitor.config.ts created!

Next steps: 
https://capacitorjs.com/docs/getting-started#where-to-go-next
[?] Join the Ionic Community! 💙
    Connect with millions of developers on the Ionic Forum and get access to live events, news updates, and more.
✔ Create free Ionic account? … no
[?] Would you like to help improve Capacitor by sharing anonymous usage data? 💖
    Read more about what is being collected and why here: https://capacitorjs.com/telemetry. You can change your mind at
    any time by using the npx cap telemetry command.
✔ Share anonymous usage data? … yes

Thank you for helping to make Capacitor better! 💖
Information about the data we collect is available on our website: https://capacitorjs.com/telemetry&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;프로젝트 루트에 &lt;code class=&quot;language-text&quot;&gt;capacitor.config.ts&lt;/code&gt; 라는 설정 파일이 생성된다. 이 설정파일의 &lt;code class=&quot;language-text&quot;&gt;webDir&lt;/code&gt; 필드가 &lt;code class=&quot;language-text&quot;&gt;out&lt;/code&gt;으로 설정되어 있는 것을 확인한다.&lt;/p&gt;
&lt;h2&gt;플랫폼 추가하기&lt;/h2&gt;
&lt;p&gt;android와 ios 프로젝트를 추가하기 위해 다음과 같이 입력한다&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;bash&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;npx cap add android
npx cap add ios&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;각 명령어를 실행하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;@capacitor/ios&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;@capacitor/android&lt;/code&gt; 의존성도 필요하다.&lt;/p&gt;
&lt;h1&gt;NextJS 에서 Capacitor를 사용 했을 때 가능 범위&lt;/h1&gt;
&lt;p&gt;NextJs에서 지원하는 좋은 기능들을 다 쓸 수 있는 것일까?&lt;/p&gt;
&lt;h2&gt;사용할 수 있는것&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;router&lt;/li&gt;
&lt;li&gt;getInitialProps&lt;/li&gt;
&lt;li&gt;dynamic Routes&lt;/li&gt;
&lt;li&gt;api&lt;/li&gt;
&lt;li&gt;link&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NextJS를 사용하면서 중요하게 생각했던 기능들은 대체로 잘 동작하는 것을 확인했다.&lt;/p&gt;
&lt;h2&gt;사용할 수 없는 것&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;next/images&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;제한적으로 사용할 수 있는 것&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;live reload&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;기존에 &lt;code class=&quot;language-text&quot;&gt;ionic capacitor —live-reload-url&lt;/code&gt; 로 편리하게 사용할 수 있었던 live reload기능은 사용할 수 없다. 다만, &lt;strong&gt;capacitor.config.ts&lt;/strong&gt; 에 다음을 추가해서 비슷한 효과를 낼 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const config: CapacitorConfig = {
...
  server: {
    url: &amp;#39;http://[YOUR_IP_ADDRESS]:[YOUR_PORT]&amp;#39;,
    cleartext: true
  }
...
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn dev&lt;/code&gt; 로 개발 서버를 띄운 다음에 주소를 &lt;code class=&quot;language-text&quot;&gt;server.url&lt;/code&gt; 로 설정해서 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;실제로 &lt;code class=&quot;language-text&quot;&gt;ionic capcitor&lt;/code&gt;도 실행되는 동안 저 설정을 추가하고 종료 시 되돌리는 일을 하고 있다.&lt;/p&gt;
&lt;h1&gt;결론&lt;/h1&gt;
&lt;p&gt;Capacitor는 모던 웹앱을 네이티브 앱 처럼 손쉽게 만들어주는 감동적인 라이브러리이다. Ionic과 찰떡 궁합이겠지만, 약간의 제한이 있지만 NextJS와도 나쁘지 않은 궁합을 보여주는 것 같다. NextJS는 CRA나 Ionic과 같은 CSR 프로젝트에 비해 SSR의 장점을 취할 수 있는데, Capacitor와 NextJS를 함께 이용한다면 웹 서비스와 앱 두 장점을 모두 취할 수 있을 것 같다.&lt;/p&gt;
&lt;h1&gt;Trouble Shooting&lt;/h1&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;next export&lt;/code&gt; 시 Error: Image Optimization using Next.js’ default loader is not compatible with &lt;code class=&quot;language-text&quot;&gt;next export&lt;/code&gt;. 에러 발생할 때&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;next/images&lt;/strong&gt; 를 이용해서 이미지를 사용하는데 &lt;code class=&quot;language-text&quot;&gt;next export&lt;/code&gt; 를 사용할 때 발생한다. &lt;strong&gt;next/images&lt;/strong&gt;는  &lt;code class=&quot;language-text&quot;&gt;next export&lt;/code&gt; 를 이용해서 생성된 정적 페이지에서는 동작하지 않기 때문에 export 시에 오류가 발생한다. &lt;strong&gt;next/images&lt;/strong&gt; 대신 &lt;strong&gt;&lt;a href=&quot;https://github.com/cyrilwanner/next-optimized-images&quot;&gt;next-optimized-images&lt;/a&gt;&lt;/strong&gt;를 사용할 수 있다.&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vercel/next.js/tree/canary/examples/with-typescript-eslint-jest&quot;&gt;https://github.com/vercel/next.js/tree/canary/examples/with-typescript-eslint-jest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://broddin.be/english/packaging-nextjs-capacitor/&quot;&gt;https://broddin.be/english/packaging-nextjs-capacitor/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cyrilwanner/next-optimized-images&quot;&gt;https://github.com/cyrilwanner/next-optimized-images&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/65487914/no-exportpathmap-found-in-next-config-js-generating-map-from-pages&quot;&gt;https://stackoverflow.com/questions/65487914/no-exportpathmap-found-in-next-config-js-generating-map-from-pages&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[내가 쓰는 앱이 M1 맥용일까? 인텔용일까? 애플 실리콘용 앱 확인하는 방법]]></title><description><![CDATA[애플 실리콘용 / 인텔용 확인하는 방법 M1 맥용 앱? 인텔 맥용 앱? m1 맥북 출시후 벌써 반년이 되어가고 있는데, 그동안 국내외 많은 유튜버 등 인플루언서, IT 커뮤니티, 벤치마크 사이트 등을 통해 m…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2021-05-02-check-intel-mac-app copy/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2021-05-02-check-intel-mac-app copy/</guid><pubDate>Sun, 02 May 2021 16:29:01 GMT</pubDate><content:encoded>&lt;h1&gt;애플 실리콘용 / 인텔용 확인하는 방법&lt;/h1&gt;
&lt;h2&gt;M1 맥용 앱? 인텔 맥용 앱?&lt;/h2&gt;
&lt;p&gt;m1 맥북 출시후 벌써 반년이 되어가고 있는데, 그동안 국내외 많은 유튜버 등 인플루언서, IT 커뮤니티, 벤치마크 사이트 등을 통해 m1 맥의 뜨거운 관심과 놀라운 성능이 입증되었고, 최근 애플은 m1칩을 탑재한 새로운 iMac을 출시했습니다. m1 프로세서는 맥에 새로운 세상을 열었다고 해도 과언이 아닙니다.&lt;/p&gt;
&lt;h2&gt;인텔용 앱도 문제없어, 로제타!&lt;/h2&gt;
&lt;p&gt;m1 맥을 도입을 가장 망설이게 되는 부분이 바로 내 앱이 m1 맥을 지원하는 앱인가 하는 점일텐데요, &lt;strong&gt;인텔 기반의 앱을 m1 맥에서도 실행할 수 있게 해주는 &lt;a href=&quot;https://support.apple.com/ko-kr/HT211861&quot;&gt;로제타&lt;/a&gt;&lt;/strong&gt;가 기대 이상으로 잘 동작하고, 링크된 문서에 작성되어 있는 것 처럼 로제타를 사용해서 실행한다고 하더라도 대부분의 경우 &lt;strong&gt;앱 성능에서는 차이가 느껴지지 않기 때문에&lt;/strong&gt; 더더욱 이 걱정은 그저 기우일 뿐이라는 생각이 듭니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/9fc19ffdf0f6e65c32eaf08c1a663df9/e2310/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 46.621621621621614%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABlUlEQVQoz41SyU7jUBD05yHmYzjBDc2VO+JHkIJQFEWIG1xCiIKdEDuLHWfxEjvO8xLsFK8e44g5IGGpVK1uverqbmtZ7KAIdeRpgrKsUFUVfvsdDgf5pvwPWlEU2O8LpGkqeY/dbocgCOB5HlarFZbLpQJj13Uxn8/hOA4WiwWiKEKWZeptDc11F7i9u8f55V+8mybiOEa73Uaz2USj0UCr1UK328V4PEa/34eu6zAMA4PBAL7vg4YoSgghoBmycH1zg5M/p3h6foaQDnu9nkKn01E8nU6VS7oj6JbMvG3byjnrymGe51iv13jtvqgExxiNRjClW8uyFNPdcDhUeTLzjMmbzQZhGCpWgrRJUR6DtlmYzWYKtu1gMpkembtjns5qNq0xbGcOkf4bmaoMkmQnBVP44Rb6xMebRM/yZOyp+NX04K4CRLJhFMVqEjYvkgCHLAJKgSKTgiwQtTC5XvJP+Lq8vHK8xdVDhYu7Eme3H9DdDBp/E+L76YWQqPkIcWzK63Jv222Cx1GOppHj/i3HcpPiE9FAnSNopM5BAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/9fc19ffdf0f6e65c32eaf08c1a663df9/fcda8/1.png&quot;
        srcset=&quot;/static/9fc19ffdf0f6e65c32eaf08c1a663df9/12f09/1.png 148w,
/static/9fc19ffdf0f6e65c32eaf08c1a663df9/e4a3f/1.png 295w,
/static/9fc19ffdf0f6e65c32eaf08c1a663df9/fcda8/1.png 590w,
/static/9fc19ffdf0f6e65c32eaf08c1a663df9/efc66/1.png 885w,
/static/9fc19ffdf0f6e65c32eaf08c1a663df9/e2310/1.png 968w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;실제로 인텔용 앱을 사용하면 로제타 설치 메시지가 나오고, 설치 이후에는 자동으로 로제타를 이용해서 사용하는데, 인텔용 앱과 맥용 앱의 성능차이가 거의 없기 때문에 사용하는 도중에는 이 앱이 인텔용 앱인지, 맥용 앱인지 체감으로는 거의 불가능에 가깝고, 이 점은 애플에서 어느정도 의도한 부분도 있는 것 같습니다. 사용경험의 차이가 거의 없기 때문에 굳이 알필요도, 걱정할 필요도 없다는 것이죠.&lt;/p&gt;
&lt;h2&gt;굳이 알고싶다. 이게 정말 애플용 앱인가?!&lt;/h2&gt;
&lt;p&gt;사용 중간에 간간이 궁금해집니다. 자연스럽게 사용하고 있는 이 앱이 과연 애플용 앱인가? 이것을 확인하는 방법은 두 가지가 있습니다.&lt;/p&gt;
&lt;h3&gt;&lt;em&gt;시스템 리포트 &gt; 응용프로그램&lt;/em&gt; 에서 확인하기&lt;/h3&gt;
&lt;p&gt;스크린 좌측 상단의 사과 아이콘  을 클릭하여 &lt;em&gt;이 Mac에 관하여&lt;/em&gt;를 클릭합니다. 그럼 아래와 같은 창이 뜨는데 &lt;em&gt;시스템 리포트…&lt;/em&gt;를 클릭합니다. 시스템 리포트 창이 뜨면 좌측에 &lt;em&gt;소프트웨어 &gt; 응용 프로그램&lt;/em&gt; 메뉴를 누르게되면 우측에 설치된 응용프로그램 목록이 나타납니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/da7cc9071fb99cb8055540fd1df9dae7/5c1ad/2.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 53.37837837837838%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd+ykUIP/8QAFxAAAwEAAAAAAAAAAAAAAAAAAQIDIP/aAAgBAQABBQJblrjP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAgMAAAAAAAAAAAAAAAAAAQMSICH/2gAIAQEABj8CK45b/8QAGhABAAEFAAAAAAAAAAAAAAAAAQARICFB8P/aAAgBAQABPyFKYlK7ieLf/9oADAMBAAIAAwAAABCQz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQACAwADAAAAAAAAAAAAAAEAESExURChwf/aAAgBAQABPxCsrlHCjacY1FT0+y3saGwL7DZg8f/Z&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/da7cc9071fb99cb8055540fd1df9dae7/1c72d/2.jpg&quot;
        srcset=&quot;/static/da7cc9071fb99cb8055540fd1df9dae7/a80bd/2.jpg 148w,
/static/da7cc9071fb99cb8055540fd1df9dae7/1c91a/2.jpg 295w,
/static/da7cc9071fb99cb8055540fd1df9dae7/1c72d/2.jpg 590w,
/static/da7cc9071fb99cb8055540fd1df9dae7/a8a14/2.jpg 885w,
/static/da7cc9071fb99cb8055540fd1df9dae7/5c1ad/2.jpg 1172w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    

  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/bc4dc012b24b14ceaff84c29ac58e755/37c35/3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 66.89189189189189%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB5UlEQVQ4y4VT227aUBD0Z0RcDcb3G1CMwTZ2cAzEgITUSry1Td8bVaqaL+iHT3c3AqWE0ofR7tlzNJ7ZXSuLfIr0PoFt27AIDiFLE8ziGLquYaD1YRo6fM+FbZnwXEdiGAYIAx/xNJLzaDiUO2WxyFE/1nA9D5ahQR+VeHz6jeTjC+6iL2jGX9GeP8HffEeD8rvoM9rJN3zY/5Ba+umF3v7CsH5GfPgJJU1TLJfLV4WWBdf1sN3tUJYP8PwAhmmRcgfzJKU3jpxtx0VR3GM2n6NarbHebJCkGR6qFZSiKLAjAt/3hdA0TQxJvk25qnbR7XbR6/XIvk5RpZoq0TQM6IMBLHpvkWW+56iUZYnVanVWyMiyDFEUySMmaDabaDQaaLVaaLfbAq7xmePbXMnzHExqypcsIU6SBFyv61ry6XSKmIY0Ho+pJS486jej3+8LeafTOUMUVlUlhI7jYEA2+IJtcs0gayflfHdJ8I6Qlez3e8xmM1GnadrZ2jVbJ5ITLklpbRbYbrcyabZ0zcYtRe8U8tqwbZ5sEAR/Ed4i/hdkbQ6HA0ajEa2KLX06WfufuquEa1rM4/GIlKYZhqGsCvfrbZ8u+3UL0kMeymQykYlqpFDTBkLMZ1bMOQ+Ll/wa+Ad4hYo/bMyDNY8jqaAAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/bc4dc012b24b14ceaff84c29ac58e755/fcda8/3.png&quot;
        srcset=&quot;/static/bc4dc012b24b14ceaff84c29ac58e755/12f09/3.png 148w,
/static/bc4dc012b24b14ceaff84c29ac58e755/e4a3f/3.png 295w,
/static/bc4dc012b24b14ceaff84c29ac58e755/fcda8/3.png 590w,
/static/bc4dc012b24b14ceaff84c29ac58e755/efc66/3.png 885w,
/static/bc4dc012b24b14ceaff84c29ac58e755/c83ae/3.png 1180w,
/static/bc4dc012b24b14ceaff84c29ac58e755/37c35/3.png 1810w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;응용 프로그램을 선택하거나 목록의 우측의 종류를 통해 확인할 수 있습니다. 종류가 &lt;em&gt;Universal&lt;/em&gt;로 표기된다면 m1맥 Intel맥에서 모두 실행되는 유니버설 앱이며, &lt;strong&gt;Intel&lt;/strong&gt;로 표기된 앱은 인텚용 앱입니다.&lt;/p&gt;
&lt;h3&gt;&lt;em&gt;활성 상태 보기&lt;/em&gt; 를 이용하는 방법&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;활성 상태 보기&lt;/em&gt;를 이용하는 방법도 있습니다. &lt;em&gt;응용 프로그램 &gt; 유틸리티&lt;/em&gt;에서 &lt;em&gt;활성 상태 보기(Activity Monitor)&lt;/em&gt;를 선택하거나, spotlight이나 Alfred를 이용해 실행시켜줍니다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/2e47fb49a89e697e5803452187e273d9/fa60d/4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 94.5945945945946%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAABpElEQVQ4y62U626DMAyFeZGuN0K4h1uBltKpk9jPbe//Mmc+aYtY10nTxg8rJnE+O4k5ztDVOA97vL1/4HUYUNc12qbBvm3RH4/o+97OP59OOIlxfDmf0XWdXW8lrpE9h8MBTbuHE2iNMPQRxzHKskTg+3Bd11qSJAiDAFmWIYoiGxOFIRpJSD+QtSLP4XkejEmhlIaTCIzV5LKglII3NQmMBeRLEmMMtCT3rwmZmDGcDyUJ4UEQwdHak43KwrQA7s27G39atyYsh1kvH/rhht8awazeAr1/gKZAHtvxZwSyuFmB9shToPdH42Mo5doXn69C6RL26izA2/2xP2cFspfnBbJCPTfwW4WP/pjp3AP/K9DX4wRfSl1FgaZu40QsuGn0pVVubTPeoYVI0Ha7RSpyVRaFlSYjfiFGn/LFHqNfVRXSNB3ljq3CvYRxdDbrNdZii8XCBlM4L8EV9l0PI5szkwnEiG+s4BaSlFpJceW4XC5Bzmq1guNuN6Apd4MkDqVK0T/NH92Xb6nI5KiyAoddg11eyp3p8VqoiTwqCyJw+fSETyyLL+E16MnjAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/2e47fb49a89e697e5803452187e273d9/fcda8/4.png&quot;
        srcset=&quot;/static/2e47fb49a89e697e5803452187e273d9/12f09/4.png 148w,
/static/2e47fb49a89e697e5803452187e273d9/e4a3f/4.png 295w,
/static/2e47fb49a89e697e5803452187e273d9/fcda8/4.png 590w,
/static/2e47fb49a89e697e5803452187e273d9/efc66/4.png 885w,
/static/2e47fb49a89e697e5803452187e273d9/c83ae/4.png 1180w,
/static/2e47fb49a89e697e5803452187e273d9/fa60d/4.png 1792w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;창을 보시면 현재 활성화되어있는 프로세스들을 확인할 수 있는데 해당 목록에 &lt;strong&gt;아키텍쳐&lt;/strong&gt; 컬럼을 보시면 &lt;strong&gt;Apple&lt;/strong&gt; 또는 &lt;strong&gt;Intel&lt;/strong&gt;로 표기되어 있는 것을 확인할 수 있습니다. 해당하는 프로세스가 어떤 아키텍처에서 실행되고 있는지를 보여줍니다. 따라서 이 앱이 인텔용인지, 애플 실리콘 용 인지 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이상 내가 쓰는 앱이 애플 실리콘 최적화 된 앱인지 인텔용 앱인지 확인하는 두 가지 방법을 알아보았습니다. 😁&lt;/p&gt;</content:encoded></item><item><title><![CDATA[SSH로 git 사용하기]]></title><description><![CDATA[Github는 패스워드 기반 인증을 지원하지 않기로 했다. 대표적인 무료 git 저장소인 github가 패스워드기반 인증을 사용하지 않겠다고 발표했습니다. 앞으로는 github를 이용할 때에는 1. 토큰 기반 인증 또는 2. SSH…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/ssh-git/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/ssh-git/</guid><pubDate>Sun, 14 Mar 2021 11:28:08 GMT</pubDate><content:encoded>&lt;h1&gt;Github는 패스워드 기반 인증을 지원하지 않기로 했다.&lt;/h1&gt;
&lt;p&gt;대표적인 무료 git 저장소인 &lt;strong&gt;github&lt;/strong&gt;가 패스워드기반 인증을 사용하지 않겠다고 발표했습니다. 앞으로는 &lt;strong&gt;github&lt;/strong&gt;를 이용할 때에는 &lt;strong&gt;1. 토큰 기반 인증&lt;/strong&gt; 또는 &lt;strong&gt;2. SSH 기반 인증&lt;/strong&gt;을 해야합니다. github뿐만 아니라 BitBucket이나 gitlab 등 일반적으로 많이 사용하는 git 기반 저장소에서도 많은 경우에 HTTPS기반 인증을 사용하고 있지만, SSH기반 인증 역시 지원하고 있습니다. 저장소의 페이지에 있는 &lt;strong&gt;Clone&lt;/strong&gt;버튼을 눌러보면 &lt;strong&gt;Clone with SSH&lt;/strong&gt;가 있는데, SSH를 통해서도 저장소를 받을 수 있음을 확인할 수 있는 부분입니다.&lt;/p&gt;
&lt;h1&gt;SSH기반 인증, 그거 어떻게 하는 건데?&lt;/h1&gt;
&lt;p&gt;그럼 슬슬 본론으로 넘어가서, SSH기반으로 인증할 수 있는 절차를 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;SSH인증을 위해서는 2가지를 해야합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;SSH키 생성&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;퍼블릭 키 등록&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;1. SSH 키 생성&lt;/h2&gt;
&lt;p&gt;SSH키라는 것은 &lt;strong&gt;SSH 프로토콜의 접근 크리덴셜&lt;/strong&gt;이라고 보면 됩니다. &lt;strong&gt;퍼블릭 키(public key, 공개 키)&lt;/strong&gt;와 &lt;strong&gt;프라이빗 키(private key, 개인 키)&lt;/strong&gt;를 가지고 있으며, &lt;strong&gt;퍼블릭 키&lt;/strong&gt;를 서비스에 등록해 놓으면, &lt;strong&gt;프라이빗 키&lt;/strong&gt;를 이용해서 인증하여 접속합니다.&lt;/p&gt;
&lt;p&gt;SSH키를 생성하면 &lt;strong&gt;퍼블릭 키&lt;/strong&gt;와 &lt;strong&gt;프라이빗 키&lt;/strong&gt;가 나오는데, 이 퍼블릭 키를  github 등 서비스에 등록하여 사용합니다.&lt;/p&gt;
&lt;p&gt;윈도우는 git-bash를 이용하세요.&lt;/p&gt;
&lt;h3&gt;프라이빗 키 생성&lt;/h3&gt;
&lt;p&gt;키 생성은 &lt;code class=&quot;language-text&quot;&gt;ssh-keygen&lt;/code&gt;이라는 명령어를 사용합니다. &lt;code class=&quot;language-text&quot;&gt;-t&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;-b&lt;/code&gt;,  &lt;code class=&quot;language-text&quot;&gt;-C&lt;/code&gt; 등 옵션을 제공합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;bash&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;ssh-keygen&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;bash&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;Generating public/private rsa key pair.
Enter file in which to save the key (/***/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /***/.ssh/id_rsa.
Your public key has been saved in /***/.ssh/id_rsa.pub.
The key fingerprint is:
*** ***&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;따로 경로를 지정하지 않으면, 일반적으로 &lt;em&gt;~/.ssh&lt;/em&gt; 경로에 &lt;strong&gt;id_rsa&lt;/strong&gt;와 &lt;strong&gt;id_rsa.pub&lt;/strong&gt; 라는 파일이 생성됩니다.&lt;/p&gt;
&lt;h3&gt;프라이빗 키를 등록하기&lt;/h3&gt;
&lt;p&gt;퍼블릭 키를 서비스에 등록하여 사용하기 전에 &lt;code class=&quot;language-text&quot;&gt;ssh-add&lt;/code&gt; 커맨드를 이용해서 개인 키 파일을 &lt;strong&gt;ssh-agent&lt;/strong&gt; 에 등록합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;bash&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;ssh-add ~/.ssh/id_rsa&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;키를 다른 경로에 등록했을 경우 각 경로로 사용해야 합니다.&lt;/p&gt;
&lt;h3&gt;퍼블릭 키를 서비스에 등록하기&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;pub&lt;/em&gt; 확장자는 &lt;strong&gt;퍼블릭 키(public key)&lt;/strong&gt; 를 의미합니다. &lt;code class=&quot;language-text&quot;&gt;cat&lt;/code&gt; 커맨드를 이용해서 그 내용을 터미널에 띄울 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;bash&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;cat ~/.ssh/id_rsa.pub
ssh-rsa AAAB3Nza어쩌구저쩌구..&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;터미널에 떠 있는 모든 내용을 복사해서 서비스에 등록을 해서 사용하면 됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Github&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Settings &gt; SSH and GPG Keys 메뉴에서 &lt;strong&gt;New **SSH Key&lt;/strong&gt; 버튼을 누르고 키를 title과 key를 입력 후 &lt;strong&gt;Add SSH Key&lt;/strong&gt; 버튼을 눌러 등록&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gitlab&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Edit Profile &gt; SSH Keys 에 Key를 붙여넣고 &lt;em&gt;Title, Expires at&lt;/em&gt; (유효기간)을 입력 후 &lt;strong&gt;Add Key&lt;/strong&gt; 버튼을 누른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bitbucket&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Personal settings &gt; Security &gt; SSH keys 메뉴에서 &lt;strong&gt;Add Key&lt;/strong&gt; 버튼을 누른 이후 &lt;em&gt;Label&lt;/em&gt; 과 &lt;em&gt;Key&lt;/em&gt; 값 입력 후 &lt;strong&gt;Add Key&lt;/strong&gt; 버튼을 눌러 등록&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Git push error pre-receive hook declined 에러]]></title><description><![CDATA[git 푸시 실패: pre-receive hook declined git 브랜치에서 푸시를 하려고 하는데 푸시가 되지 않았다. 하려고 했던 푸시는 force to push였다. pre-receive hook declined…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/git-pre-receive-hook-declined-error/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/git-pre-receive-hook-declined-error/</guid><pubDate>Mon, 01 Mar 2021 15:30:04 GMT</pubDate><content:encoded>&lt;h1&gt;git 푸시 실패: pre-receive hook declined&lt;/h1&gt;
&lt;p&gt;git 브랜치에서 푸시를 하려고 하는데 푸시가 되지 않았다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;remote: GitLab: You are not allowed to force push code to a protected branch on this project.
[remote rejected] master -&amp;gt; master (pre-receive hook declined)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하려고 했던 푸시는 force to push였다.&lt;/p&gt;
&lt;h2&gt;pre-receive hook declined 에러 해결 방법&lt;/h2&gt;
&lt;p&gt;그래서 내가 에러를 해결한 방법은? 푸시를 하려고 하는 해당 &lt;code class=&quot;language-text&quot;&gt;master&lt;/code&gt; 브랜치에 &lt;strong&gt;protect&lt;/strong&gt; 설정이 있는지 확인했다. 역시나 &lt;strong&gt;protect&lt;/strong&gt; 설정이 되어있었고 그걸 일시적으로 해제해서 해결을 했다.&lt;/p&gt;
&lt;h2&gt;pre-receive hook declined 에러 원인은?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;pre-receive hook declined&lt;/strong&gt;는 에러 양상이 여러가지로 알고 있다. 일반적으로 원인은&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브랜치 권한 문제&lt;/li&gt;
&lt;li&gt;브랜치 protect 문제 (권한 문제로 봐도 무방한 것 같음)&lt;/li&gt;
&lt;li&gt;커밋 메시지 규칙 준수 문제 (이슈 ID를 작성하지 않았다든지)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그냥 그렇게만 알고 있었는데 그 의미를 곱씹어보면 왜 한 가지가 아니라 다양하게 원인이 있는지 추측할 수 있다.
일반적으로 &lt;strong&gt;pre-receive hook declined&lt;/strong&gt; &lt;code class=&quot;language-text&quot;&gt;hook&lt;/code&gt;이 거절됐다는 것인데, 우리가 푸시를 할 때에 &lt;em&gt;git hook&lt;/em&gt;을 걸 수 있는데, 그 단계에서 푸시가 반려되었다고 추측해볼 수 있다. 일반적으로 위에 나열된 브랜치 권한이나 브랜치 보호, 커밋 메시지 규칙 준수 문제의 validation을 git hook으로 작동한다고 추측할 수도 있다. 그래서 해당 에러가 발생하면 어떤 훅이 설정되어있고, 어떤 훅에서 문제가 발생했는지 파악하는 것이 중요할 것 같다.&lt;/p&gt;
&lt;p&gt;또 한가지 팁이 있는데, 사실 &lt;strong&gt;pre-recevie hook declined&lt;/strong&gt; 라인 위에 한 줄이 더 있는데, 아마도 hook에 설정된 메시지 인 것 같은데, 그 메시지가 있는 경우도 아닌 경우도 있을 것 같지만, 해당 메시지가 있다면 그 메시지를 보는 것이 더 원인 파악에 중요할 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[맥북 스크린샷 저장 오류 - 스크린샷 저장이 되지 않을 때 해결법]]></title><description><![CDATA[…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2021-02-13-mac-screenshot-troubleshoot/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2021-02-13-mac-screenshot-troubleshoot/</guid><pubDate>Sat, 13 Feb 2021 15:52:15 GMT</pubDate><content:encoded>&lt;h1&gt;맥에서 갑자기 스크린샷 저장이 되지 않는다?&lt;/h1&gt;
&lt;p&gt;맥에서 스크린샷을 할 때에 &lt;code class=&quot;language-text&quot;&gt;cmd + shift + 3&lt;/code&gt; 또는 &lt;code class=&quot;language-text&quot;&gt;cmd + shift + 4&lt;/code&gt;로 스크린샷을 찍는다. 최근 맥북을 바꾸면서 스크린샷이 되지 않는 문제가 있었다.&lt;/p&gt;
&lt;h2&gt;이전에는 터치바에서 저장 위치를 설정할 수 있었는데..&lt;/h2&gt;
&lt;p&gt;이전 맥북은 터치바가 있는 모델이어서 스크린샷을 찍을 때에 저장될 위치를 선택할 수 있었는데, 새로운 맥북은 터치바가 없으면서 그것이 안된 것으로 추측된다. 그러니까 &lt;em&gt;클립보드로 저장&lt;/em&gt;되도록 설정해둔채로 데이터를 마이그레이션해서 그게 계속 유지되고 있고 터치바가 없어서 따로 옵션을 선택할 수 없었던 것.&lt;/p&gt;
&lt;h2&gt;터치바가 없으면 저장 위치를 설정하지 못하나?&lt;/h2&gt;
&lt;p&gt;그렇지 않다. &lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;cmd + shift + 5&lt;/code&gt;&lt;/strong&gt; 를 누르면 아래와 같이 &lt;strong&gt;메뉴와 함께 스크린샷 도구가 나타난다.&lt;/strong&gt; 메뉴 오른편에 &lt;code class=&quot;language-text&quot;&gt;옵션&lt;/code&gt;을 누르면 &lt;code class=&quot;language-text&quot;&gt;다음으로 저장&lt;/code&gt;에서 저장 방법을 선택할 수 있다. 여기서 원하는 옵션을 누르면 이후 &lt;code class=&quot;language-text&quot;&gt;cmd + shift + 3&lt;/code&gt;이나 &lt;code class=&quot;language-text&quot;&gt;cmd + shift + 4&lt;/code&gt;로 캡처를 해도 &lt;strong&gt;동일한 설정대로 저장된다.&lt;/strong&gt; 😎&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/9648602c48663334f162c905f0012bb0/62522/macos-big-sur-screenshot-menu-record.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 59.45945945945946%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwT/xAAVAQEBAAAAAAAAAAAAAAAAAAABA//aAAwDAQACEAMQAAABWxGb6SAj/8QAGxAAAgIDAQAAAAAAAAAAAAAAARIAAwIRISL/2gAIAQEAAQUC8stZlWChRtRK+D//xAAZEQEAAwEBAAAAAAAAAAAAAAABAAMhAhH/2gAIAQMBAT8B9rsNI8hhP//EABkRAAIDAQAAAAAAAAAAAAAAAAABESExQf/aAAgBAgEBPwGGsZfT/8QAGhABAQACAwAAAAAAAAAAAAAAAQAQEUFRYf/aAAgBAQAGPwJ2c3Um5fcN/8QAHBAAAgICAwAAAAAAAAAAAAAAAREAITFRYbHB/9oACAEBAAE/ISaA2tQC4bYAIiMAhuoDWMu5RqnUFDnwT//aAAwDAQACAAMAAAAQGz//xAAYEQEBAAMAAAAAAAAAAAAAAAABACFBUf/aAAgBAwEBPxBMM5yR0X//xAAWEQEBAQAAAAAAAAAAAAAAAAABAGH/2gAIAQIBAT8QtKtX/8QAGhABAAMBAQEAAAAAAAAAAAAAAQARITFB0f/aAAgBAQABPxBdb8A3rKChOfQIDGNhXhFK2VS86hcAfRhlSK96w//Z&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/9648602c48663334f162c905f0012bb0/1c72d/macos-big-sur-screenshot-menu-record.jpg&quot;
        srcset=&quot;/static/9648602c48663334f162c905f0012bb0/a80bd/macos-big-sur-screenshot-menu-record.jpg 148w,
/static/9648602c48663334f162c905f0012bb0/1c91a/macos-big-sur-screenshot-menu-record.jpg 295w,
/static/9648602c48663334f162c905f0012bb0/1c72d/macos-big-sur-screenshot-menu-record.jpg 590w,
/static/9648602c48663334f162c905f0012bb0/a8a14/macos-big-sur-screenshot-menu-record.jpg 885w,
/static/9648602c48663334f162c905f0012bb0/fbd2c/macos-big-sur-screenshot-menu-record.jpg 1180w,
/static/9648602c48663334f162c905f0012bb0/62522/macos-big-sur-screenshot-menu-record.jpg 1560w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;그러니, 스크린샷이 잘 동작하지 않는다면,&lt;/p&gt;
&lt;p&gt;당장 눌러서 확인해보세요. &lt;strong&gt;cmd + shift + 5&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://support.apple.com/ko-kr/HT208721&quot;&gt;apple 홈페이지&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[마참내!! 나에게도 드디어!! 애드센스! - 애드센스 도전기]]></title><description><![CDATA[Adsnese. 마참내!! (마침내 ㅋㅋ) 애드고사 통과! 사실 오랜기간 여러번 도전했으나 여러 실패를 겪고 거의 반 포기하고 있었다.. 그런데 얼마전. 약 일주일전인가? Jekyll 기반의 블로그를 gatsby…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2021-02-12-adsense/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2021-02-12-adsense/</guid><pubDate>Fri, 12 Feb 2021 14:53:44 GMT</pubDate><content:encoded>&lt;h1&gt;Adsnese. 마참내!! (마침내 ㅋㅋ) 애드고사 통과!&lt;/h1&gt;
&lt;p&gt;사실 오랜기간 여러번 도전했으나 여러 실패를 겪고 거의 반 포기하고 있었다.. 그런데 얼마전. 약 일주일전인가? &lt;em&gt;Jekyll&lt;/em&gt; 기반의 블로그를 &lt;em&gt;gatsby&lt;/em&gt;로 업데이트하면서 한 번 더 도전했고.. 마침내 광고를 개제할 수 있게 되었다는 메일을 받았따.. 와우! 얼마나 수익을 낼 수 있을까라는 것과 별개로 꽤 오랜시간 해보고자 했는데 잘 되지 않았던 것이 드디어 되어서 너무 기쁜 마음이 컸다. 애드센스 통과를 위해 많은 시도를 했던 것은 아니지만.. 약간 감이 잡힌다.&lt;/p&gt;
&lt;h1&gt;나의 애드센스 도전기&lt;/h1&gt;
&lt;p&gt;뭐 사실 도전이라고 하기에는 아주 가끔씩이었지만, 잠깐 썰을 풀어보려한다.&lt;/p&gt;
&lt;h2&gt;애드센스 조건&lt;/h2&gt;
&lt;p&gt;애드 센스를 통과하기 위해서는 많이 알려져 있는 조건들이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;글 개수 (40여개? 사실 그정도는 아니어도 괜찮은 것 같다.)&lt;/li&gt;
&lt;li&gt;포스트당 글자 수 (1000자 내외 수준)&lt;/li&gt;
&lt;li&gt;맞춤법, 주제나 문장의 완성도 등 (의미가 있는 글일 것)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;뭐 여기저기 글을 찾아봐도 엄청난 정답은 없었다. 하지만 주요한 기준은 있었다. &lt;strong&gt;1. 충분한 내용을 포함한 사이트일것&lt;/strong&gt;, &lt;strong&gt;2. 의미가 있는 글로 이루어 질 것.&lt;/strong&gt; &lt;a href=&quot;https://support.google.com/adsense/answer/9724?hl=ko&quot;&gt;공식 문서&lt;/a&gt; &lt;a href=&quot;https://support.google.com/adsense/answer/7299563&quot;&gt;자격요건 문서&lt;/a&gt; 에서는 몇 가지 기준을 제시하고는 있지만 &lt;em&gt;콘텐츠의 품질&lt;/em&gt;, &lt;em&gt;독창적이고 관련성이 높은 고유 콘텐츠&lt;/em&gt; 등의 모호한 말로 설명되고 있는 것 같다. 그래서 위의 기준들이 나오는 것이 아닐까하는 생각이 든다.&lt;/p&gt;
&lt;p&gt;기준으로 또 중요한 내용이 있다. 페이지의 메뉴가 &lt;strong&gt;명확&lt;/strong&gt;하고 &lt;strong&gt;사용하기 쉬울 것&lt;/strong&gt;. 봇이 자동으로 판별하고 있는지는 모르겠지만, 마크업 상태 등을 고려할 때 마크업이 잘 정리되어있고 &lt;strong&gt;웹 접근성&lt;/strong&gt;이 높은 페이지일 수록 쉬운 것 같다.&lt;/p&gt;
&lt;p&gt;내가 한 몇 가지 시도를 공유해보고자 한다.&lt;/p&gt;
&lt;h2&gt;SPA 애플리케이션&lt;/h2&gt;
&lt;p&gt;사실은 블로그를 할 생각은 없었다. qtumprice.cf를 만들던 쯤이었나 ㅡ 그땐 qtumprice에 사실 다른 배너 광고를 붙이긴 했지만 ㅡ 그 때쯤부터 쭉 생각하던 것은 간단한 사이드 프로젝트 형식의 서비스를 만들고 배너를 달아서 소소하게 한달에 치킨값이라도 벌어보고싶다는 생각이 있었다(아마도 모든 개발자의 꿈이 아닐지..ㅋㅋ). qtumprice에도 잠깐 배너 달아본적이 있었지만 진짜 미미해서 걍 관뒀다.. 그래도 웹에서 찾게되는 블로그나 간단한 서비스들을 보면서 나도 이런 걸 해보고 싶다는 생각을 계속 했다. 그래서 싱글 페이지 형태의 웹 서비스들을 가지고 애드센스 신청해봤다. 하지만 참패했다. 사유는 &lt;em&gt;콘텐츠가 없다&lt;/em&gt;는 것이다. 문장으로 따지면 글이 거의 없는 것이나 다름 없었고, 어떤 서비스만을 제공 하는 것인데, 이러한 경우는 콘텐츠가 없는 것으로 판명되었다. 많은 글을 읽어볼 때 ㅡ아마도 블로거들이여서 더 그랬겠지만ㅡ 적당한 페이지 수와 각 페이지의 내용이 필요하다는 것을 알게 되었고 블로그로 시도해보게 되었다.&lt;/p&gt;
&lt;h2&gt;블로그&lt;/h2&gt;
&lt;p&gt;나는 2번의 시도로 블로그로 애드센스 승인이 났다. 사실 그 사이동안 콘텐츠가 어느정도 늘어나긴 했지만, 내가 생각하는 큰 변화는 스킨의 변화였다. 처음 사용했던 theme은 &lt;a href=&quot;https://h01000110.github.io/windows-95/&quot;&gt;이걸&lt;/a&gt; 살짝 변형한 것이었는데, &lt;em&gt;콘텐츠가 없다&lt;/em&gt;는 이유로 반려가 되었다. 사실 객관적으로 봐도 메인 페이지가 너무 빈약하고, 내용을 알기가 어려웠다. 그래서 이번에 블로그를 개편하면서 이 부분을 개선했다. 최신 글들의 목록을 어느정도 볼 수 있게 하고, 각 포스트의 내용을 일부 공개했다. 그랬더니 한번에 성공했다. 아무래도 메인 페이지에서 올 수 있는 얼마나 많은 내용이 뿌려져있는지가 내용을 좌우한 것 같다는 생각이 많이 든다.&lt;/p&gt;
&lt;h1&gt;결론&lt;/h1&gt;
&lt;p&gt;어찌됏건 꽤 긴 시간동안 노력(?) 끝에 성공하게 되었는데, 콘텐츠의 양도 중요하지만, 그 콘텐츠를 어떻게 보여줄 것인가 하는 것도 중요하다는 생각이 든다. 블로그를 만들게 되면서 더더욱 웹점근성에 대한 생각이 많이 들기도 했고, 그래서 잘 알려진 좋은 테마들이 왜 인기가 있는지도 알 것 같다(ㅋㅋㅋ)는 생각이 든다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[최신버전 mobx mobx-react에서 observer re-render 안될 때]]></title><description><![CDATA[최신버전 mobx mobx-react 패키지 설치 후 observer 리렌더링이 되지 않는다?! 😭 오랜만에 새로운 프로젝트를 세팅하느라 React 프로젝트를 만들고, state 관리로는 MobX…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2021-02-11-mobx-v7-observer-rerender/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2021-02-11-mobx-v7-observer-rerender/</guid><pubDate>Thu, 11 Feb 2021 08:40:16 GMT</pubDate><content:encoded>&lt;h1&gt;최신버전 mobx mobx-react 패키지 설치 후 observer 리렌더링이 되지 않는다?! 😭&lt;/h1&gt;
&lt;p&gt;오랜만에 새로운 프로젝트를 세팅하느라 React 프로젝트를 만들고, state 관리로는 &lt;em&gt;MobX&lt;/em&gt;로 결정. &lt;code class=&quot;language-text&quot;&gt;mobx&lt;/code&gt;롸 &lt;code class=&quot;language-text&quot;&gt;mobx-react&lt;/code&gt; 패키지를 설치한다. 테스트로 &lt;code class=&quot;language-text&quot;&gt;observable&lt;/code&gt; 변수를 만들고 &lt;code class=&quot;language-text&quot;&gt;observer&lt;/code&gt; 컴포넌트에서 상태 변화를 확인해본다. 그런데 갑자기 업데이트가 되질 않는다. 도대체 무슨 일인가?! 이것저것 해봐도 한 것은 정확히 똑같은데?!!&lt;/p&gt;
&lt;h2&gt;Enabling decorators&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mobx.js.org/enabling-decorators.html&quot;&gt;공식 문서&lt;/a&gt;에 소개된 바로는, &lt;em&gt;MobX&lt;/em&gt; 버전 6이전까지는 ES.next 데코레이터를 이용해서 &lt;code class=&quot;language-text&quot;&gt;observable&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;computed&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;action&lt;/code&gt;으로 만들기로 되어 있었다. 하지만 데코레이터는 현재 ES 표준이 아니고, 표준화의 과정이 너무 오랜 기간이 소요된다. 그리고 표준이 이전에 데코레이터와는 다른 방식으로 구현되고 있는 것으로 보이고 있다고 한다. MobX 버전 6부터는 &lt;code class=&quot;language-text&quot;&gt;makeObservable&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;makeAutoObservable&lt;/code&gt;을 대신 사용하도록 한다고 한다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;import { makeObservable, observable, computed, action } from &amp;quot;mobx&amp;quot;

class Todo {
    id = Math.random()
    @observable title = &amp;quot;&amp;quot;
    @observable finished = false

    constructor() {
        makeObservable(this)
    }

    @action
    toggle() {
        this.finished = !finished
    }
}

class TodoList {
    @observable todos = []

    @computed
    get unfinishedTodoCount() {
        return this.todos.filter(todo =&amp;gt; !todo.finished).length
    }

    constructor() {
        makeObservable(this)
    }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;mobx와 mobx-react의 올바른 버전 선택은?&lt;/h2&gt;
&lt;p&gt;사실 셋업하는 시점에는 최신 버전의 &lt;code class=&quot;language-text&quot;&gt;mobx&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;mobx-react&lt;/code&gt;를 설치해서 사용하지만, &lt;a href=&quot;https://github.com/mobxjs/mobx-react&quot;&gt;mobx-react 문서&lt;/a&gt;에 따르면 &lt;code class=&quot;language-text&quot;&gt;mobx-react&lt;/code&gt;는 유지보수가 되고 있는 법전이 2가지 존재한다고한다. &lt;code class=&quot;language-text&quot;&gt;mobx&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;mobx-react&lt;/code&gt;는 다음 버전 궁함이 있는 것으로 보인다:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code class=&quot;language-text&quot;&gt;mobx-react&lt;/code&gt; 버전&lt;/th&gt;
&lt;th&gt;&lt;code class=&quot;language-text&quot;&gt;mobx&lt;/code&gt; 버전&lt;/th&gt;
&lt;th&gt;React 버전&lt;/th&gt;
&lt;th&gt;hook 기반 컴포넌트 지원 여부&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;v7&lt;/td&gt;
&lt;td&gt;6.*&lt;/td&gt;
&lt;td&gt;16.8+&lt;/td&gt;
&lt;td&gt;지원&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v6&lt;/td&gt;
&lt;td&gt;4._ / 5._&lt;/td&gt;
&lt;td&gt;16.8+&lt;/td&gt;
&lt;td&gt;지원&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v5&lt;/td&gt;
&lt;td&gt;4._ / 5._&lt;/td&gt;
&lt;td&gt;0.13+&lt;/td&gt;
&lt;td&gt;미지원 (&lt;code class=&quot;language-text&quot;&gt;&amp;lt;Observer&amp;gt;&lt;/code&gt; 로 감싸서 사용)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;혹시나 MobX가 잘 동작하지 않는다면, 버전을 확인해봐야 할 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[eslint 'React' was used before it was defined  @typescript-eslint/no-use-before-define 대처법]]></title><description><![CDATA[‘React’ was used before it was defined ? typescript 기반 CRA 프로젝트를 생성한 다음 eslint…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2021-02-10-typescript-eslint-warning/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2021-02-10-typescript-eslint-warning/</guid><pubDate>Wed, 10 Feb 2021 22:53:41 GMT</pubDate><content:encoded>&lt;h1&gt;‘React’ was used before it was defined ?&lt;/h1&gt;
&lt;p&gt;typescript 기반 CRA 프로젝트를 생성한 다음 eslint르 적용을 다음과 같이 적용했는데,&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;yarn add eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin --dev&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다음과 같은 어이없는 메시지를 발견하고 말았다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;#39;React&amp;#39; was used before it was defined  @typescript-eslint/no-use-before-define&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;정의 전에 &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt;가 사용되었다고? 무슨말인지…🤯&lt;/p&gt;
&lt;p&gt;일반적으로 &lt;code class=&quot;language-text&quot;&gt;no-use-before-define&lt;/code&gt;은 변수 선언 전에 변수가 사용되는 경우를 탐지하고 그 잠재된 위험을 발견하기 위한 워닝이다. 이런 워닝이 왜 &lt;code class=&quot;language-text&quot;&gt;import React from &amp;#39;react&amp;#39;&lt;/code&gt; 구문에서 발생되는 것일까?&lt;/p&gt;
&lt;p&gt;대충 찾아보았는데 프로젝트 내에 &lt;code class=&quot;language-text&quot;&gt;react-scripts&lt;/code&gt; 패키지가 설치되어 있을 텐데, &lt;code class=&quot;language-text&quot;&gt;react-scripts&lt;/code&gt; 내에 의존성으로 설치된 &lt;code class=&quot;language-text&quot;&gt;@typescript-eslint&lt;/code&gt;의 버전과 프로젝트의 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt;에 설치된 버전이 맞지 않아서 충돌하면서 생기는 문제라고 한다.&lt;/p&gt;
&lt;p&gt;간단하게 아래와같에 프로젝트 단 &lt;code class=&quot;language-text&quot;&gt;@typescript-eslint&lt;/code&gt; 의존성을 조절해주면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;yarn add @typescript-eslint/parser@4.0.1 @typescript-eslint/eslint-plugin@4.0.1 --dev&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그러면 그 워닝이 깨끗하게 사라진다.&lt;/p&gt;
&lt;h2&gt;다른 방법: 단순 무시&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;.eslintrc&lt;/code&gt;에 다음과 같이 설정해서 해당 규칙을 무시하는 방법도 있다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;quot;rules&amp;quot;: {
  // note you must disable the base rule as it can report incorrect errors
  &amp;quot;no-use-before-define&amp;quot;: &amp;quot;off&amp;quot;,
  &amp;quot;@typescript-eslint/no-use-before-define&amp;quot;: [&amp;quot;error&amp;quot;]
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;다른 방법: react-scripts 버전&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;react-scripts&lt;/code&gt;버전과도 문제가 있는 것같다. 버전 4 이상에서는 lint 에러가 compile error로 인식된다. 이건 생각보다 귀찮은 문제다. 3점대로 낮추면 이런 문제가 해결된다. &lt;code class=&quot;language-text&quot;&gt;eslint&lt;/code&gt; 버전 관련 내용이 나올경우 별도로 설치한 &lt;code class=&quot;language-text&quot;&gt;eslint&lt;/code&gt; 패키지를 지워본다.&lt;/p&gt;
&lt;p&gt;그럼 클린 코딩 😎&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/typescript-eslint/typescript-eslint/issues/2540&quot;&gt;Github Issue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/63818415/react-was-used-before-it-was-defined&quot;&gt;Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[Gatsby 블로그 github에 빌드/배포하기 (Feat. gh-pages)]]></title><description><![CDATA[Gatsby 블로그 github.io로 빌드/배포하기 최근 Jekyll에서 Gatsby로 블로그를 변경했다. 여러가지 이유가 있겠지만 React 사용에 익숙하고, Gatsby…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2021-02-06-gatsby-deploy-github/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2021-02-06-gatsby-deploy-github/</guid><pubDate>Sat, 06 Feb 2021 19:43:59 GMT</pubDate><content:encoded>&lt;h1&gt;Gatsby 블로그 github.io로 빌드/배포하기&lt;/h1&gt;
&lt;p&gt;최근 Jekyll에서 Gatsby로 블로그를 변경했다. 여러가지 이유가 있겠지만 React 사용에 익숙하고, Gatsby를 활용해보고 싶은 마음이 컸다. 제일 중요한 것은 개발한 블로그를 github.io에 어떻게 보내는 것인가? 하는 것이었다. Netlify를 이용하면 편리해서 많이 이용하는 것 같은데, 사실상 github.io로 블로그를 활용하는 장점을 최대한 활용하고 싶었다. Gatsby 역시도 그 점을 예상했던 것 같다. &lt;a href=&quot;https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/&quot;&gt;문서&lt;/a&gt;에서 안내하고 있으니 말이다.&lt;/p&gt;
&lt;h2&gt;Gatsby 빌드&lt;/h2&gt;
&lt;p&gt;개츠비로 개발한 소스는 &lt;code class=&quot;language-text&quot;&gt;gatsby build&lt;/code&gt;로 빌드할 수 있다. 빌드하게 되면 &lt;strong&gt;public&lt;/strong&gt; 폴더에 빌드 결과물이 생성된다. 이 &lt;code class=&quot;language-text&quot;&gt;public&lt;/code&gt;폴더를 게시하면 되는 것이다. 그러니까 간단하게 생각하면 &lt;code class=&quot;language-text&quot;&gt;gatsby build&lt;/code&gt;를 한 뒤, &lt;strong&gt;public&lt;/strong&gt;폴더의 내용물을 github.io 리파지토리의 &lt;em&gt;master&lt;/em&gt; 브랜치의 루트에 복사하면 된다.&lt;/p&gt;
&lt;h2&gt;gh-pages&lt;/h2&gt;
&lt;p&gt;하지만 매번 빌드해서 복사하고.. 여간 번거로운 일이 아닐 수 없다. 이 것을 도와주는 패키지가 있었으니, 바로 &lt;code class=&quot;language-text&quot;&gt;gh-pages&lt;/code&gt;이다. &lt;code class=&quot;language-text&quot;&gt;gh-pages&lt;/code&gt;가 하는 일은 특정 폴더 내에 있는 파일들을 특정 브랜치에 루트에 구성되게 한다. 즉, 내가 &lt;em&gt;A&lt;/em&gt; 브랜치로 설정해서 &lt;code class=&quot;language-text&quot;&gt;gh-pages&lt;/code&gt;를 실행한다면, 현 브랜치에서 빌드한 public 하위 파일들만으로 &lt;em&gt;A&lt;/em&gt;브랜치가 구성되게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;gh-pages -d public -b master&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;라고 하면 &lt;em&gt;master&lt;/em&gt; 브랜치에 &lt;em&gt;public&lt;/em&gt; 하위 파일들로 구성되게 된다.&lt;/p&gt;
&lt;h2&gt;브랜치 세팅&lt;/h2&gt;
&lt;p&gt;그렇다면 &lt;em&gt;master&lt;/em&gt; 브랜치에 빌드 결과물이 올라가야하니까, 소스는 다른 브랜치에 구성해야한다. 예를들면,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;gatsby&lt;/em&gt;: 개츠비 소스가 포함된 브랜치&lt;/li&gt;
&lt;li&gt;&lt;em&gt;master&lt;/em&gt;: 배포용 브랜치
이렇게 세팅하고 &lt;em&gt;gatsby&lt;/em&gt; 브랜치에서 &lt;code class=&quot;language-text&quot;&gt;gh-pages&lt;/code&gt;를 이용해서 배포를 하면 &lt;em&gt;master&lt;/em&gt; 브랜치에 내용이 들어가게하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;gh-pages의 설치&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;gh-pages&lt;/code&gt;는 개발 디펜던시로 설치한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm install gh-pages -D&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;또는&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;yarn add gh-pages --dev&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;로 설치해서 사용한다.&lt;/p&gt;
&lt;h2&gt;스크립트 세팅&lt;/h2&gt;
&lt;p&gt;기본적으로 위의 커맨드를 이용하면되는데, 좀 더 편하게 사용하려면 &lt;code class=&quot;language-text&quot;&gt;gatsby build&lt;/code&gt;와 함께 &lt;em&gt;package.json&lt;/em&gt;에 스크립트로 등록해둔다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;//package.json
{
  ...
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;deploy&amp;quot;: &amp;quot;gatsby build &amp;amp;&amp;amp; gh-pages -d public -b master&amp;quot;
  }
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;프로젝트 빌드&lt;/h2&gt;
&lt;p&gt;이 상태로 &lt;em&gt;gatsby&lt;/em&gt; 브랜치 (개츠비 소스가 포함된 브랜치) 에서 &lt;em&gt;yarn deploy&lt;/em&gt;를 해보자. 그러면 &lt;em&gt;master&lt;/em&gt; 브랜치에 빌드 결과물들이 들어가서 푸시가 되어있는 것을 확인할 수 있다. 명령어 하나로 깔끔하게 배포까지 할 수 있게 된 것이다. 😆&lt;/p&gt;
&lt;h2&gt;refrence&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/&quot;&gt;Gatsby 문서&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[에러 “error fsevents@2.0.7: The platform ”linux“ is incompatible with this module.”, ”error Found incompatible module.”를 만났을 때]]></title><description><![CDATA[cra 프로젝트를 docker를 이용해 빌드하려고  컨테이너에서 을 실행하도록 했는데 다음과 같은 에러를 마주하게 된다. 아무래도 에러는 특정 모듈이 linux…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2021-01-17-yarn-incompatible-error/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2021-01-17-yarn-incompatible-error/</guid><pubDate>Sun, 17 Jan 2021 10:03:58 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;cra&lt;/em&gt; 프로젝트를 &lt;em&gt;docker&lt;/em&gt;를 이용해 빌드하려고 &lt;code class=&quot;language-text&quot;&gt;node&lt;/code&gt; 컨테이너에서 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;을 실행하도록 했는데 다음과 같은 에러를 마주하게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;yarn install v1.21.1
[1/4] Resolving packages...
[2/4] Fetching packages...
info fsevents@2.3.1: The platform &amp;quot;linux&amp;quot; is incompatible with this module.
info &amp;quot;fsevents@2.3.1&amp;quot; is an optional dependency and failed compatibility check. Excluding it from installation.
error postcss@8.1.9: The engine &amp;quot;node&amp;quot; is incompatible with this module. Expected version &amp;quot;^10 || ^12 || &amp;gt;=14&amp;quot;. Got &amp;quot;13.8.0&amp;quot;
error Found incompatible module.
info Visit https://yarnpkg.com/en/docs/cli/install for documentation about this command.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;아무래도 에러는 특정 모듈이 linux 호환이 안된다는 것 같다? 이런 일이…
&lt;code class=&quot;language-text&quot;&gt;node:latest&lt;/code&gt; 이미지로도 동일했다.
이 문제는 &lt;code class=&quot;language-text&quot;&gt;fsevents&lt;/code&gt; 모듈의 문제로, &lt;code class=&quot;language-text&quot;&gt;fsevents&lt;/code&gt; 모듈이 MacOS를 위한 것이고, linux에서는 안되어서 인 것 같다.
그래서 &lt;strong&gt;yarn.lock&lt;/strong&gt; 파일의 &lt;code class=&quot;language-text&quot;&gt;fsevents&lt;/code&gt;가 포함된 dependency 부분을 제거하는 것으로 해결 가능하다고 한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt;파일의&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  fsevents@^1.2.7, fsevents@^2.0.6:
  version &amp;quot;2.0.7&amp;quot;
  resolved &amp;quot;https://registry.yarnpkg.com/fsevents/-/fsevents-2.0.7.tgz#382c9b443c6cbac4c57187cdda23aa3bf1ccfc2a&amp;quot;
  integrity sha512-a7YT0SV3RB+DjYcppwVDLtn13UQnmg0SWZS7ezZD0UjnLwXmy8Zm21GMVGLaFGimIqcvyMQaOJBrop8MyOp1kQ==&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;부분과&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  optionalDependencies:
    fsevents &amp;quot;^2.0.6&amp;quot;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;부분을 제거한다.&lt;/p&gt;
&lt;p&gt;더욱 같단한 방법으로는 &lt;code class=&quot;language-text&quot;&gt;--ignore-engines&lt;/code&gt; 옵션을 확용한다. 아래와 같이 커맨드를 입력하도록 하면 해결된다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;yarn install --ignore-engines&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;--ignore-engeins&lt;/code&gt; 옵션은 엔진 체크를 무시하는 옵션이다.&lt;/p&gt;
&lt;h3&gt;reference&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/40225844/why-does-yarn-say-found-incompatible-module-when-the-version-is-correct&quot;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/57082249/how-to-fix-error-fsevents2-0-7-the-platform-linux-is-incompatible-with-thi&quot;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[docker container에서 pm2가 시작하자마자 종료될 때]]></title><description><![CDATA[도커 컨테이너에서 pm2를 실행하는 데 바로 꺼질 때 node 프로젝트를 프로덕션 환경에 pm2로 올려보도록 한다. node docker image를 이용해서 docker container…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-12-20-docker-pm2/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-12-20-docker-pm2/</guid><pubDate>Sun, 20 Dec 2020 00:51:10 GMT</pubDate><content:encoded>&lt;h1&gt;도커 컨테이너에서 pm2를 실행하는 데 바로 꺼질 때&lt;/h1&gt;
&lt;p&gt;node 프로젝트를 프로덕션 환경에 &lt;strong&gt;pm2&lt;/strong&gt;로 올려보도록 한다. node docker image를 이용해서 docker container에서 &lt;code class=&quot;language-text&quot;&gt;pm2 start&lt;/code&gt;로 시작하도록 올려본다. 하지만 갑자기 시작하자마자 docker container가 종료된다. 분명 정확하게 프로세스기 실행되었는데.. 어찌된 일일까. 어떻게 해결할까?&lt;/p&gt;
&lt;p&gt;결론부터 말하자면 &lt;code class=&quot;language-text&quot;&gt;pm2&lt;/code&gt;가 아니라 &lt;code class=&quot;language-text&quot;&gt;pm2-runtime&lt;/code&gt;을 이용하면 해결된다.&lt;/p&gt;
&lt;p&gt;그러니까,&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$pm2 start ecosystem.config.js&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;라고 되어있었다면,&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$pm2-runtime start ecosystem.config.js&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;라고 해주면 된다.&lt;/p&gt;
&lt;p&gt;이유는,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;pm2&lt;/code&gt;: 일반적인 용도로 애플리케이션을 백그라운드에 보내고 실행함.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;pm2-runtime&lt;/code&gt;: 도커 컨테이너에서 사용하는 용도로, 애플리케이션을 foreground에 유지하고 컨테이너를 계속 실행하게 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이라고 한다.&lt;/p&gt;
&lt;p&gt;문서에 따르면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The goal of pm2-runtime is to wrap your applications into a proper Node.js production environment. It solves major issues when running Node.js applications inside a container like: Second Process Fallback for High Application Reliability Process Flow Control Automatic Application Monitoring to keep it always sane and high performing Automatic Source Map Discovery and Resolving Support Further than that, using PM2 as a layer between the container and the application brings PM2 powerful features like application declaration file, customizable log system and other great features to manage your Node.js application in production environment.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53962776/whats-the-difference-between-pm2-and-pm2-runtime&quot;&gt;stackOverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[yarn.lock package-lock.json 간 변환]]></title><description><![CDATA[Yarn or NPM…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-12-02-package-lock-yarn-lock-conversion/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-12-02-package-lock-yarn-lock-conversion/</guid><pubDate>Wed, 02 Dec 2020 13:11:10 GMT</pubDate><content:encoded>&lt;h1&gt;Yarn or NPM?&lt;/h1&gt;
&lt;p&gt;웹 개발시 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;이나 &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;을 패키지 매니저로 사용한다. &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;은 거의 동일하다. &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;이 더 기본값이라고 생각할 수 있다. 나는 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;을 선호한다. 내가 처음 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;을 접하던 시기에 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;보다 미세하게 더 빨랐고, 이전에는 패키지를 설치할 때에 &lt;code class=&quot;language-text&quot;&gt;npm install --save&lt;/code&gt;라고 &lt;code class=&quot;language-text&quot;&gt;--save&lt;/code&gt; 옵션을 쓰지 않으면 추가한 패키지가 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt;의 의존성에 작성되지 않았다. 그래서 항상 패키지를 설치할 때에 &lt;code class=&quot;language-text&quot;&gt;--save&lt;/code&gt;라는 옵션을 사용해야하는 번거로움이 존재했다. 그래서 &lt;code class=&quot;language-text&quot;&gt;Yarn&lt;/code&gt;을 선호했다.&lt;/p&gt;
&lt;h1&gt;&lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; or &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt;?&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;을 이용하면 &lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; 파일이 생성되고 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt;을 하게되면 &lt;code class=&quot;language-text&quot;&gt;pacakge-lock.json&lt;/code&gt;파일이 생성되는 것을 확인할 수 있다. 파일 내용을 보면 알겠지만 설치된 의존성 패키지들의 버전이 기록되어있다. 프로젝트가 개발되는 시점에 어떤 의존성이 설치되어있는가 확인할 수 있는 자료가 된다. &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt;파일의 의존성 정보에는 각 패키지의 &lt;strong&gt;특정 버전을 명시&lt;/strong&gt;해서 작성할 수도 있지만, &lt;em&gt;일정 버전 이상&lt;/em&gt;이라든지 조금 더 유연하게 작성할 수 있기 때문에, 이 &lt;strong&gt;lock&lt;/strong&gt;파일 들이 &lt;em&gt;패키지를 설치하는 시점에 어떤 버전을 설치했는지 확인할 수 있는 기준&lt;/em&gt;이 된다. 또한, 개발 하던 시점의 패키지 의존성 상태를 복원할 수 있는 자료가 된다. 즉, &lt;strong&gt;의존성 패키지들의 버전의 일관성&lt;/strong&gt;을 유지하기 위해 필요한 파일이라는 뜻이다.&lt;/p&gt;
&lt;p&gt;이 lock 파일들을 &lt;code class=&quot;language-text&quot;&gt;gitignore&lt;/code&gt;에 추가해야하는지 말아야하는지에 대한 이야기가 있곤 하는데 바로 위 이유 때문에 이 lock파일들은 무조건 유지해야하고 &lt;strong&gt;gitignore처리하면 안된다&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;&lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 간 변환&lt;/h1&gt;
&lt;p&gt;그런데 나는 yarn 개발 환경을 써왔는데, 정작 원격 빌드 환경은 npm을 쓰는 경우에는, 또는 그 반대의 경우에는 어떻게 해야하는가? 좀 황당한 질문이지만 이런 종류가 왕왕있다. 그래서 찾아봤다. 그랬더니 &lt;em&gt;&lt;a href=&quot;https://github.com/imsnif/synp&quot;&gt;synp&lt;/a&gt;&lt;/em&gt; 라는 도구가 있었다. &lt;em&gt;synp&lt;/em&gt;는 &lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; 파일을 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt;파일로 변환하거나 그 반대로 변환해주는 도구이다. &lt;code class=&quot;language-text&quot;&gt;npm install -g&lt;/code&gt; 또는 &lt;code class=&quot;language-text&quot;&gt;yarn global add&lt;/code&gt;로 글로벌로 설치해서 사용할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;yarn global add synp&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;변환은 다음과 같이 커맨드를 입력하여 변환 가능하다:&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;synp --source-file yarn.lock            # will create package-lock.json
synp --source-file package-lock.json    # will create yarn.lock&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그럼 이제 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; 고민 끝 ㅎㅎㅎ&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/50093627/how-to-convert-package-lock-json-to-yarn-lock&quot;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/imsnif/synp&quot;&gt;synp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[[nginx] nginx.conf 설정으로 프록시 서버 쿠키 설정 추가하기]]></title><description><![CDATA[nginx로 프록시 서버를 구성하게 되면, 프록시서버로 연결된 내부 백엔드 구조에서는  등 속성이 위부로 통하는 response에 적용되지 않는 문제가 발생한다. 이럴 때  nginx.conf…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-11-21-nginx-cookie-override/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-11-21-nginx-cookie-override/</guid><pubDate>Sun, 22 Nov 2020 00:01:10 GMT</pubDate><content:encoded>&lt;p&gt;nginx로 프록시 서버를 구성하게 되면, 프록시서버로 연결된 내부 백엔드 구조에서는 &lt;code class=&quot;language-text&quot;&gt;Secure&lt;/code&gt; 등 속성이 위부로 통하는 response에 적용되지 않는 문제가 발생한다. 이럴 때  &lt;strong&gt;nginx.conf&lt;/strong&gt; 파일에서 아래와 같이 &lt;code class=&quot;language-text&quot;&gt;proxy_cookie_path&lt;/code&gt;를 이용하여 설정할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;location /foo {
    proxy_pass http://localhost:4000;
    proxy_cookie_path /foo &amp;quot;/; SameSite=None; HTTPOnly; Secure&amp;quot;;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;크로스 도메인의 경우 &lt;code class=&quot;language-text&quot;&gt;SameSite=none&lt;/code&gt;처리도 필요하다.&lt;/p&gt;
&lt;h3&gt;Refernce&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/48880738/how-to-set-secure-attribute-to-set-cookie-in-nginx-through-nginx-conf-file&quot;&gt;Stackoverflow&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Portal + Hook으로 외부 DOM에 Component 생성하기]]></title><description><![CDATA[Portals - React Portal은 부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링하는 최고의 방법을 제공합니다. Why Portal? Portal은 기존 React Component가 담겨있는 DOM Tree…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-11-17-react-portal/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-11-17-react-portal/</guid><pubDate>Tue, 17 Nov 2020 08:24:48 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://ko.reactjs.org/docs/portals.html&quot;&gt;Portals - React&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Portal은 부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링하는 최고의 방법을 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Why Portal?&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Portal&lt;/strong&gt;은 기존 React Component가 담겨있는 DOM Tree 밖으로 Component를 렌더링을 할 때에 사용할 수 있는 기법이다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;React.Portal&lt;/code&gt;의 &lt;strong&gt;&lt;em&gt;대표적인 유스케이스&lt;/em&gt;&lt;/strong&gt;가 있다. 다이얼로그 처럼 전체 페이지를 덮어쓰면서 튀어나오도록 보이게 하는 컴포넌트들을 나타낼 때이다. 일반적인 경우 모달 다이얼로그는 페이지 전체를 덮어쓰는 방식이기 때문에 &lt;code class=&quot;language-text&quot;&gt;position:fixed&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;z-index&lt;/code&gt; 등 속성을 사용하게 되지만, 결국 부모 엘레멘트의 속성에 영향을 받기 때문에, 페이지 최상단 등에 두게 된다. &lt;strong&gt;redux&lt;/strong&gt;, &lt;strong&gt;mobx&lt;/strong&gt; 등을 이용해 상태관리를 하고 있는 경우에는 다이얼로그의 show/hide를 별도의 공간에서 관리하기 때문에 원격지의 컴포넌트의 상태를 관리하는 것이 간단하지만, 원격지에 있는 컴포넌트가 여간 신경쓰이는 것이 아니게 된다… 이럴 때에 &lt;strong&gt;Portal&lt;/strong&gt;을 사용하면, 기존의 DOMTree 밖으로 컴포넌트를 생성할 수 있기 때문에 부모 엘레멘트의 속성으로 부터 자유로워질 수 있다!&lt;/p&gt;
&lt;h1&gt;Portal의 사용&lt;/h1&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;ReactDOM.createPortal(child, container)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;일반적으로 &lt;code class=&quot;language-text&quot;&gt;index&lt;/code&gt;에 담겨있는 &lt;code class=&quot;language-text&quot;&gt;ReactDOM.render&lt;/code&gt;와 유사하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt;: 렌더링 할 컴포넌트&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;container&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt;를 담을 DOM 엘레멘트&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;예제&lt;/h2&gt;
&lt;p&gt;예제는 &lt;a href=&quot;https://ko.reactjs.org/docs/portals.html&quot;&gt;리액트 공식 문서&lt;/a&gt;에서 잘 제공 하고 있다. &lt;a href=&quot;https://codepen.io/gaearon/pen/jGBWpE&quot;&gt;codepen&lt;/a&gt;도 제공하고 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;app-root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;modal-root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;Portal.js&lt;/strong&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 여기 이 두 컨테이너는 DOM에서 형제 관계입니다.
const appRoot = document.getElementById(&amp;#39;app-root&amp;#39;);
const modalRoot = document.getElementById(&amp;#39;modal-root&amp;#39;);

class Modal extends React.Component {
  constructor(props) {
    super(props);
    this.el = document.createElement(&amp;#39;div&amp;#39;);
  }

  componentDidMount() {
    // Portal 엘리먼트는 Modal의 자식이 마운트된 후 DOM 트리에 삽입됩니다.
    // 요컨대, 자식은 어디에도 연결되지 않은 DOM 노드로 마운트됩니다.
    // 만약 자식 컴포넌트가 마운트될 때 그것을 즉시 DOM 트리에 연결해야만 한다면,
    // 예를 들어, DOM 노드를 계산한다든지 자식 노드에서 &amp;#39;autoFocus&amp;#39;를 사용한다든지 하는 경우에,
    // Modal에 state를 추가하고 Modal이 DOM 트리에 삽입되어 있을 때만 자식을 렌더링하십시오.
    modalRoot.appendChild(this.el);
  }

  componentWillUnmount() {
    modalRoot.removeChild(this.el);
  }

  render() {
    return ReactDOM.createPortal(
      this.props.children,
      this.el
    );
  }
}
class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {clicks: 0};
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    // 이것은 Child에 있는 버튼이 클릭 되었을 때 발생하고 Parent의 state를 갱신합니다.
    // 비록 버튼이 DOM 상에서 직계 자식이 아니라고 하더라도 말입니다.
    this.setState(state =&amp;gt; ({
      clicks: state.clicks + 1
    }));
  }
  render() {
    return (
      &amp;lt;div onClick={this.handleClick}&amp;gt;
        &amp;lt;p&amp;gt;Number of clicks: {this.state.clicks}&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;
          Open up the browser DevTools
          to observe that the button
          is not a child of the div
          with the onClick handler.
        &amp;lt;/p&amp;gt;
        &amp;lt;Modal&amp;gt;
          &amp;lt;Child /&amp;gt;
        &amp;lt;/Modal&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

function Child() {
  // 이 버튼에서의 클릭 이벤트는 부모로 버블링됩니다.
  // 왜냐하면 &amp;#39;onClick&amp;#39; 속성이 정의되지 않았기 때문입니다.
  return (
    &amp;lt;div className=&amp;quot;modal&amp;quot;&amp;gt;
      &amp;lt;button&amp;gt;Click&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}
ReactDOM.render(&amp;lt;Parent /&amp;gt;, appRoot);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;Portal Component&lt;/h2&gt;
&lt;p&gt;사용법은 간단하므로, Portal Component를 만들어서 사용하면 되겠다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React, { FC } from &amp;#39;react&amp;#39;;
import ReactDOM from &amp;#39;react-dom&amp;#39;;

const Portal:FC&amp;lt;any&amp;gt; = ({ children, className = &amp;#39;root-portal&amp;#39;, el = &amp;#39;div&amp;#39; }) =&amp;gt; {
  const [container] = React.useState(document.createElement(el));

  container.classList.add(className);

  React.useEffect(() =&amp;gt; {
    document.body.appendChild(container);
    return () =&amp;gt; {
      document.body.removeChild(container);
    };
  }, [container]);

  return ReactDOM.createPortal(children, container);
};

export default Portal;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;생성된 컴포넌트를 넣고 뺄 때 자연스럽게 &lt;code class=&quot;language-text&quot;&gt;body&lt;/code&gt;에서 사라지게 할 수 있다.&lt;/p&gt;
&lt;h3&gt;출처&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/49426474/can-a-react-portal-be-used-in-a-stateless-functional-component-sfc/59154364#59154364&quot;&gt;Stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[JQuery Uncaught TypeError: a.indexOf is not a function 에러처리]]></title><description><![CDATA[ㅎㅎㅎ 예전에 네이버 블로그에서 작성했던 글이었는데,
최근 어떤 분이 댓글을 달아두셔서 뿌듯했던 포스트라 이쪽으로 옮겨온다. ㅎㅎㅎ Uncaught TypeError: a.indexOf is not a function JQuery…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-11-13-jquery-load-error/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-11-13-jquery-load-error/</guid><pubDate>Fri, 13 Nov 2020 09:41:58 GMT</pubDate><content:encoded>&lt;p&gt;ㅎㅎㅎ 예전에 네이버 블로그에서 작성했던 글이었는데,
최근 어떤 분이 댓글을 달아두셔서 뿌듯했던 포스트라 이쪽으로 옮겨온다. ㅎㅎㅎ&lt;/p&gt;
&lt;h1&gt;Uncaught TypeError: a.indexOf is not a function&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;JQuery&lt;/strong&gt; 프로젝트 상에서 &lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;Uncaught TypeError: a.indexOf is not a function&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위와 같은 에러가 나올때에는
&lt;code class=&quot;language-text&quot;&gt;.load()&lt;/code&gt; function이 있는지 찾아보고, &lt;code class=&quot;language-text&quot;&gt;on(&amp;#39;load&amp;#39;,function(){});&lt;/code&gt;으로 바꾸어주면 됨.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;.load&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;.unload&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;.error&lt;/code&gt;가 &lt;strong&gt;deprecate&lt;/strong&gt;되었다고.&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/38871753/uncaught-typeerror-a-indexof-is-not-a-function-error-when-opening-new-foundat&quot;&gt;stackOverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[[mongoose] mongoose paranoid (soft delete) 적용하기 (feat. plugin)]]></title><description><![CDATA[mongoose는 timestamp라는 옵션을 제공한다. plugin은 스키마별로도 적용할 수 있지만,
전역 플러그인(global plugin)으로 모든 schema…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-08-mongoose-soft-delete-plugin/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-08-mongoose-soft-delete-plugin/</guid><pubDate>Sat, 24 Oct 2020 17:20:15 GMT</pubDate><content:encoded>&lt;p&gt;mongoose는 timestamp라는 옵션을 제공한다.&lt;/p&gt;
&lt;p&gt;plugin은 스키마별로도 적용할 수 있지만,
전역 플러그인(global plugin)으로 모든 schema에 대해서도 적용이 가능하다.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;remove&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;delete&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;이제부터 &lt;code class=&quot;language-text&quot;&gt;delete&lt;/code&gt;를 기록하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;delete&lt;/code&gt;만을 사용한다.
&lt;code class=&quot;language-text&quot;&gt;remove&lt;/code&gt;는 &lt;em&gt;document를 완전히 삭제&lt;/em&gt;할 때 사용한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[mongoose] mongoose 연결하기]]></title><description><![CDATA[mongoose 시작하기 MySQL과 같은 전통적인 SQL 데이터베이스가 여전히 많이 쓰이고 있고, 나도 꽤 익숙한지라..
mongoDB는 자주 접할 기회기 없었는데, javascript…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-24-mongoose-connect/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-24-mongoose-connect/</guid><pubDate>Sat, 24 Oct 2020 16:19:25 GMT</pubDate><content:encoded>&lt;h1&gt;mongoose 시작하기&lt;/h1&gt;
&lt;p&gt;MySQL과 같은 전통적인 SQL 데이터베이스가 여전히 많이 쓰이고 있고, 나도 꽤 익숙한지라..
&lt;em&gt;mongoDB&lt;/em&gt;는 자주 접할 기회기 없었는데, &lt;em&gt;javascript&lt;/em&gt;와의 찰떡 궁합이라는 이야기에 욕심내서 공부겸.. 사용해보려고 한다.&lt;/p&gt;
&lt;h2&gt;mongoose?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;mongoose&lt;/strong&gt;는 &lt;em&gt;mongoDB&lt;/em&gt;의 &lt;em&gt;ODM&lt;/em&gt; 라이브러리이다. &lt;em&gt;ODM&lt;/em&gt;은 &lt;em&gt;Object-Document Mapper&lt;/em&gt;로, &lt;em&gt;ORM(Object-Relation Mapper)&lt;/em&gt;과 유사한 개념이라고 보면 된다.
&lt;em&gt;ODM&lt;/em&gt;을 사용하면 &lt;em&gt;ORM&lt;/em&gt;을 사용할 때와 같은 장점을 가지고 있다고 볼 수 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mongoose&lt;/em&gt;는 &lt;em&gt;mongoDB&lt;/em&gt;를 사용한다고 하면 거의 대부분 &lt;em&gt;mongoose&lt;/em&gt;를 이용한다고 보면 될 정도로 유명하고 많이 쓰이는 라이브러리 같다.
일반적으로는 &lt;em&gt;mongoDB&lt;/em&gt;를 그대로 사용한다기보다 &lt;em&gt;mongoose&lt;/em&gt;를 이용해서 사용한다.
특히, SQL에 익숙하다면 &lt;em&gt;mongoDB&lt;/em&gt;를 사용하게되면 쿼리를 작성하는 것이 달라서 낯설고 어렵게만 다가오는데, &lt;em&gt;mongoose&lt;/em&gt;를 사용하면 한결 편해진다.&lt;/p&gt;
&lt;h2&gt;mongoose의 설치.&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;mongoose&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;으로 설치하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$yarn add mongoose&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;typescript 프로젝트의 경우 아래와 같이 정의를 &lt;em&gt;devDependency&lt;/em&gt;로 설치해주자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$yarn add @types/mongoose --dev&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;mongoDB의 연결&lt;/h2&gt;
&lt;p&gt;이 포스트의 주제다. 그럼 mongoose를 이용해서 어떻게 DB에 연결하는지 알아보자.
&lt;em&gt;mongoDB&lt;/em&gt;의 연결은 &lt;code class=&quot;language-text&quot;&gt;mongoose.connect&lt;/code&gt;로 한다.
스펙은 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;mongoose.connect(&amp;#39;mongodb://username:password@host:port/database?options...&amp;#39;, {useNewUrlParser: true});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;연결에 관한 내용은 &lt;code class=&quot;language-text&quot;&gt;mongoose.connection&lt;/code&gt;이 제공한다. &lt;code class=&quot;language-text&quot;&gt;mongoose.connection&lt;/code&gt;을 이용하면 DB 연결에 대한 콜백이나 에러 핸들링 등도 가능하다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import mongoose from &amp;#39;mongoose&amp;#39;;

mongoose.connect(&amp;#39;mongodb://localhost:27017&amp;#39;, {useNewUrlParser: true});
const { connection } = mongoose;

console.log(&amp;#39;connecting db...&amp;#39;);
connection.on(&amp;#39;error&amp;#39;, console.error.bind(console, &amp;#39;connection error:&amp;#39;));
connection.once(&amp;#39;open&amp;#39;, () =&amp;gt; {
  console.log(&amp;#39;connected to mongo db&amp;#39;);
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 해주면 성공적으로 연결되었을 때, &lt;code class=&quot;language-text&quot;&gt;connected to mongo db&lt;/code&gt;라는 메시지를 콘솔에서 확인할 수 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Jira 스마트 커밋(Smart Commit) 사용하기]]></title><description><![CDATA[이슈 관리를 위해 Jira를 사용하고 있다.
일반적으로 Bitbucket과 연동해서 사용하고 있을텐데, 원격 저장소에 커밋을 할 경우 연동된 Jira 이슈에 몇가지 부가적인 기능을 하게 할 수 있다.
이것을 스마트 커밋 (Smart Commit…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-22-jira-smart-commit/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-22-jira-smart-commit/</guid><pubDate>Thu, 22 Oct 2020 13:05:21 GMT</pubDate><content:encoded>&lt;p&gt;이슈 관리를 위해 Jira를 사용하고 있다.
일반적으로 Bitbucket과 연동해서 사용하고 있을텐데, 원격 저장소에 커밋을 할 경우 연동된 Jira 이슈에 몇가지 부가적인 기능을 하게 할 수 있다.
이것을 &lt;strong&gt;스마트 커밋 (Smart Commit)&lt;/strong&gt;이라고 부른다. &lt;strong&gt;스마트 커밋(Smart Commit)&lt;/strong&gt;은 다음과 같은 몇 가지 기능을 제공한다.&lt;/p&gt;
&lt;h1&gt;스마트 커밋 문법&lt;/h1&gt;
&lt;p&gt;스마트 커밋은 다음과 같이 커밋을 작성하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;ignored text&amp;gt; &amp;lt;ISSUE_KEY&amp;gt; &amp;lt;ignored text&amp;gt; #&amp;lt;COMMAND&amp;gt; &amp;lt;optional COMMAND_ARGUMENTS&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;ignored text&amp;gt;&lt;/code&gt;는 아무 텍스트이다.
예를들면,&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;Chore: ABC-123 코멘트 테스트 #comment Hello, World!&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;라고 커밋 메시지를 작성하면, &lt;strong&gt;ABC-123&lt;/strong&gt; 이라는 Jira 이슈에 &lt;em&gt;‘Hello, World!’&lt;/em&gt;라는 댓글이 달리게 된다.&lt;/p&gt;
&lt;p&gt;스마트 커밋은 3가지 커맨드를 제공한다&lt;/p&gt;
&lt;h1&gt;댓글 - &lt;code class=&quot;language-text&quot;&gt;#comment&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;방금 위에서 알아보았던 이슈에 댓글을 달기다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;ABC-123 #comment Hello World&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;ABC-123&lt;/strong&gt;이라는 지라 이슈에 &lt;em&gt;‘Hello World’&lt;/em&gt;라는 댓글이 달린다.&lt;/p&gt;
&lt;h1&gt;소요시간 입력 - &lt;code class=&quot;language-text&quot;&gt;#time&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;소요시간 단위를 입력할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;ABC-123 #time 3m Hello World&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;라고하면 &lt;strong&gt;ABC-123&lt;/strong&gt;이라는 이슈에 &lt;strong&gt;시간추적&lt;/strong&gt; 3분 로그가 추가되고, &lt;em&gt;‘Hello World’&lt;/em&gt;라는 댓글이 달린다.
소요시간은 이슈에 일일이 입력하기 너무 번거로운 점이 있는데, 이런식으로 하면 소요시간을 입력할 수 있고, 앞으로 업무 예측하기 좋아진다.&lt;/p&gt;
&lt;h1&gt;transition&lt;/h1&gt;
&lt;p&gt;이슈의 상태를 바꿀 수 있는 커맨드이다. 워크플로우의 각 상태를 이어주는 화살표를 &lt;strong&gt;transition&lt;/strong&gt;이라고 부르고, 커밋을 통해 Jira 이슈의 상태를 바꿀 수 있다.
만약 워크플로 상에 &lt;code class=&quot;language-text&quot;&gt;close&lt;/code&gt;라는 트랜지션이 존재한다면&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;TEST-23 #close Fixed this today&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;라고 커밋을 하면 &lt;strong&gt;TEST-23&lt;/strong&gt;이라는 이슈에 &lt;em&gt;Fixed this today&lt;/em&gt;라는 댓글이 달리면서 이슈는 닫히게 된다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[스크럼의 이론과 실천에 대한 가벼운 안내서]]></title><description><![CDATA[이 글은 ScrumPrimer…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-13-scrum-overview/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-13-scrum-overview/</guid><pubDate>Tue, 13 Oct 2020 08:58:53 GMT</pubDate><content:encoded>&lt;p&gt;이 글은 &lt;a href=&quot;https://scrumprimer.org/translations&quot;&gt;ScrumPrimer&lt;/a&gt; 사이트의 스크럼의 이론과 실천에 대한 가벼운 안내서를 요약한 글입니다. 요즘 여기저기서 &lt;em&gt;애자일&lt;/em&gt;을 도입한다, &lt;em&gt;스크럼&lt;/em&gt; 도입한다고만 하면서 여러가지 이유로 실제로 잘 운영되지 못하는 경우가 많은데… 내용을 보니 정말 중요한 이야기들이 많아 공유하려 합니다.&lt;/p&gt;
&lt;h1&gt;개요 Overview&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;스크럼&lt;/em&gt;은 &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-functional_team&quot;&gt;다기능팀&lt;/a&gt;&lt;/em&gt;이 제품이나 프로젝트를 &lt;strong&gt;반복적&lt;/strong&gt;이고 &lt;strong&gt;점진적&lt;/strong&gt;인 방식으로 개발하기 위한 개발 프레임워크&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;스프린트&lt;/em&gt;라고 불리는 주기로 구성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;반복 주기는 4주를 넘지 않으며 (보통 2주)&lt;/li&gt;
&lt;li&gt;멈추지 않고 하나가 끝나면 다음것이 시작&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;시간이 고정&lt;/strong&gt; (&lt;em&gt;timeboxed)&lt;/em&gt;되어있음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일이 끝났던, 끝나지 않았던 기간이 &lt;strong&gt;절대 늘어나지 않고 정해진 날짜에 끝&lt;/strong&gt;난다.&lt;/li&gt;
&lt;li&gt;보통 스크럼 팀은 스프린트의 길이를 정해놓고 개선해서 주기를 더 짧게 할 수 있을
때 까지는 모든 스프린트를 그 길이로 진행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매 스프린트 시작 시 다기능팀(약 7명)은&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;우선순위가 매겨진 리스트에서 아이템(요구사항)을 고름&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프린트가 끝날 때 어떤 &lt;strong&gt;결과물&lt;/strong&gt;을 낼 수 있을지 합의&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;결과물은 분명하고 정말로 &lt;strong&gt;“완료”&lt;/strong&gt;라고 할 수 있는 것을 말함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프린트 동안은 &lt;strong&gt;어떤 새로운 아이템도 추가되지 않음.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;다음 스프린트&lt;/em&gt;에 대한 변화는 수용&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;현재의 짧은 스프린트&lt;/em&gt;는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;작고&lt;/li&gt;
&lt;li&gt;분명하며&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상대적으로 안정적인 목표에 집중&lt;/strong&gt;해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;매일 진척사항에 대해 간단히 점검 + 남은 일을 완료하기 위해 필요한 다음 단계 조정&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프린트가 끝날 때&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이해관계자와 해당 스프린트에 대해 검토하고 시연함&lt;/li&gt;
&lt;li&gt;다음 스프린트에 반영될 수 있는 피드백 수집&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스크럼에서는 스프린트가 끝날 때 &lt;strong&gt;작동할 수 있는 제품&lt;/strong&gt;을 만드는 것이 강조&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시스템이 통합되고&lt;/li&gt;
&lt;li&gt;완전히 테스트 되었으며&lt;/li&gt;
&lt;li&gt;최종 사용자를 위한 문서가 작성되었고&lt;/li&gt;
&lt;li&gt;잠재적으로 출시 가능한 제품&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스크럼의 주요한 주제는 &lt;strong&gt;검토&lt;/strong&gt;와 &lt;strong&gt;조정&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/2c8233265b6fc401b4e6c05417f3804b/2f8cb/scrum_diagram.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 53.37837837837838%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACCUlEQVQoz52SXW/ScBTG+/X8HN76AfwC3iwxXu3GRGPMXFCme4ksG7qROTdGCAjdxijQMimvBVb6QmmB8bOt6TKWeeNJTvo///Oc5/+cJxUWiwX3I6iju+FwiCiKVCoVEokEsVgMRVHucI+FEDXm01mAWgJrmhYSBplMJonH4w8IF5GKuxSC2nZd1k/SZJV62L+NHpnP8TwvzOA8m83C78NNovMiItSnHu9zWU7r8t2r/1rpvjWP4YRRV6OUTOFaJmJrxNpZnb7pRGNLA5OJh207uJPp301u5yEmqPUby+9PEbRshvTKCrZSY1fWebF3yVXXDAd03eHDu2Muz9UQLNdaSOVrxvZkSdVA65M9y9FtthEc20DvNMPGyBqj9nrMpi5T1+G61uT16gEf19LsJ4rsbOYQfzVCbOCnWi362AlS9juvnj9FksoIrWqKxsUh+lBDVVXaLclXYyLl48jlHSxrxkHygtS3c44OS2ROKyFh4Wibl8+e+KoUBo0O4vE+SlND6Hd/I18V0Hoa5VKdfL5Mpz1CLJz4/1+ea6XPl09Ztj6n2drIsL2R862wkEo5fuxv+tgmu18vebt+xnmxijAeOxiWhet6DPsm/Z6Oodu+sjFBbziwKF00Of0p+T7VqJTbmKaNYRjc+MSOY9HrGqy+OUaWOwhz3wvLJ/Q8l/8N23LoqD2cscsfBdo0bo3r/awAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/2c8233265b6fc401b4e6c05417f3804b/fcda8/scrum_diagram.png&quot;
        srcset=&quot;/static/2c8233265b6fc401b4e6c05417f3804b/12f09/scrum_diagram.png 148w,
/static/2c8233265b6fc401b4e6c05417f3804b/e4a3f/scrum_diagram.png 295w,
/static/2c8233265b6fc401b4e6c05417f3804b/fcda8/scrum_diagram.png 590w,
/static/2c8233265b6fc401b4e6c05417f3804b/efc66/scrum_diagram.png 885w,
/static/2c8233265b6fc401b4e6c05417f3804b/c83ae/scrum_diagram.png 1180w,
/static/2c8233265b6fc401b4e6c05417f3804b/2f8cb/scrum_diagram.png 1689w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h1&gt;스크럼에서의 역할들 (Scrum Roles)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;제품 책임자&lt;/strong&gt;와 &lt;strong&gt;팀&lt;/strong&gt;, &lt;strong&gt;스크럼마스터&lt;/strong&gt;가 있음.&lt;/p&gt;
&lt;h2&gt;제품 책임자 (Product Owner)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;투자 수익률(ROI)를 최대해야할 책임&lt;/li&gt;
&lt;li&gt;&lt;em&gt;기능(Feature)&lt;/em&gt;를 식별하고&lt;/li&gt;
&lt;li&gt;이것을 반영해 리스트의 우선순위를 수립하여&lt;/li&gt;
&lt;li&gt;어떤 것이 리스트의 가장 위에 와야하는지 결정&lt;/li&gt;
&lt;li&gt;지속적으로 리스트의 우선순위를 재조정 + 개선&lt;/li&gt;
&lt;li&gt;제품이 상업적인 경우, 제품 책임자는 &lt;strong&gt;제품의 손익에 대한 책임이 있다&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;고객과 제품책임자가 같을 수도 있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Product Manager나 Product Marketing Manager의 역활과 비슷하지만 기존 Product Manager와는 다름&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제품 책임자는 프로젝트 관리자에게 개발에 대한 결정권을 위임하는 것이 아님&lt;/li&gt;
&lt;li&gt;팀과 적극적인 소통 + 모든 이해관계자들과 협업을 통해 ⇒ 매 스프린트의 결과를 검토하며 우선순위를 정함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;스크럼의 최종 권한을 가진 책임자는 오직 1명&lt;/strong&gt;이며 업무의 가치에 대한 책임이 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;팀&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;개발팀이라고도 함&lt;/li&gt;
&lt;li&gt;제품 책임자가 지시하는 제품(App, Web, etc.)을 만든다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;다기능 (cross-functional)&lt;/strong&gt; = 필요한 모든 전문 지식을 가지고 있어야 함.&lt;/li&gt;
&lt;li&gt;높은 수준의 자율성과 책임을 가진 &lt;strong&gt;자기조직(self-organizing, self-managing)&lt;/strong&gt;이어야 함.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제품 책임자가 제안한 것들 중 한 스프린트 동안&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;몇 개의 아이템을 완성할 지&lt;/li&gt;
&lt;li&gt;목표 달성을 위한 방법을 결정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;고정된 전문가는 없으며, 매 스프린트가 진행되는 동안 스스로 정한 목표의 달성을 위해 &lt;strong&gt;어떤 방식으로든&lt;/strong&gt; 함께 일한다.&lt;/li&gt;
&lt;li&gt;오직 팀원만 있기 때문에 &lt;strong&gt;다중학습(multi-learning)&lt;/strong&gt;이어야 함.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;팀 구성은 7명~2명 안팎&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제품을 개발&lt;/li&gt;
&lt;li&gt;제품 책임자에게 어떻게 제품을 훌륭하게 만들 것인지에 대한 아이디어를 제시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스프린트 동안 하나의 제품을 위해서 100% 몰두해서 일할 수 있을 때 가장 생산적 &amp;#x26; 효율적
⇒ &lt;strong&gt;주의가 분산되거나 흐름이 바뀌면서 낭비되는 것을 막아야 함.
여러 제품이나 프로젝트에 걸쳐져서 동시에 여러 작업을 하게 되는 것을 피해야 함.
팀원이 바뀌는 것을 지양&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;하나의 팀이 고객 중심의 기능들을 완성하기 위한 모든 일(계획, 분석, 프로그래밍, 테스트)을 종종 하므로 이런 팀은 또한 &lt;em&gt;기능팀(feature team)&lt;/em&gt;이라고도 불린다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;스크럼마스터(ScrumMaster)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;제품 그룹이 사업적인 가치를 만들기 위해서 스크럼을 배우고 적용하는 것을 돕는다.&lt;/li&gt;
&lt;li&gt;팀과 제품 책임자, 조직이 성공하기 위해 가능한 모든 일을 돕는다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;관리자가 아니며, 프로젝트 관리자도 아니고 팀 리더도 아니며 팀 대표자도 아님!
단지 도움을 주는 사람&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장애물을 제거&lt;/li&gt;
&lt;li&gt;외부의 간섭으로부터 보호&lt;/li&gt;
&lt;li&gt;새로운 개발 방식에 적응할 수 있도록 도움&lt;/li&gt;
&lt;li&gt;제품 책임자와 팀 그리고 다른 조직원이 스크럼을 능숙하게 사용할 수 있도록 가르치고 지도하고 설명&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;비록 작은 팀의 경우는 팀원이 기존에 하던 일을 줄이고 이 역할을 할 수도 있지만, &lt;strong&gt;그래도 모든 시간 동안 이 일에만 전념하는 스크럼마스터가 있어야 한다&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;스크럼마스터와 제품 책임자는 &lt;strong&gt;초점이 매우 다르며&lt;/strong&gt; 병행할 경우 혼란이나 충돌이 생기기 때문에 &lt;strong&gt;같은 사람이 맡을 수 없다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;참고: 스크럼에서는 &lt;strong&gt;프로젝트 관리자의 역할이 전혀 없다.&lt;/strong&gt; 왜냐하면 전혀 필요하지 않기 때문이다. 기존의 프로젝트 매니저가 맡았던 일들은 스크럼의 세 가지 역할에 나누어 할당되는데 스크럼 마스터보다는 팀과 제품 책임자에게 대부분 할당한다. 스크럼을 하면서 프로젝트 관리자를 추가한다는 것은 &lt;strong&gt;스크럼을 근본적으로 잘못 이해하고 있다는 것&lt;/strong&gt;을 말한다. 그리고 이런 경우 일반적으로 책임들 간의 충돌, 분명하지 않은 권한, 차선의 결과 같은 것들이 발생한다. 때론 프로젝트 관리자가 스크럼마스터의 역할을 하게 될 수 있지만 이런 접근방식이 전적으로 성공할 수 있을지는 개인이 얼마나 두 역할의 근본적인 차이에 대해서 이해를 했는지, 그날그날의 역할과 성공하기 위한 마음가짐을 모두 이해했는지에 달려있다. 스크럼마스터의 역할을 완전히 이해하고 성공하기 위한 핵심 기술들을 개발하기 위한 좋은 방법은 Scrum Alliance의 Certified ScrumMaster 교육을 받는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;기타 역할&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;제품의 성공에 기여하는 다른 이해관계자들&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;직무 관리자&lt;/li&gt;
&lt;li&gt;공학 관리자 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스크럼을 적용할 때에는 변해야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그들은 스크럼의 규칙들과 참뜻을 존중함으로써 팀을 지원한다.&lt;/li&gt;
&lt;li&gt;그들은 팀과 제품 책임자가 찾은 장애물을 제거하는 것을 돕는다.&lt;/li&gt;
&lt;li&gt;그들은 그들의 전문 지식과 경험을 쓸 수 있도록 한다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;⇒ 업무를 할당하고 현황 보고서를 받고 다른 형태의 세세한 관리 → 멘토링, 코칭, 장애물 제거를 돕기, 문제를 해결하는 것을도와주기, 창의적인 조언 제공, 팀원들의 기술 개발 지도&lt;/strong&gt; 로 변화&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;제품 백로그 (Product Backlog)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;스프린트 시작 전에 제품 백로그가 있어야 함&lt;/li&gt;
&lt;li&gt;사용자 중심의 기능들을 우선순위를 매겨 리스트화&lt;/li&gt;
&lt;li&gt;제품 수명기간 동안 계속 존재하고 개선되면서 &lt;strong&gt;해당 제품의 로드맵 역할&lt;/strong&gt;을 함&lt;/li&gt;
&lt;li&gt;우선 순위에 따라 기록된 것이 한눈에 명확히 드러나야 함&lt;/li&gt;
&lt;li&gt;하나의 제품에 대해 오직 하나의 제품 백로그만 존재: &lt;strong&gt;제품 책임자는 팀을 포함해 이해관계자들의 관심사를 전반적으로 반영하여 우선순위를 결정해야함.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/20a8024431aa0a40929923dd5535f3b7/5a3c9/scrum_backlog.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 95.94594594594595%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAAEIElEQVQ4y12U21NTVxTG8yf1oX9BO9OHvvShM+1M7YxObTt1HBvlLkkDxATIlYSQREyAAEGEChTQarVWndqOtR3FYriIXARygYSEcIvc5te9DqR2ema+s/bes9b3ffvsfZZuc3OT9fV1DTIWbG9vs7W19e98Y2ODnZ0dbV1iPp/nyZMnPHv2jIWFBdbW1rR8iTp5ZTIZdnd3OTw85ODgQCORBBnv7++zt7dHPB7XIGRSk06nSaVSrK6uks1mNVGJuvn5eWZnZ1laWtIKVlZWNFWBJEiBIBaLMTk5qeUsLi5qZMlkUkMikdDWJepEaXl5mfHxca1AIAKvXr3i5cuXzM3NaWJCKs4kimiRrIiigE4SpGBqaoqZmRmNSEjEoUTZgURJFnFxIcWCFYV4IsnS8hFhSghFTRxOT08zMTGhbUcEZE22nFOQKHnyrYuEMhekUuI2dTxOoZPCeeXg7+fP1XYnNMj2x8bGeK7WxLnkiJC4nJPvrcayJohrURk4NqE5TCiFpUSK/OYWO4U3FAq72hUpolAoKLzRkN9Q10jlFZHPqxuxvaPqCtpJ63Z398ilU6TnYsRn1YFMv2Bi/A9ik+pUpyaVw0l1ONMsvJ4lmXhNPpOksJFhfzvHQSEPhztkU0skF18jj24tm+PxnRHue0u45asmYDqHqfRzSr/+gm/PnqWsspzaSyZaGixcb/Pz8HY/47/dYuav+yRijyisTnC328P1Vs9bwvu3hhl0lXGvzcqAr46Qsw6bXo+5sgJLvQW318kVayN9gQA/XO/h56Fr/H57kNivN1kcf8Tj4TBPfxk6Iszmcvx0Y5jWWj19zbX0eGuJuEz4G00E3JcINtsJBz10dwTpu9rOYLSN0f4ID0Z7+fPOAC8e/ciNriZmxh4UCdcZGRrk4tlTOIwXsFXrtdhsMRBssnK5xUGr30Mo6KM9HKTjip/erhCj33dxdyjKvdFr3OxpIbPw9O2WhxVh+TcncdRU4airxnnJgFsRehxmWjyNCg78viaCijQUaKazrZW+aDsD0RADvRHCbjMPR6JHhJm1HH39/ei/PIGjVhEqskazEWe9CbfDisfVSJPLhs/jIhBs4UrAR6TtMt2dYbpV7O3p5MLpT7ErM8eEWaLRq5w5+RlWQxVm40XMNUZM1eV8Z6yipsZAvdVIQ4MZm92G2+3E63Xj9TiVmA2/38dXH3+It+6YcDWdIRRq4/SJTzCUlVBZcp7SkgtUlJ2nolzNqyowGPWYag2YrVYaHXYcLgWHDbu9HpcSeO/dd7BU6N867OnppfTcGewWM5a6GhqsZpyOBlwuB+4mF26Pl2a/n9ZwmPbOTiLdXUS6IkQ6O+iIdPDR+x9gqa4+Iix2Wvnp06rzJBJx7SeXWOwu0hz+27H/j7zq9tuKR55/AEgx5OV6+n5GAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/20a8024431aa0a40929923dd5535f3b7/fcda8/scrum_backlog.png&quot;
        srcset=&quot;/static/20a8024431aa0a40929923dd5535f3b7/12f09/scrum_backlog.png 148w,
/static/20a8024431aa0a40929923dd5535f3b7/e4a3f/scrum_backlog.png 295w,
/static/20a8024431aa0a40929923dd5535f3b7/fcda8/scrum_backlog.png 590w,
/static/20a8024431aa0a40929923dd5535f3b7/efc66/scrum_backlog.png 885w,
/static/20a8024431aa0a40929923dd5535f3b7/5a3c9/scrum_backlog.png 1169w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;백로그는 아래 내용들을 모두 포함한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;새로운 기능 (e.g. 모든 사용자는 장바구니에 책을 담을 수 있다)&lt;/li&gt;
&lt;li&gt;개발에 대한 발전적인 목표 (e.g. 시스템을 C++ 에서 Java기반으로 변환한다)&lt;/li&gt;
&lt;li&gt;팀의 개선 목표 (e.g. 테스트 속도를 향상시킨다)&lt;/li&gt;
&lt;li&gt;연구 업무 (e.g. 신용 카드 인증 속도를 향상하기 위한 해결책 조사)&lt;/li&gt;
&lt;li&gt;결함 (결함이 많을 경우 별도의 추적 시스템을 사용)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아이템은 어떤 방식으로든 분명하고 계속 유지될 수 있도록 표현&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대부분의 아이템들은 고객 가치 전달에 초점이 맞추어져 작성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DEEP&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Detailed appropriately&lt;/strong&gt;
최우선 순위의 아이템은 낮은 우선순위의 아이템보다 먼저 진행되기 때문에 &lt;strong&gt;상세하고 세밀하게 기술&lt;/strong&gt;되어야 함&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Estimated&lt;/strong&gt;
팀은 제품 책임자에게 제품 백로그의 각 아이템에 대해 해당하는 &lt;strong&gt;일의 양 (effort)와 기술적인 위험성(technical risk)에 대한 추정치를 제공&lt;/strong&gt;해야 함.
사업적 이해관계자들은 제품 &lt;strong&gt;요구사항의 가치에 대한 정보&lt;/strong&gt;(수익, 비용절감, 사업적 리스크, 중요성 등)를 다양한 이해관계자들에게 전달해야 함.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Emergent&lt;/strong&gt;
제품 책임자는 학습 내용, 변동사항에 따라 제품 백로그는 자주 개선해야 함.
매 스프린트마다 우선순위에 따라 추가/제거/수정 등 변경을 거침&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Prioritized&lt;/strong&gt;
제품 백로그의 최우선 순위 아이템부터 1에서 N까지 순서로 우선순위가 매겨져야 함.
최우선 순위의 아이템들은 &lt;strong&gt;적은 비용으로 큰 가치를 내는 것&lt;/strong&gt;이어야함
&lt;em&gt;큰 위험을 포함하고 아이템의 우선순위를 높게 잡는 방법(tackle high risks early, before the risks atack you)&lt;/em&gt;도 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스크럼마스터는 사업적 가치를 가늠하는 법을 배울 수 있게 도와야 함&lt;/li&gt;
&lt;li&gt;스크럼에는 매 스프린트마다 일이 얼마나 끝났는지 추적하는 기술이 있음 ⇒ 속도velocity&lt;/li&gt;
&lt;li&gt;다가오는 스프린트의 제품 백로그 아이템들은 팀이 이 아이템들에 대해서 이해할 수 있을 만큼 &lt;strong&gt;충분히 세분화되어서 스프린트 계획 때 팀이 유의미한 예측&lt;/strong&gt;을 할 수 있어야 함 ⇒ &lt;strong&gt;“실행가능한(actionable)” 크기&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시간과 비용이 많이 드는 주요한 기술 개선사항은 제품 백로그에 포함돼야함.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가벼운 기술사항에 대해서는 독자적으로 맡아 진행할 수 있더라도, 매 스프린트마다 팀은 대부분 시간을 내부적인 기술 업무 보다는 제품 책임자가 정한 목표를 위해 사용해야함.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;무엇이 중요한지를 최소한으로 명시해야 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;완료 기준 (Definition of Done)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;매 스프린트의 산출물 = 잠재적으로 출시 가능한 제품 증분 (Potentionally Shippable Product Increment)&lt;/li&gt;
&lt;li&gt;제품을 출시하기 위해 필요한 모든 활동 = 잠재적으로 출시 가능이라는 말의 정의에 포함되어야 함 (그러므로 스프린트 동안 끝나야 함)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매 스프린트마다 잠재적으로 출시 가능한 제품을 전달하는데 실패할 경우&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀이 자동화가 덜 되었거나&lt;/li&gt;
&lt;li&gt;충분히 다기능적이지 않기 때문&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스프린트 시작 전 제품 책임자와 팀은 완료 기준에 대해 합의를 봐야함.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좋은 제품 책임자?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;완료기준이 가능하면 잠재적으로 출시할 수 있을 수준&lt;/li&gt;
&lt;li&gt;개발이 투명해지고 지연되는 경우가 줄어들며 리스크가 감소&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;스프린트 계획(Sprint Planning)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;매 스프린트 시작 전 스프린트를 준비하기 위한 회의로, 2개의 파트로 나뉜다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파트1: &lt;strong&gt;“무엇(what)”&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;파트2: &lt;strong&gt;“어떻게(how)”&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;참가자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파트1: 제품 책임자, 팀, 스크럼마스터&lt;/li&gt;
&lt;li&gt;파트2: 팀, 스크럼마스터, 제품 책임자(optional)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;기간: 각 파트는 스프린트의 한 주당 한 시간 이내로 제한&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;스프린트 계획 파트1&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;제품 책임자와 팀이 제품 백로그 중 제품 책임자가 이번 스프린트에서 진행되길 원하는 우선순위가 높은 아이템들을 검토&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;지난 스프린트에서 제품 백로그 개선을 하는 동안 분석되었으므로 간단히 질문에 대해서 한 번 명확히 하는 작업만 진행&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;우선순위가 높은 아이템에 대한 목표와 내용에 대해서 정의&lt;/li&gt;
&lt;li&gt;제품 책임자의 의도 파악&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;제품 책임자가 무엇을 원하고 그것이 왜 필요한지 초점&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;스프린트 목표&lt;/strong&gt;를 정한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이상적으로는 짜임새가 있는 주제를 담고 있을 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;아이템의 이상적인 규모 = 전체 스프린트에 비해 현저히 작게 쪼개질 것 (스프린트 기간의 1/4 이내에 완수될 수 있을 정도의 크기)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;스프린트 계획 파트2&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;아이템을 &lt;strong&gt;어떻게 수행&lt;/strong&gt;할 지에 대해서 초점&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;팀은 제품 백로그의 우선순위가 높은 것부터 순차적으로 해당 스프린트가 끝날 때까지 할 수
있는 아이템의 수를 예측&lt;/strong&gt; ⇒ 핵심!
&lt;strong&gt;스크럼에서는 완수해야 할 작업을 제품 책임자가 팀에 할당하는 것이 아니라, 팀이 스스로 할 수 있는 작업의 양을 결정하는 것을 중요&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;팀은 우선순위가 아래에 있는 제품에 대해서도 영향력을 행사할 수 있음 (보통 팀과 제품 책임자 둘 다 현재 우선순위가 아래에 있는 아이템이 더 위에 있는 것이 적절하다고 생각하는 경우)&lt;/li&gt;
&lt;li&gt;스프린트 계획 회의는 2주 단위의 스프린트를 기준으로 4시간을 넘지 않도록 제한&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;수용 능력을 활용하는 방식으로 목표치 결정하기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;업무 수행에 얼만큼의 시간을 쓸지 추정&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스프린트와 관련된 업무를 수행하는데 쓸 시간 = 회의 참석, 메일, 휴식시간 등은 제외하는 개념&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;일반적으로 하루 4~6시간 정도 = 스프린트에 대한 수용 능력&lt;/li&gt;
&lt;li&gt;수용 능력이 정해지고 나면 기간동안 제품 백로그에 있는 아이템 몇개를 할지, 완수할지 검토&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아이템 선정&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;지난 스프린트의 회고 때 나온 개선 목표를 위한 작업&lt;/li&gt;
&lt;li&gt;제품 백로그에서 제품 책임자가 가장 우선순위를 높게 설정해놓은 아이템을 골라서 ‘충분’할 때까지 세분화&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스프린트 동안 해야 하는 일에 대한 리스트 = &lt;strong&gt;스프린트 백로그(Sprint Backlog)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/78cd45d8006a8f0496e47a5a124cbfd1/a9965/scrum_sprint_backlog.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 31.08108108108108%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA80lEQVQY0z1R16qEQBTz/79M0BdlFffae++KWCCXHHAfwmmZzMmMsm0biGmasCwL9n3Hfd84z1Nqzpgfx4F1XWXe9z3SNEWSJPh8PrBtG3meYxxHKCRQrCxLabyC13WhrmvpPc8josMwCNq2heM4aJpGhIqikJxQXkJVVXKz7/vQNA2WZSEIAmRZ9ptzIwrEcSwz1oxhGMo55gptzPP8245kVVWh6zpM05RD3JQOaJN5FEUiQi4j6xcK7RLclMJsUsgwDHkb3kohClKA8RVh9DxPONyQUF6xruvEMi19v39wXVfI7PFzyGPOSC7fizWfg/WLf9mYvNrFWn5uAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/78cd45d8006a8f0496e47a5a124cbfd1/fcda8/scrum_sprint_backlog.png&quot;
        srcset=&quot;/static/78cd45d8006a8f0496e47a5a124cbfd1/12f09/scrum_sprint_backlog.png 148w,
/static/78cd45d8006a8f0496e47a5a124cbfd1/e4a3f/scrum_sprint_backlog.png 295w,
/static/78cd45d8006a8f0496e47a5a124cbfd1/fcda8/scrum_sprint_backlog.png 590w,
/static/78cd45d8006a8f0496e47a5a124cbfd1/efc66/scrum_sprint_backlog.png 885w,
/static/78cd45d8006a8f0496e47a5a124cbfd1/a9965/scrum_sprint_backlog.png 1171w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;계획회의의 결과 = &lt;strong&gt;스프린트 약속 (Sprint Commitment): 스프린트가 끝날 때 어떤 결과물을 내놓을 것인지에 대한 현실적인 목표&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;스크럼의 기본적인 하나의 특징은 &lt;strong&gt;팀이 스프린트의 목표를 한 번 설정하면, 모든 추가사항이나 변경사항들은 다음 스프린트까지 미뤄져야 한다는 것&lt;/strong&gt;이다. 이 말은 만일 제품 책임자가 스프린트 중에 팀이 했으면 하는 새로운 아이템을 결정해도 &lt;strong&gt;다음 스프린트가 시작할 때 까지는 바꿀 수 없다는 뜻&lt;/strong&gt;이다. 만약 외부 상황에 의해서 우선순위가 많이 바뀌거나 이 일을 계속 했을 경우 팀이 시간을
낭비하는 꼴이 된다면 제품 책임자나 팀은 &lt;strong&gt;스프린트를 중단&lt;/strong&gt;할 수 있다. 팀이 스프린트를 중단하면 새로운 스프린트 계획 회의를 통해서 새로운 스프린트를 시작한다. 보통 이런 일이 일어나는 것을 막는 것이 좋다. 왜냐하면 이런 경우 제품 책임자와 팀이 사기가 하락해서 극단적인 결정에 의지하도록 하기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프린트 동안 목표가 바뀌지 않는 긍정적인 효과&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;팀&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀은 목표가 바뀌지 않을 것임을 확실하게 알고 일을 하기 대문에 확실하게 완료하는데 초점을 둘 수 있음&lt;/li&gt;
&lt;li&gt;스프린트에 자신이 제품 백로그에 우선순위를 매기고 팀에게 준 아이템들에 대해서 제대로 생각해 보게 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제품 책임자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀이 실질적이고 분명한 일들을 끝내기 위해서 최선을 다 한다는 것을 알게 된 것에 확신&lt;/li&gt;
&lt;li&gt;다음 스프린트가 시작하기 전에는 어떤 변경이든 제품 백로그에 반영할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;데일리 스크럼(Daily Scrum)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;팀원 사이의 최근 정보 공유와 협력&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;참가자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀(required)&lt;/li&gt;
&lt;li&gt;제품 책임자(optional)&lt;/li&gt;
&lt;li&gt;스크럼마스터 (팀에도 이 역할을 할 사람이 있어야함)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;기간: 최대 15분 이내&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;팀원&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;각자 한 업무에 대해 서로 맞추고 장애 요소에 대해서 공유&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;지난 회의 이후로 무엇을 완료했는가?&lt;/li&gt;
&lt;li&gt;다음 회의 전에 무엇을 완료할 것인가?&lt;/li&gt;
&lt;li&gt;이것을 하는데 장애 요소는 무엇인가?&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;보고 자리가 아닌, 진행사항에 대한 공유/협력의 시간&lt;/li&gt;
&lt;li&gt;누군가 장애 요소를 말했다면, 스크럼 마스터는 팀원들이 그것을 해결할 수 있도록 도와주는 역할&lt;/li&gt;
&lt;li&gt;회의가 필요하다면 종료 후 이어서 회의 진행&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;팀이 스크럼을 처음 한다면 일반적으로 &lt;strong&gt;관리자나 또는 권한이 있다고 여겨지는 사람들이 데일리 스크럼에 들어오지 않기를 권장&lt;/strong&gt;한다. 이런 위험한 행동을 통해 팀은“ 감시”당하고 있다고 생각하게 되어서 매일 비현실적인 기대치에 대한 주요 진척도를 보고해야 한다는 압박을 느끼게 된다. 또한 팀은 문제점을 보고하는 것에 대해서 억제를 당한다고 느끼며 팀이 스스로 잘 관리하지 못하고 세부사항까지 관리를 받게 된다. 이해관계자들은 팀의 회의에 따라가기 보다는 팀의 진척을 느리게 하는 장애 요소들을 제거해 주는 것이 더 유익할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;스프린트 동안 진척도 추적(Tracking Progress during the Sprint)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;스크럼에서 팀은 스스로 관리한다.&lt;/li&gt;
&lt;li&gt;스프린트 백로그에 있는 현재 작업을 완료하기 위해서 얼마나 남았는지 새로 추정&lt;/li&gt;
&lt;li&gt;스프린트 번다운 차트에 표시&lt;/li&gt;
&lt;li&gt;지속적으로 효율적으로 일할 방향을 찾아서 조정해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e28160e-4cc9-4ac2-8018-8045f9664aad/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e28160e-4cc9-4ac2-8018-8045f9664aad/Untitled.png&quot;&gt;&lt;/p&gt;
&lt;h2&gt;제품 백로그 개선(Product Backlog Refinement)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;미래의 스프린트를 위해 큰 아이템을 쪼개고 아이템을 분석하고 재추정하고 우선순위 재조정&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;참가자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀&lt;/li&gt;
&lt;li&gt;제품 책임자(optional, 세부적 개선에 도움을 줄 수 있는 전문가라면)&lt;/li&gt;
&lt;li&gt;요구사항을 이해하고 팀에 도움을 줄 수 있는 사람들 참가.&lt;/li&gt;
&lt;li&gt;스크럼마스터(효과적으로 진행할 수 있도록 지도하기 위해서 참가하고 나머지 부분은 참가하지 않을 수도 있음.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기간&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 팀이 사용 가능한 시간의 10% 넘지 않도록 함&lt;/li&gt;
&lt;li&gt;분석이 작업이 많은 아이템이기 때문에 오래 걸릴수는 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가치있는 스크럼 가이드라인 중 하나는 매 스프린트의 일정 부분은 팀 전체가 미래의 스프린트들을 위해 제품 백로그를 개선해야하는데 써야 한다는 것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;세부적인 요구사항 분석&lt;/li&gt;
&lt;li&gt;아이템 쪼개기&lt;/li&gt;
&lt;li&gt;새로운 아이템에 대한 추정&lt;/li&gt;
&lt;li&gt;현재 아이템 재추정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이 과정을 통해 스프린트 계획이 상대적으로 간단해짐&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;스프린트 리뷰(Sprint Review)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;제품 증분의 기능성에 관한 검토와 조정&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;참가자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀&lt;/li&gt;
&lt;li&gt;제품 책임자&lt;/li&gt;
&lt;li&gt;스크럼 마스터&lt;/li&gt;
&lt;li&gt;제품 책임자가 초대한 적합한 이해관계자들&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스프린트의 한 주당 한 시간으로 제약 (2주 길이 스프린트 = 최대 2시간)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프린트를 검토&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데모 x, 중요한 개념은 &lt;em&gt;검토&lt;/em&gt;와 &lt;em&gt;조정&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;제품 책임자: 제품과 팀에 대한 상황을 배움&lt;/li&gt;
&lt;li&gt;팀: 제품 책임자와 시장에 대해 배움&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;실제 제품으로 데모를 할 것&lt;/li&gt;
&lt;li&gt;리뷰 준비에 30분 이상을 사용하지 않을 것 (그렇다면 뭔가 잘못된 것)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;스프린트 회고(Sprint Retrospective)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;프로세스와 환경에 관련된 것을 검토하고 조정하는 활동&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;참가자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀&lt;/li&gt;
&lt;li&gt;스크럼 마스터&lt;/li&gt;
&lt;li&gt;제품 책임자 (optional)&lt;/li&gt;
&lt;li&gt;팀이 초대하지 않은 이해관계자들은 &lt;strong&gt;참석 불가&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스프린트 한 주당 45분으로 제한&lt;/li&gt;
&lt;li&gt;&lt;em&gt;프로세스&lt;/em&gt;와 &lt;em&gt;환경&lt;/em&gt;에 대해서 검토하고 조정&lt;/li&gt;
&lt;li&gt;스크럼 마스터는 회고에서 퍼실리테이터 역할을 할 수도 있으나, 외부 퍼실리테이터를 찾는 것이 더 나을 수 있음&lt;/li&gt;
&lt;li&gt;기법은 &lt;a href=&quot;https://agile.2ia.net/Agile%20Retrospectives.pdf&quot;&gt;Agile Rerospectives(Derby, Larsen 2006)&lt;/a&gt; 참고&lt;/li&gt;
&lt;li&gt;긍정적인 부분 부정적인 부분 모두 집중할 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;다음 스프린트의 시작(Starting the next Sprint)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;새로운 시각으로 새로운 아이템을 추가, 기존 아이템 제거 등 수정하여 제품 백로그 업데이트&lt;/li&gt;
&lt;li&gt;애자일 개발의 한 가지 원칙은 “지속 가능한 속도”이며 탐은 합리적인 수준으로 적절히 일해야 이 주기를 계속 이어나갈 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;생산성은 팀의 실천방식이 발전하고 &lt;strong&gt;팀의 생산성에 방해가 되는
요소들을 제거해 가며 계속해서 오르는 것&lt;/strong&gt;이지, 잔업이나 품질에 대해서 타협하며 오르는 것이 아니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;스프린트는 제품 책임자가 제품을 출시할 준비가 되었다고 판단할 때까지 계속&lt;/li&gt;
&lt;li&gt;완벽한 스크럼에서 제품은 매 스프린트가 끝날 때 마다 잠재적으로 출시가 가능한 상태&lt;/li&gt;
&lt;li&gt;하지만 많은 조직들은 개발 방법, 툴, 인프라가 약하고 이런 완벽한 스크럼은 할 수 없으며 그렇기 때문에 남은 일을 처리하기 위해서 &lt;strong&gt;“릴리즈 스프린트(Release Sprint)”&lt;/strong&gt;가 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;릴리즈 관리(Managing Release)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;반복적인 모델의 경우 장기적인 출시 계획을 어떻게 해야 하는가?&lt;/li&gt;
&lt;li&gt;첫번째 릴리즈를 위한 새로운 제품&lt;/li&gt;
&lt;li&gt;추후의 릴리즈를 위한 현재의 제품&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;새로운 제품의 경우나 현재의 제품에 단지 스크럼만 적용하는 경우&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;첫 번째 스프린트 전에 제품 백로그 개선을 시작 = &lt;strong&gt;제품 백로그 제작 or 릴리즈 계획&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;모든 아이템에 대한 추정도 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;확실히 정해진 제품 백로그가 있는 제품의 경우는 다음 릴리즈를 위한 어떤 특별하거나 큰 릴리즈 계획이 필요 없음 (= 매 스프린트마다 5~10% 정도의 시간을 백로그 개선, 추후를 위한 준비에 사용)&lt;/li&gt;
&lt;li&gt;스크럼은 매 스프린트마다 잠재적으로 출시 가능한 코드를 만드는 것을 강조하기 때문에 제품 책임자는 중간 릴리즈를 하기로 할 수도 있고, 고객이 완료된 작업에 대한 수혜를 더 빨리 받을 수 있게 할 수도 있다.&lt;/li&gt;
&lt;li&gt;계획을 세우고 개선하는 것을 통해서 릴리즈에 대한 큰 방향성을 제시하고 어떻게 결정들의 균형을 맞출지(예를 들면 범위냐 일정이냐 같은)를 명확히 하는 것이 핵심&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;애플리케이션 또는 제품에서의 관점&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;스크럼은 더 이상 시작, 중간, 끝이 있는 프로젝트는 없다.&lt;/li&gt;
&lt;li&gt;기존의 프로젝트 관리자도 없다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;필요한 모든 프로젝트 관리 업무는 팀과 제품 책임자가 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제품 책임자는 내부적인 사업 고객이거나 제품 관리와 관련된 사람&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;때로는 앞의 방법으로도 해결하기 힘들 정도로 새로운 일이 적어서 팀이 한 스프린트 내에 여러 애플리케이션의 아이템들을 담당할 수도 있다. 그러나 이런 방법은 &lt;strong&gt;다양한 애플리케이션에 걸쳐서 비생산적인 멀티태스크를 만들 수도 있으니 주의&lt;/strong&gt;해야 한다. 스크럼에서 생산성에 대한 기본적인 &lt;strong&gt;한 가지는 팀은 한 스프린트에 한 개의 제품이나 애플리케이션에 집중해야 한다&lt;/strong&gt;는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;공통 과제(Common Challenge)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;도전적인 스크럼 실천 방법을 할 때의 한 가지 &lt;strong&gt;흔한 실수는 스크럼을 변형시키는 것&lt;/strong&gt;이다. 예를 들어 산출물을 만드는데 문제가 있는 팀은 스프린트의 기간을 늘일 수도 있고 그래서 절대 시간이 다 되지 않을 것이다. 그리고 그런 프로세스에서는 추정하고 시간을 관리하는 것을 어떻게 하면 더 잘할지 절대 배울 필요가 없을 것이다. 이런 식으로 경험이 있는 스크럼마스터의 코칭이나 지원 없이 조직은 그들의 약점과 장애와는 반대로 스크럼을 변형시킬 수도 있고 스크럼이 주는 진정한 혜택을 약하게 만들 수도 있다. 여기서 말하는 스크럼이 주는 진정한 혜택은 &lt;strong&gt;장점과 단점을 눈에 보이도록 하고 조직이 더 높은 수준으로 나아가기 위한 선택 사항을 제시하는 것&lt;/strong&gt;을 뜻한다.
다른 흔한 실수는 스크럼이 &lt;strong&gt;특정 실천 사항을 분명하게 요구하지 않는다&lt;/strong&gt;는 이유로 어떤 실천 사항을 피하거나 금지해야 한다고 생각하는 것이다. 예를 들면, 스크럼에서는 제품 책임자가 제품을 위한 장기적인 전략을 세우는 것을 요구하지 않는다. 또한 스크럼에서는 엔지니어가 복잡한 기술적인 문제에 대해서 더 경험이 많은 엔지니어에게 조언을 구하는 것을 요구하지도 않는다. 스크럼에서는 이런 부분들은 개인이 올바른 결정을 하도록 남겨둔다. 대부분의 경우는 위의 두 실천 사항은 하는 것이 더 낫다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://scrumprimer.org/translations&quot;&gt;Scrum Primer&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[로컬에서 Jekyll 확인하기 - 기본 Jekyll 커맨드]]></title><description><![CDATA[로멀에서 Jekyll을 설치해서 블로그를 꾸며보기 최근 여유가 좀 있어서 Jekyll…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-09-jekyll-preview-local/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-09-jekyll-preview-local/</guid><pubDate>Fri, 09 Oct 2020 22:19:11 GMT</pubDate><content:encoded>&lt;h1&gt;로멀에서 Jekyll을 설치해서 블로그를 꾸며보기&lt;/h1&gt;
&lt;p&gt;최근 여유가 좀 있어서 &lt;em&gt;Jekyll&lt;/em&gt; 본격적으로 꾸며 나가보려는 마음에 이것저것 시도를 해보고 있다.
새롭게 찾은 테마가 처음 마음에 들긴 했지만, 보다보니 마음에 안들거나 개선시켜 보고 싶은 부분들도 느껴지고, 개인적으로 좀 욕심도 생겨서 지금 테마를 진화시켜나가보려고 마음을 먹었다.
기본적으로 &lt;em&gt;Jekyll&lt;/em&gt;은 원하는 플러그인을 붙이거나 &lt;em&gt;js&lt;/em&gt;나 &lt;em&gt;scss&lt;/em&gt;도 지원하는 등 손쉽게 원하는 커스터마이즈가 가능하다. (본 테마를 적용하게 되면서 알게된 사실이다..ㅎㅎ)&lt;/p&gt;
&lt;p&gt;그래서 처음엔 간단한 수정을 하기 위해서… 로컬에 별도의 프로젝트에서 js와 scss를 테스트 한 다음 이 블로그에 내용을 업데이트해서 푸시해서 확인하는 형식으로 업데이트 했다.
하지만 이런식으로 계속 하려니 좀 불편했다. 그래서 결국 &lt;em&gt;Jekyll&lt;/em&gt;을 설치했다..ㅋㅋ..&lt;/p&gt;
&lt;p&gt;로컬에 &lt;strong&gt;Jekyll&lt;/strong&gt;을 굳이 설치한다는 것은 약간의 귀찮음을 동반하지만 몇 가지 장점이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;푸시하기 전에 로컬에서 포스트를 미리보기할 수 있다.&lt;/li&gt;
&lt;li&gt;블로그를 로컬에서 확인할 수 있기 때문에, 테마 수정을 하기 용이하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그럼 본격적으로 &lt;strong&gt;Jekyll&lt;/strong&gt;을 설치하고, 사용하는 커맨드를 소개하고자 한다.&lt;/p&gt;
&lt;h2&gt;Jekyll 설치하기&lt;/h2&gt;
&lt;p&gt;Jekyll을 설치하는 방법은 [공식홈페이지][ref]에서 너무 잘 안내되어 있다. 그냥 따라하면 쉽게 설치할 수 있다. 간단하게 적자면 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Ruby&lt;/em&gt; 설치하기&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Homebrew&lt;/em&gt; 설치하기&lt;/li&gt;
&lt;li&gt;&lt;em&gt;rbenv&lt;/em&gt; 설치 (여러 버전의 ruby를 관리하는데 사용된다고 한다.)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Jekyll&lt;/em&gt; 설치&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이렇게 로컬에 &lt;em&gt;Jekyll&lt;/em&gt;을 설치한 다음에 새로운 블로그 프로젝트를 만들어 실행하는 방법은 다음과 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ jekyll new myblog
$ cd myblog
$ bundle exec jekyll serve&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게하면 새로운 블로그를 만들어 로컬 서버로 띄울수가 있고 &lt;code class=&quot;language-text&quot;&gt;localhost:4000&lt;/code&gt;으로 접속할 수 있다. clone한 github 블로그 프로젝트에 &lt;code class=&quot;language-text&quot;&gt;bundle exec jekyll serve&lt;/code&gt;를 하게 되면 &lt;code class=&quot;language-text&quot;&gt;Could not locate Gemfile or .bundle/ directory&lt;/code&gt; 오류가 난다.
깃헙 프로젝트에서는 다음 커맨드들을 이용하면 된다.&lt;/p&gt;
&lt;h2&gt;Jekyll 빌드&lt;/h2&gt;
&lt;p&gt;소스를 빌드하려면 다음 커맨드를 입력한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ jekyll build&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;커맨드를 실행하면 &lt;strong&gt;_site&lt;/strong&gt;폴더, &lt;strong&gt;.jekyll-cache&lt;/strong&gt;폴더 등이 생성되며, 만들어둔 &lt;strong&gt;md&lt;/strong&gt;과 에셋들이 빌드된 형태로 만들어진다.&lt;/p&gt;
&lt;h2&gt;Jekyll 서버 띄우기&lt;/h2&gt;
&lt;p&gt;블로그를 로컬 서버에 띄우려면 다음과 같이 입력한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ jekyll serve&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 하면 &lt;code class=&quot;language-text&quot;&gt;localhost:4000&lt;/code&gt;으로 로컬에서 블로그를 확인할 수 있다.&lt;/p&gt;
&lt;h2&gt;Jekyll 빌드 클린&lt;/h2&gt;
&lt;p&gt;빌드 결과물들을 지우려면 다음과 같이 입력한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ jekyll clean&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하면 캐시 등이 사라 진다.&lt;/p&gt;
&lt;p&gt;이제 남은 것은 뭐다? &lt;strong&gt;해피 해킹!!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[ref]:[https://jekyllrb-ko.github.io/docs/installation/macos/]&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Mac OS mds_store 리소스 점유율 문제 해결하기]]></title><description><![CDATA[Mac OS mds_store 리소스 점유율 문제 맥북이 점점 느려져서 활성 상태를 보니 mds_store가 CPU, 메모리 등 꽤 리소스를 점유하고 있었다.. 찾아보니 이렇게 mds_store의 리소스 점유율이 높은것은 spotlight…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-09-mds_store/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-09-mds_store/</guid><pubDate>Fri, 09 Oct 2020 18:01:58 GMT</pubDate><content:encoded>&lt;h1&gt;Mac OS mds_store 리소스 점유율 문제&lt;/h1&gt;
&lt;p&gt;맥북이 점점 느려져서 활성 상태를 보니 &lt;strong&gt;mds_store&lt;/strong&gt;가 CPU, 메모리 등 꽤 리소스를 점유하고 있었다..&lt;/p&gt;
&lt;p&gt;찾아보니 이렇게 &lt;strong&gt;mds_store&lt;/strong&gt;의 리소스 점유율이 높은것은 &lt;strong&gt;spotlight&lt;/strong&gt; 인덱싱 기능과 관련있는 모양.&lt;/p&gt;
&lt;p&gt;어차피 &lt;strong&gt;alfred&lt;/strong&gt;를 시용하고 있는 입장에서는 인덱싱을 비활성화되도 되어서 비활성화 처리했다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo mdutil -a -i off&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다시 활성화 하고 싶다면 아래와 같이 입력하면 된다. 꽤 낮아진다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo mdutil -a -i on&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;</content:encoded></item><item><title><![CDATA[node.js express 서버에 Swagger 끼얹기]]></title><description><![CDATA[Express 프로젝트에 Swagger를 달아보자. Swager? Swagger는 RESTful 웹 서비스에서 설계, 구축, 문서화 등을 도와주는 오픈소스 프레임워크라고 볼 수 있다.
Spring 프로젝트에서 적용된 사례를 많이 접했는데, node…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-08-swagger-ui-express/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-08-swagger-ui-express/</guid><pubDate>Thu, 08 Oct 2020 12:45:52 GMT</pubDate><content:encoded>&lt;h1&gt;Express 프로젝트에 Swagger를 달아보자.&lt;/h1&gt;
&lt;h2&gt;Swager?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Swagger&lt;/strong&gt;는 RESTful 웹 서비스에서 설계, 구축, 문서화 등을 도와주는 오픈소스 프레임워크라고 볼 수 있다.
Spring 프로젝트에서 적용된 사례를 많이 접했는데, node.js도 지원하고 있었다.&lt;/p&gt;
&lt;h2&gt;Swagger Tools&lt;/h2&gt;
&lt;p&gt;Swagger는 다음과 같은 것들이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://swagger.io/tools/swagger-editor/&quot;&gt;Swagger Editor&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Swagger Editor&lt;/strong&gt;는 RESTful API를 Swagger 스펙에 맞게 설계, 정의, 문서화할 수 있는 오픈소스 에디터이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://swagger.io/tools/swagger-codegen/&quot;&gt;Swagger Codegen&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Swagger Codegen&lt;/strong&gt;은 OpenAPI 스펙을 기반으로 API 클라이언트 라이브러리(SDK generation), server stubs, 문서화 등을 자동으로 해준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://swagger.io/tools/swagger-ui/&quot;&gt;Swagger UI&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Swagger UI&lt;/strong&gt;는 API 스펙들을 가시적으로 볼 수 있고, 실제 API를 테스트해볼 수 있게 해준다. API에 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://swagger.io/tools/swagger-inspector/&quot;&gt;Swagger Inspector&lt;/a&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;자동 생성된 OpenAPI 문서를 테스트 할 수 있는 툴이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;현업에서 일반적으로 &lt;strong&gt;Swagger&lt;/strong&gt;라고 하면 &lt;strong&gt;swager-ui&lt;/strong&gt;를 많이 지칭하는 것 같다. &lt;strong&gt;swagger-ui&lt;/strong&gt;는 백엔드 - 프론트 개발자 간 소통하는 문서로 많이 사용되고 있는데,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프론트 작업자 입장에서는  API 스펙을 볼 수 있고, 테스트도 해볼 수 있기 때문에&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;백엔드 작업자를 찾아가서 물어보지 않을 수 있고,&lt;/li&gt;
&lt;li&gt;백엔드 프로젝트를 들춰서 VO 소스코드를 보지 않아도 작업을 할 수 있는 장점이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;백엔드 개발자 입장에서는 &lt;strong&gt;swagger-ui&lt;/strong&gt; 자체가 문서가 되기 때문에&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;별도의 문서가 필요하지 않다는 점,&lt;/li&gt;
&lt;li&gt;프로젝트 소스와 연동되어있기 때문에 &lt;em&gt;가장 신선한&lt;/em&gt; 문서라고 볼 수 있다는 장점이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;실제로 Spring 개발자들은 &lt;strong&gt;swagger-ui&lt;/strong&gt;를 많이 도입해서 사용하는 사례들을 자주 보았다. 쓰는 프로젝트와 안쓰는 프로젝트의 차이? 말모말모.. 없으면 너무 불편한 정도다.&lt;/p&gt;
&lt;p&gt;그렇다면 node.js에는 어떻게 적용할 수 있을까?&lt;/p&gt;
&lt;h2&gt;express 프로젝트에 &lt;code class=&quot;language-text&quot;&gt;swagger-ui&lt;/code&gt;를 적용하기&lt;/h2&gt;
&lt;p&gt;express로 개발된 node.js 프로젝트에 &lt;code class=&quot;language-text&quot;&gt;swagger-ui&lt;/code&gt;를 적용해보자.&lt;/p&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;swagger-ui-express&lt;/code&gt; 설치&lt;/h3&gt;
&lt;p&gt;프로젝트에 &lt;code class=&quot;language-text&quot;&gt;swagger-ui-express&lt;/code&gt;를 설치한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;swagger-ui-express&lt;/code&gt;는 swagger-ui를 사용할 수 있게 하는 express 미들웨어이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;bash&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ yarn add swagger-ui-express&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;swagger.json&lt;/code&gt; 생성&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;swagger.json&lt;/code&gt;파일을 프로젝트 루트에 생성한다.&lt;/p&gt;
&lt;p&gt;이 JSON 파일에 OpenAPI 정의를 작성한다.&lt;/p&gt;
&lt;p&gt;swagger open api 스펙은 다음링크에서 확인 가능: &lt;a href=&quot;https://swagger.io/docs/specification/basic-structure/&quot;&gt;https://swagger.io/docs/specification/basic-structure/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;swagger 기본 구조&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;info&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API의 정보들을 정의: &lt;code class=&quot;language-text&quot;&gt;title&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;description&lt;/code&gt;(optional), &lt;code class=&quot;language-text&quot;&gt;version&lt;/code&gt;, …&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Paths&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 endpoint path를 나타냄&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Parameters&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URL에 포함된 파라미터나 Query String들을 정의함.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Request Body&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;requestBody&lt;/code&gt;로 body content와 media type을 정의할 수 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Responses&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가능한 status code와 response body &lt;code class=&quot;language-text&quot;&gt;schema&lt;/code&gt;를 정의할 수있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래와 같이 &lt;code class=&quot;language-text&quot;&gt;swagger,json&lt;/code&gt;파일을 작성한다. 참고로 아래 &lt;code class=&quot;language-text&quot;&gt;version&lt;/code&gt;은 OpenAPI 스펙의 버전이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;swagger&amp;quot;: &amp;quot;2.0&amp;quot;,
  &amp;quot;info&amp;quot;: {
    &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;, //version of the OpenAPI Specification
    &amp;quot;title&amp;quot;: &amp;quot;My User Project CRUD&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;My User Project Application API&amp;quot;,
    &amp;quot;license&amp;quot;: {
      &amp;quot;name&amp;quot;: &amp;quot;MIT&amp;quot;,
      &amp;quot;url&amp;quot;: &amp;quot;https://opensource.org/licenses/MIT&amp;quot;
    }
  },
  &amp;quot;host&amp;quot;: &amp;quot;localhost:8000&amp;quot;,
  &amp;quot;basePath&amp;quot;: &amp;quot;/&amp;quot;,
  &amp;quot;tags&amp;quot;: [
    {
      &amp;quot;name&amp;quot;: &amp;quot;Users&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;API for users in the system&amp;quot;
    }
  ],
  &amp;quot;schemes&amp;quot;: [
    &amp;quot;http&amp;quot;
  ],
  &amp;quot;consumes&amp;quot;: [
    &amp;quot;application/json&amp;quot;
  ],
  &amp;quot;produces&amp;quot;: [
    &amp;quot;application/json&amp;quot;
  ]
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;swagger-ui-express&lt;/code&gt; 연동하기&lt;/h3&gt;
&lt;p&gt;아래와같이 &lt;code class=&quot;language-text&quot;&gt;swagger-ui-express&lt;/code&gt;와 작성한 &lt;code class=&quot;language-text&quot;&gt;swagger.json&lt;/code&gt;을 import 하여&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const swaggerUi = require(‘swagger-ui-express’),
swaggerDocument = require(‘./swagger.json’);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;app.listen()&lt;/code&gt;앞에 아래 코드를 추가한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;app.use(&amp;#39;/api-docs&amp;#39;, swaggerUi.serve, swaggerUi.setup(swaggerDocument));&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게하면 호스트에서 &lt;code class=&quot;language-text&quot;&gt;{{host}}/api-docs&lt;/code&gt;를 통해서 Swagger 문서를 볼 수있는 것을 확인할 수 있다.&lt;/p&gt;
&lt;h3&gt;API 정의 완성하기&lt;/h3&gt;
&lt;p&gt;이제 &lt;code class=&quot;language-text&quot;&gt;swagger.json&lt;/code&gt;을 사용하는 API로 완성하면 된다. &lt;code class=&quot;language-text&quot;&gt;paths&lt;/code&gt; 필드에 api 스펙을 추가해나가면 된다. &lt;code class=&quot;language-text&quot;&gt;definitions&lt;/code&gt;에는 API에서 사용하게되는 object 형태를 제공 할 수 있다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;endpoint&lt;/code&gt; 명과 method type이 key가 되고, 각 값들을 정의할 수 있다. &lt;code class=&quot;language-text&quot;&gt;parameters&lt;/code&gt;로 파라미터의 타이&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;..
&amp;quot;paths&amp;quot;: {
    &amp;quot;/users&amp;quot;: {
      &amp;quot;get&amp;quot;: {
        &amp;quot;tags&amp;quot;: [
          &amp;quot;Users&amp;quot;
        ],
        &amp;quot;summary&amp;quot;: &amp;quot;Get all users in system&amp;quot;,
        &amp;quot;responses&amp;quot;: {
          &amp;quot;200&amp;quot;: {
            &amp;quot;description&amp;quot;: &amp;quot;OK&amp;quot;,
            &amp;quot;schema&amp;quot;: {
              &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/Users&amp;quot;
            }
          }
        }
      }
    },
    &amp;quot;/addUser&amp;quot;: {
      &amp;quot;post&amp;quot;: {
        &amp;quot;tags&amp;quot;: [
          &amp;quot;Users&amp;quot;
        ],
        &amp;quot;description&amp;quot;: &amp;quot;Create new user in system&amp;quot;,
        &amp;quot;parameters&amp;quot;: [
          {
            &amp;quot;name&amp;quot;: &amp;quot;user&amp;quot;,
            &amp;quot;in&amp;quot;: &amp;quot;body&amp;quot;,
            &amp;quot;description&amp;quot;: &amp;quot;User that we want to create&amp;quot;,
            &amp;quot;schema&amp;quot;: {
              &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/User&amp;quot;
            }
          }
        ],
        &amp;quot;produces&amp;quot;: [
          &amp;quot;application/json&amp;quot;
        ],
        &amp;quot;responses&amp;quot;: {
          &amp;quot;200&amp;quot;: {
            &amp;quot;description&amp;quot;: &amp;quot;New user is created&amp;quot;,
            &amp;quot;schema&amp;quot;: {
            &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/User&amp;quot;
            }
          }
        }
      }
    },
    &amp;quot;/user/{id}&amp;quot;: {
      &amp;quot;put&amp;quot;: {
        &amp;quot;summary&amp;quot;: &amp;quot;Update user with given ID&amp;quot;,
        &amp;quot;tags&amp;quot;: [
          &amp;quot;Users&amp;quot;
        ],
        &amp;quot;parameters&amp;quot;: [
          {
            &amp;quot;name&amp;quot;: &amp;quot;id&amp;quot;,
            &amp;quot;in&amp;quot;: &amp;quot;path&amp;quot;,
            &amp;quot;rquired&amp;quot;: true,
            &amp;quot;description&amp;quot;: &amp;quot;ID of user that we want to find&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;
          },
          {
            &amp;quot;name&amp;quot;: &amp;quot;user&amp;quot;,
            &amp;quot;in&amp;quot;: &amp;quot;body&amp;quot;,
            &amp;quot;description&amp;quot;: &amp;quot;User with new values of properties&amp;quot;,
            &amp;quot;schema&amp;quot;: {
              &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/User&amp;quot;
            }
          }
        ],
        &amp;quot;responses&amp;quot;: {
          &amp;quot;200&amp;quot;: {
            &amp;quot;description&amp;quot;: &amp;quot;User is updated&amp;quot;,
            &amp;quot;schema&amp;quot;: {
              &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/User&amp;quot;
            }
          }
        }
      }
    }
  },
  &amp;quot;definitions&amp;quot;: {
    &amp;quot;User&amp;quot;: {
      &amp;quot;required&amp;quot;: [
        &amp;quot;name&amp;quot;,
        &amp;quot;_id&amp;quot;,
        &amp;quot;companies&amp;quot;
      ],
      &amp;quot;properties&amp;quot;: {
        &amp;quot;_id&amp;quot;:{
          &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;,
          &amp;quot;uniqueItems&amp;quot;: true
        },
        &amp;quot;isPublic&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;boolean&amp;quot;
        },
        &amp;quot;name&amp;quot;: {
          &amp;quot;types&amp;quot;: &amp;quot;string&amp;quot;
        },
        &amp;quot;books&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;array&amp;quot;,
          &amp;quot;items&amp;quot;: {
            &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
            &amp;quot;properties&amp;quot;: {
              &amp;quot;name&amp;quot;: {
                &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;
              },
              &amp;quot;amount&amp;quot;: {
                &amp;quot;type&amp;quot;: &amp;quot;number&amp;quot;
              }
            }
          }
        },
        &amp;quot;companies&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;array&amp;quot;,
          &amp;quot;items&amp;quot;: {
            &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;
          }
        }
      }
    },
    &amp;quot;Users&amp;quot;: {
      &amp;quot;type&amp;quot; :&amp;quot;array&amp;quot;,
      &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/User&amp;quot;
    }
  }
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;대략적으로 형태들이 파악이 가능하다.&lt;/p&gt;
&lt;p&gt;그런데… 이 모든 API에 대해서 &lt;code class=&quot;language-text&quot;&gt;swagger.json&lt;/code&gt;을 작성해야하나?!!
이럴거면 단순 문서를 위해서라면 JSDoc, TSDoc, docz 등을 차라리 사용했겠죠..&lt;/p&gt;
&lt;p&gt;그럼 다음 포스트에서 좀 더 쉽게 작성할 수 잇는 방법을 소개한다!&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;p&gt;참고가 된 사이트&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md&quot;&gt;Open API Spec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@kirtikau/how-to-add-swagger-ui-to-existing-node-js-and-express-js-project-2c8bad9364ce&quot;&gt;how-to-add-swagger-ui-to-existing-node-js-and-express-js-project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://levelup.gitconnected.com/the-simplest-way-to-add-swagger-to-a-node-js-project-c2a4aa895a3c&quot;&gt;the-simplest-way-to-add-swagger-to-a-node-js-project&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[MySQL Field를 이용해서 원하는 순서로 정렬하기]]></title><description><![CDATA[쿼리를 짜다보면 일정 특정 필드에 대해 오름차순이나 내림차순 뿐만 아니라 특정 순서를 만들어서 정렬하고 싶을 경우가 있다. 이럴 때 MySQL…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-06-mysql-field-function/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-06-mysql-field-function/</guid><pubDate>Tue, 06 Oct 2020 13:43:59 GMT</pubDate><content:encoded>&lt;p&gt;쿼리를 짜다보면 일정 특정 필드에 대해 오름차순이나 내림차순 뿐만 아니라 특정 순서를 만들어서 정렬하고 싶을 경우가 있다.&lt;/p&gt;
&lt;p&gt;이럴 때 &lt;strong&gt;MySQL&lt;/strong&gt;에서 제공하고 있는 &lt;code class=&quot;language-text&quot;&gt;FIELD&lt;/code&gt; 함수를 이용하면 굉장히 간단하게 쿼리를 작성할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;SELECT name FROM city
ORDER BY FIELD(name, &amp;#39;london&amp;#39;, &amp;#39;milano&amp;#39;, &amp;#39;paris&amp;#39;, &amp;#39;new york&amp;#39;, &amp;#39;tokyo&amp;#39;);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;FIELD&lt;/code&gt;의 파라미터로 넘긴 값 외 다른 값의 정렬은 &lt;code class=&quot;language-text&quot;&gt;DESC&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;ASC&lt;/code&gt;로 설정 가능하다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;SELECT name FROM city
ORDER BY FIELD(name, &amp;#39;london&amp;#39;, &amp;#39;milano&amp;#39;, &amp;#39;paris&amp;#39;, &amp;#39;new york&amp;#39;, &amp;#39;tokyo&amp;#39;) DESC;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다른 필드를 섞어서 정렬도 가능하다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;SELECT name FROM city
ORDER BY FIELD(name, &amp;#39;london&amp;#39;, &amp;#39;milano&amp;#39;, &amp;#39;paris&amp;#39;, &amp;#39;new york&amp;#39;, &amp;#39;tokyo&amp;#39;) DESC, poularity;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;만약 &lt;code class=&quot;language-text&quot;&gt;FIELD&lt;/code&gt;를 사용하지 않는다고 한다면? &lt;code class=&quot;language-text&quot;&gt;CASE&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;DESC&lt;/code&gt;를 줄줄 늘려서 쓸 수도 있다고 한다.
약간 지저분해 보인다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;select name FROM city
ORDER BY CASE
  WHEN name = &amp;#39;london&amp;#39; then 1 else 2
end, city ASC&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;SELECT * FROM table ORDER BY id=&amp;#39;8&amp;#39; DESC, id=&amp;#39;5&amp;#39; DESC, id=&amp;#39;4&amp;#39; DESC, id=&amp;#39;3&amp;#39; DESC&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;FIELD&lt;/code&gt;를 이용하면 보기 좋게 쿼리 작성이 가능하므로 잘 알아두고 요긴하게 써먹자.&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;p&gt;1.[stackoverflow][ref1]&lt;/p&gt;
&lt;p&gt;[ref1]:[https://stackoverflow.com/questions/14104055/ordering-by-specific-field-value-first]&lt;/p&gt;</content:encoded></item><item><title><![CDATA[아직도 console.log만 쓰니? 내 콘솔창과 디버깅 생활에 생기를 불어넣어줄 console API]]></title><description><![CDATA[, 진짜 그것만으로 충분할까? 아주 오래전 웹 개발에서 Chrome Insepctor…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-javascript-console/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-javascript-console/</guid><pubDate>Tue, 06 Oct 2020 13:37:00 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;code class=&quot;language-text&quot;&gt;console.log()&lt;/code&gt;, 진짜 그것만으로 충분할까?&lt;/h1&gt;
&lt;p&gt;아주 오래전 웹 개발에서 &lt;em&gt;Chrome Insepctor&lt;/em&gt; 같은 강력한 도구가 없던 시절 자바스크립트 디버깅엔 &lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;가 필수였다.
그 때의 습관 탓일까, 디버깅 하면서 간단한 값 확인은 중단점을 걸고 스텝을 넘겨가며 로직을 확인하기보다 로그를 찍어 확인하는 것이 훨씬 빠르게 느껴져서 여전히 많이 사용하고 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.log()&lt;/code&gt;는 사실 유용하다. C나 JAVA와 같은 컴파일 언어는 로그를 찍는 코드가 추가되면 컴파일을 필수적으로 해야하는 시간이 걸리지만, javascript같은 인터프리터 언어는 굳이 신경쓸 필요가 없기 때문이다. (&lt;em&gt;Typescript&lt;/em&gt; 같은 전처리가 들어간다면 좀 다른 얘기가 되어버리지만..)
여하튼 &lt;code class=&quot;language-text&quot;&gt;console.log()&lt;/code&gt;는 굉장히 유용하고 자주 쓰이게 된다.&lt;/p&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;console.log()&lt;/code&gt;만 있는 것이 아니다.
디버깅에 유용한, 당신의 디버깅을 다채롭게 할 몇가지 console API를 소개한다.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.debug()&lt;/code&gt;&lt;/h2&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  const greeting = &amp;#39;hello world&amp;#39;;
  console.debug(greeting);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;와 거의 차이가 없는 &lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;의 alias라고 보면 될 것 같다.&lt;/p&gt;
&lt;p&gt;하지만 다른 점이 있다. &lt;em&gt;Chrome Insepctor&lt;/em&gt; 상의 &lt;em&gt;level&lt;/em&gt;이 &lt;strong&gt;Default levels&lt;/strong&gt;로 설정되어있을 경우에 &lt;code class=&quot;language-text&quot;&gt;console.debug&lt;/code&gt;에 의한 로그는 나타나지 않는다. &lt;code class=&quot;language-text&quot;&gt;Verbose&lt;/code&gt;를 체크해주어야 &lt;code class=&quot;language-text&quot;&gt;console.debug&lt;/code&gt;의 로그가 나타난다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/83252004a1964a187bb03dc00259cf86/3684f/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 225px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 93.91891891891892%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAACEUlEQVQ4y5VUy47TQBCcG1z4ApA475HP5caVAyc4IiHOGxR5s2yCveT9cJ52bOdlJy6qZuMIiU1iRiq1Zzxd0z1T3SaKlhj5PsbEZDLFYrGAP/IRhCGazSaWyyXiOEYURaVgwmCBu7t7/H708PP+AY+eh+qPKoY8wHEchCROksSSloFZzOdoNVsYjUbodDrodruMTHMfc/4LgqA0lI2ZzWbYbrdYrVZI0/QErW02m9KRCePxGEasGnmeYzqdQgcIWtd9/s+QPwlDOzkcMrjuLzQaDxaOU0Wv1zsdVpowCJbQ/iwTKey37H4vm9MKB2J/EQc6TSYTEQ7J3eCCTzsn6oRDDAhtTHhYepVQsIRx/J0X+pIv+ga+/xaDwSu+9Ate8GvOb7DbvSNx75hUfj3lOP5GR0NSQzIDzzNotQylY1CvG76+4VbXXkWeH+x9PocTYRj2+fmZqX2k/UR8Ib4SH4j31uZ5dDbCfwiTZI1+f0UhbxhZiNtbj/PYbtDDFA/85IjrhJJNmq65mNFusF7HFPXqGM3+iIKsRIQq6IyakZWgpfjdbmeFrWoRJIlzenwm5YQp9m1VuK6LSqVCYTdsY6jVanauUixNqG5ybhR1fala/iZUhpZQglSURbdpt9uU0ODkoJTPyaX4ryE/oy5TdBqRqw0p9EuRnxtqgUaRKUJfXZvtR9BcdjgcloKIlJF8/gB8cKo5rfwA7gAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/83252004a1964a187bb03dc00259cf86/3684f/1.png&quot;
        srcset=&quot;/static/83252004a1964a187bb03dc00259cf86/12f09/1.png 148w,
/static/83252004a1964a187bb03dc00259cf86/3684f/1.png 225w&quot;
        sizes=&quot;(max-width: 225px) 100vw, 225px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;이는 아래에서 소개하는 다양한 기능이 없는 심플한 &lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt; 같은 로그이면서도 &lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;와 기능적으로 분리하여 사용할 수 있게 만든다.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.error()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;굉장히 많이 사용하는 기능이다. 원하는 &lt;em&gt;에러 메시지&lt;/em&gt;를 콘솔에 찍을 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  const error = new Error(&amp;#39;you are not loggined&amp;#39;);
  console.error(error);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그 결과는 굉장히 에러스러운 메시지를 출력하게 만든다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f2ac69b6c7913c11df78aad8562fbc9e/dea13/2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 514px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 14.18918918918919%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAnUlEQVQI112OyRKCQAxE+f/PU0oWGYYddQaBi1pszwzqxUPXq0q6O/EeUcSiNSQJS12zKPVRmrLqdJ9zPEAcsRnDNgwguuc5bRxjxOd4k8xkLd7a97zalkmCTRhS+T5NEFCeIjFpnu2V6WKYjQXx/gqXrtsLHGfhLNxk77lBJx/aLNuvjGXBRWWkZ0uhDLmy6MRiqw7GYQ858S3+1xsgAODBzj3PigAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/f2ac69b6c7913c11df78aad8562fbc9e/dea13/2.png&quot;
        srcset=&quot;/static/f2ac69b6c7913c11df78aad8562fbc9e/12f09/2.png 148w,
/static/f2ac69b6c7913c11df78aad8562fbc9e/e4a3f/2.png 295w,
/static/f2ac69b6c7913c11df78aad8562fbc9e/dea13/2.png 514w&quot;
        sizes=&quot;(max-width: 514px) 100vw, 514px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;console.debug&lt;/code&gt;와의 큰 차이점은 이미지의 &lt;strong&gt;▼&lt;/strong&gt;에서 보면 알 수 있듯이 stack trace가 가능하다. 어느 지점에서 해당 로그가 나왔는지 확인 가능하므로 어떤 경로로 에러가 나왔는지 추적하기가 굉장히 수월하다.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.warn()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.error&lt;/code&gt;와 유사하지만 warning(경고)를 위해 사용한다.
&lt;code class=&quot;language-text&quot;&gt;console.error&lt;/code&gt;에 비해 많이 사용되지는 않지만, 라이브러리나 프레임워크와 같이 여러 사람들과 협업하는 과정에서 무언가를 알려야할 때에 꽤 유용하게 사용할 수 있다. 예를들면 다음 버전에서 deprecate 될 것이라든지, 동작은 하지만 올바른 사용방법이 따로 있다든지.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0b47199d2b70693f8627e595490b45b0/dea13/3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 514px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 10.81081081081081%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAc0lEQVQI123MywrCMABE0f7/t4lCq3YhImmetpqKEa2J9dpU3Lk4w8DAFGNY0Lcl3q4I5w3eLQm+Jg2aOCji4ytNnZRpxqfkqEtaU81yv1128DIUOe7XPSe3prMVvttOaoQ+IG2Dcg3CCHwv57N3VH/9tg9iVpZb88JkZwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/0b47199d2b70693f8627e595490b45b0/dea13/3.png&quot;
        srcset=&quot;/static/0b47199d2b70693f8627e595490b45b0/12f09/3.png 148w,
/static/0b47199d2b70693f8627e595490b45b0/e4a3f/3.png 295w,
/static/0b47199d2b70693f8627e595490b45b0/dea13/3.png 514w&quot;
        sizes=&quot;(max-width: 514px) 100vw, 514px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.warn&lt;/code&gt;도 trace를 확인할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.assert()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.assert&lt;/code&gt;도 꽤 유용하게 사용할 수 있는 메소드다..&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  const undef = undefined;
  const emptyStr = &amp;#39;&amp;#39;;
  const greeting = &amp;#39;Hello World&amp;#39;;
  console.assert(undef);
  console.assert(emptyStr);
  console.assert(greeting);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;&amp;#39;&amp;#39;&lt;/code&gt; 같은 &lt;code class=&quot;language-text&quot;&gt;falsy&lt;/code&gt; 값에 대한 error 로그를 나타난다. 아닌 경우에는 로그가 나타나지 않는다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/9f94e729a7227c1cf66a6a214fcf2249/267f6/4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 513px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 21.62162162162162%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAz0lEQVQY01WP0W6DMAxF+f+v26RtrDTACISVQIAitRsgcXah2qQ9XNmxnePraH155ZZlLHHMkiSsec6Spsxv7yylYzY588mwZh9gDJQl2zDgNdPo3ervRXGqKrheiZgmvpqGIFAnjdYySNY02LTD5R2FaQlVgHEUbAQB9/yfVNsXRcvTM3eBju3ahmAUBZwTqJ1yOctS1Qu2fUb9re8fBjT/G291fYAj1Lw7R6dzW2lQsxfAxhWl8bjzBXv6lHMPoWML/eHk2/s/7Reu4XHBD7XiKvlPdjwYAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/9f94e729a7227c1cf66a6a214fcf2249/267f6/4.png&quot;
        srcset=&quot;/static/9f94e729a7227c1cf66a6a214fcf2249/12f09/4.png 148w,
/static/9f94e729a7227c1cf66a6a214fcf2249/e4a3f/4.png 295w,
/static/9f94e729a7227c1cf66a6a214fcf2249/267f6/4.png 513w&quot;
        sizes=&quot;(max-width: 513px) 100vw, 513px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.time()&lt;/code&gt; &amp;#x26; &lt;code class=&quot;language-text&quot;&gt;console.timeLog()&lt;/code&gt; &amp;#x26; &lt;code class=&quot;language-text&quot;&gt;console.timeEnd()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;벤치 마킹 등 코드 실행을 측정할 때 사용할 수 있는 API이다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  console.time(&amp;#39;timer #1&amp;#39;);
  let count = 0;
  const timerId = setInterval(() =&amp;gt; {
    console.timeLog(&amp;#39;timer #1&amp;#39;);
    count++;
    if(count &amp;gt; 2) {
      clearInterval(timerId);
      console.timeEnd(&amp;#39;timer #1&amp;#39;);
    }
  },1000);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/aba5c4dcee47c557f7ec7bfaab809c28/2fd48/5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 508px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 20.945945945945947%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAm0lEQVQY01WPCQrFIAxEvf81axe7b7SotPm8AQs/IDHkOTO6lJJt22bzPNu6rnYch3VdZ9M0qXPattXuvm8rBR9CsGEY1Jmf5zGHIPA4jhI+z1MAgt573Zdl0S7n/AnCN02jPYYw7/uaizFq6PteLvu+W13XAnlAQlJc1yUhUlAYFkGYv4S4A5Qv44hIVVXqxQyOFFQJQVI6OwR/0rowwF1HjmQAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/aba5c4dcee47c557f7ec7bfaab809c28/2fd48/5.png&quot;
        srcset=&quot;/static/aba5c4dcee47c557f7ec7bfaab809c28/12f09/5.png 148w,
/static/aba5c4dcee47c557f7ec7bfaab809c28/e4a3f/5.png 295w,
/static/aba5c4dcee47c557f7ec7bfaab809c28/2fd48/5.png 508w&quot;
        sizes=&quot;(max-width: 508px) 100vw, 508px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;위와 같이 사용해서 타임스탬프를 확인할 수 있다.
파라미터로 &lt;code class=&quot;language-text&quot;&gt;label&lt;/code&gt;을 받는다.&lt;/p&gt;
&lt;p&gt;참고로 [&lt;code class=&quot;language-text&quot;&gt;console.timeStamp()&lt;/code&gt;][ref-timestamp]는 표준이 아니라고 함.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.trace()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.trace()&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;console.log()&lt;/code&gt;와 유사하지만 콜스택 정보를 함께 콘솔에 나타낸다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  console.trace(&amp;#39;hello world&amp;#39;);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b66abd7438facc929336b746611412c8/13a9a/6.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 9.45945945945946%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAX0lEQVQI122L2wrCMBAF+//fGUkkl62xwbhxM9L4aAeGAwdmK6XgnMN7zz0EHs+OHB/2Y9DfBkzm/PfEzBCRZa11/VtrjRgjKSVKzqT9xS0rQZTWbYW//JoxBqq69uQL+gSbu5tVSRcAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/b66abd7438facc929336b746611412c8/fcda8/6.png&quot;
        srcset=&quot;/static/b66abd7438facc929336b746611412c8/12f09/6.png 148w,
/static/b66abd7438facc929336b746611412c8/e4a3f/6.png 295w,
/static/b66abd7438facc929336b746611412c8/fcda8/6.png 590w,
/static/b66abd7438facc929336b746611412c8/13a9a/6.png 637w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.group()&lt;/code&gt; &amp;#x26; &lt;code class=&quot;language-text&quot;&gt;console.groupEnd()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.group()&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;console.groupEnd()&lt;/code&gt;는 로그를 그룹해서 몪어준다. 콘솔창을 정리할 때 유용하다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  console.group();
  console.log(&amp;#39;hello&amp;#39;);
  console.log(&amp;#39;world&amp;#39;);
  console.groupEnd();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/c12cdf6c4222b1b23f6575ed32edc1a5/68de2/7.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 16.216216216216214%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAWklEQVQI15XPSwrAIAwE0Nz/oEaELBTR+olj47rQdmDIah6EYoxwzoGZEUJAKQWWtdZrLWOMs7WaRXNO5JwhIp+QJ9B7f8CUEuhqDb13tPv+Ba2qilrr+cycDT++6zI1Tj9OAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/c12cdf6c4222b1b23f6575ed32edc1a5/fcda8/7.png&quot;
        srcset=&quot;/static/c12cdf6c4222b1b23f6575ed32edc1a5/12f09/7.png 148w,
/static/c12cdf6c4222b1b23f6575ed32edc1a5/e4a3f/7.png 295w,
/static/c12cdf6c4222b1b23f6575ed32edc1a5/fcda8/7.png 590w,
/static/c12cdf6c4222b1b23f6575ed32edc1a5/68de2/7.png 677w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.table()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.table()&lt;/code&gt;은 표 형태로 로그를 나타낸다.
&lt;code class=&quot;language-text&quot;&gt;Object&lt;/code&gt;형태로 파라미터를 넘길 수도 있고, &lt;code class=&quot;language-text&quot;&gt;Array&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;Object[]&lt;/code&gt;형태도 가능하다. &lt;code class=&quot;language-text&quot;&gt;Object[]&lt;/code&gt; 형태로 파라미터를 넘겼을 경우는 두 번째 파라미터에 프로퍼티명을 파라미터로 넣어서 원하는 속성만을 확인할 수도 있다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  console.table({name: &amp;#39;apple&amp;#39;, amount: 10});
  console.table([&amp;#39;apple&amp;#39;, &amp;#39;orange&amp;#39;]);
  const fruits = [
    {
      name: &amp;#39;apple&amp;#39;,
      amount: 10,
    }, {
      name: &amp;#39;orange&amp;#39;,
      amount: 12,
    }, {
      name: &amp;#39;strawberry&amp;#39;,
      amount: 15,
    }
  ];
  console.table(fruits);
  console.table(fruits, [&amp;#39;name&amp;#39;]);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/62314419ff1fce6292eb7d631bd24dd1/31493/8.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 89.86486486486487%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACRUlEQVQ4y3WUiXKDMAxE+f+vbJuUQA7C4duY7UpAmvSYyY6MJTv4aU01DgMOhwO62w3TNGEaR8ZN21hqTp9HXM9nmL1GcxOGvsflclFZY1D1nPj4+MA4DnDOwVn7KmdhWHg+vON2PML/rJFnynIcQuCGo0HdXuFTQchgXF4U8gIbCroLF04ePi+/anbFXFBNk8GpOcO6gDwvSJxM86b8HSP/jOE1/6NmZqzkNeXY8topJaQYX5UiIqPl0b33j5qouaQ42rbFmXxlj2ok3LZtMAz9N0O36YlhS34dF3rvXvgKO2MmbVYInhsap+xELpY/ZcKM6XzDeKj5phEuyfz8yPu0xphmMjQW167HvR8ROJF2jspm2fhRhBhYG7ea/KtO5sgw55WDHFfGqzIy+QhfHe+aZ40xBj26jOXogkx8KJZSH9Z1jf5+V2MKC/mDgWb+fHvDQMObfX7L1Z8NmqZR0+/8ZCxNq4zzagkiYVxWzVAupqH76dE1t2vBrePx0/MaqF/l+JWxNCszcWelolFZZa4dTN3A3QcEPq+LZ24Y+fxaH5UnmyLs5K7Ka5fCv1wW/jaRUSHHQmYyv+cK4S+P58J1qxaqEnPKJbfcOG6GfYi5KE1gdOQTfuR3Yzf0Z9ue1ZPalBObMmy3RSaf5Tbjnt7fcWc3n2vco87oxvpxEIa7sf+79FbMfekwHU/K2/9Tqx8Hyy6roXP5ffHn1bSS9zS+PTXwtzsiW5z++JBkaYq8snxc5cjznBVs+UvMFTJT0eDln7ovY3x3/3X7to4AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/62314419ff1fce6292eb7d631bd24dd1/fcda8/8.png&quot;
        srcset=&quot;/static/62314419ff1fce6292eb7d631bd24dd1/12f09/8.png 148w,
/static/62314419ff1fce6292eb7d631bd24dd1/e4a3f/8.png 295w,
/static/62314419ff1fce6292eb7d631bd24dd1/fcda8/8.png 590w,
/static/62314419ff1fce6292eb7d631bd24dd1/31493/8.png 664w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.debug()&lt;/code&gt;에서 부터 &lt;code class=&quot;language-text&quot;&gt;console.tabel()&lt;/code&gt;까지 다양한 Console API를 확인해보았다.
다양한 Console API를 이용해서 좀 더 세련되고 풍성한 디버깅을 즐겨보자!&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;[MDN][ref-mdn]&lt;/li&gt;
&lt;li&gt;[There’s more than just console.log()…other useful ways to use the console in javascript][ref-dev-to]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[ref-timestamp]: [https://developer.mozilla.org/en-US/docs/Web/API/Console/timeStamp]
[ref-mdn]: [https://developer.mozilla.org/en-US/docs/Web/API/Console]
[ref-dev-to]: [https://dev.to/developer_buddy/there-s-more-than-just-console-log-other-useful-ways-to-use-the-console-in-javascript-17l8]&lt;/p&gt;</content:encoded></item><item><title><![CDATA[날짜 입력을 편하게 해주는 vscode extension Insert Date String]]></title><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-vscode-ext-insert-date-string/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-vscode-ext-insert-date-string/</guid><pubDate>Mon, 05 Oct 2020 15:14:25 GMT</pubDate><content:encoded></content:encoded></item><item><title><![CDATA[Jekyll 포스트를 숨기고 싶을 땐 published!]]></title><description><![CDATA[작성중인 포스트 보여주고 싶지 않아! github에서 Jekyll기반 블로그로 갈아타기 시작하며 몇 가지 장점? 특징?이 있다. 나름 재미를 느끼고 있다. 깃헙의 무료 포스트 테마 등 자유도가 높음 사용하는 IDE를 이용해서 작업하고 github…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-jekyll-front-matter-published/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-jekyll-front-matter-published/</guid><pubDate>Mon, 05 Oct 2020 14:12:15 GMT</pubDate><content:encoded>&lt;h1&gt;작성중인 포스트 보여주고 싶지 않아!&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;github&lt;/strong&gt;에서 &lt;strong&gt;Jekyll&lt;/strong&gt;기반 블로그로 갈아타기 시작하며 몇 가지 장점? 특징?이 있다. 나름 재미를 느끼고 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;깃헙의 무료 포스트&lt;/li&gt;
&lt;li&gt;테마 등 자유도가 높음&lt;/li&gt;
&lt;li&gt;사용하는 IDE를 이용해서 작업하고 github으로 바로 올리면 된다.&lt;/li&gt;
&lt;li&gt;마크다운 문법 (장점이자 단점이다..!!)&lt;/li&gt;
&lt;li&gt;CLI처럼 다 외우거나 자주 쓰지 않는 문법을 이용할 경우에는 치트시트가 필요함.&lt;/li&gt;
&lt;li&gt;하지만 문서가 규격화 되어 서식을 일괄적으로 조정하거나 관리할 수 있고, 예상 가능한 수준의 규격을 지니게 된다.&lt;/li&gt;
&lt;li&gt;뭘 추가하려면 직접 구성해야함. (좀 귀찮아 보이긴 하지만 의외로 찾아보면 방법들이 잘 정리되어있다.)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이러한 느낌들을 느끼는 중..
오래전에 사용했던 태터툴즈나 워드프레스, 네이버 블로그 등 다양한 블로그 서비스들에 비해 받았던 첫 인상 중 하나는 &lt;strong&gt;관리자 페이지&lt;/strong&gt;가 없다는 것이었다.
(찾아보니 &lt;a href=&quot;https://github.com/jekyll/jekyll-admin&quot;&gt;jekyll-admin&lt;/a&gt; 이라는 모듈이 있긴 한 듯 하다. 하지만 아직까지 이정도의 필요성은 못느끼겠다..)&lt;/p&gt;
&lt;p&gt;기존 블로그 서비스들의 관리자 기능에서 가장 많이 사용하는 기능중 하나가 &lt;em&gt;포스트의 show/hide를 관리&lt;/em&gt;하는 것이었다.
jekyll 블로그를 사용하게 되면서 다른 것보다도 제일 먼저 필요를 느낀 기능이다.&lt;/p&gt;
&lt;p&gt;짬짬이 블로그 포스트를 작성하다보면, 한 포스트가 완성되기 전까지 여러번 커밋을 거쳐야할 경우가 발생한다. 당연 작성중인 포스트를 걸기엔 너무 챙피해.. 완성된 뒤에 보여주고 싶어! 하지만 그전까지 커밋을 참기엔..? 환경을 옮겨서 작성해야한다면? 이럴 때엔 어쩌면 좋을까?&lt;/p&gt;
&lt;h1&gt;답은 front-matter에 있다.&lt;/h1&gt;
&lt;p&gt;세상에 필요한 것은 이미 다 있다고 했던가.. 역시나 필요하던 기능이 있었다. 답은 &lt;strong&gt;front-matter&lt;/strong&gt;에 있었다.&lt;/p&gt;
&lt;p&gt;일반적으로 설정하게 되는 front-matter는 다음과 같다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;layout: post
title: &amp;quot;Jekyll 포스트를 숨기고 싶을 땐 published&amp;quot;
date: 2020-10-05 14:12:15
categories: jekyll
tags: jekyll&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서 블로그에서 글을 내리고 싶다면 어떨까?
바로 아래 한 줄을 추가하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;...
published: false
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;front-matter&lt;/strong&gt;에 추가할 수 있는 &lt;code class=&quot;language-text&quot;&gt;published&lt;/code&gt;는 특정 포스트를 보여주고싶지 않을 때에 사용할 수 있는 속성이다. &lt;code class=&quot;language-text&quot;&gt;published&lt;/code&gt;의 값을 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;로 해두면 블로그에서 해당 포스트가 사라져 보이게 된다.&lt;/p&gt;
&lt;p&gt;역시 이미 편리하게 사용할 수 있는 다양한 기능을 제공하고 있다.&lt;/p&gt;
&lt;p&gt;이로써 &lt;code class=&quot;language-text&quot;&gt;jekyll-admin&lt;/code&gt; 설치는 잠시 미뤄두기로 한다… (ㅋㅋㅋ)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Hook Form의 watch() vs getValues]]></title><description><![CDATA[React Hook Form은 14.7k에 빛나는 리액트용 폼 라이브러리이다.
폼 생성과 검증 등 개발 과정을 간소화할 수 있고, 폼 생성 과정과 코드를 좀 더 규격화 할 수 있다는 장점이 있다.
다른 폼 라이브러리에 비해서 React Hooks…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-rhf-watch-vs-getvalues/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-rhf-watch-vs-getvalues/</guid><pubDate>Mon, 05 Oct 2020 14:11:13 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;React Hook Form&lt;/strong&gt;은 14.7k에 빛나는 리액트용 폼 라이브러리이다.
폼 생성과 검증 등 개발 과정을 간소화할 수 있고, 폼 생성 과정과 코드를 좀 더 규격화 할 수 있다는 장점이 있다.
다른 폼 라이브러리에 비해서 React Hooks 형태로 사용할 수 있다는 점과 빠르다는 장점도 있다.
또한, 문서가 &lt;strong&gt;굉장히&lt;/strong&gt; 잘 구성되어있다.ㅎㅎ (완벽하지는 않지만 번역도 되어있는 듯 하다.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React Hook Form&lt;/strong&gt;사용에 필수적인 &lt;code class=&quot;language-text&quot;&gt;getValues&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;의 차이점에 대하여 메모해두고자 한다.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt; vs &lt;code class=&quot;language-text&quot;&gt;getValues&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;getValues&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;는 &lt;strong&gt;React Hook Form&lt;/strong&gt;을 값을 나타내거나 확인하는 등에 사용하기 때문에 필수적으로 사용하게 된다.
&lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;를 대부분 사용하지만…&lt;/p&gt;
&lt;p&gt;이미 &lt;a href=&quot;https://react-hook-form.com/faqs/#watchvsgetValuesvsstate&quot;&gt;공식 문서&lt;/a&gt;에서는 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;getVAlues&lt;/code&gt;에 대한 차이점을 아래와 같이 설명하고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;watch: subscribe to either all inputs or the specified inputs changes via event listener and re-render based on which fields that are subscribed. Check out this codesandbox for actual behaviour.
getValues: get values that are stored inside the custom hook as reference, fast and cheap. This method doesn’t trigger re-render.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아주 친절하게 &lt;a href=&quot;https://codesandbox.io/s/react-hook-form-watch-with-radio-buttons-and-select-examples-ovfus&quot;&gt;codesandbox&lt;/a&gt;로 예제도 제공하고 있다.&lt;/p&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/react-hook-form-watch-with-radio-buttons-and-select-examples-ovfus?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
  style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
  title=&quot;React Hook Form - watch with Radio Buttons and Select examples&quot;
  allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
  sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
&gt;&lt;/iframe&gt;
&lt;p&gt;핵심은 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;는 &lt;strong&gt;값 변화에 대해 컴포넌트가 re-render가 이루어지고&lt;/strong&gt; &lt;code class=&quot;language-text&quot;&gt;getValues&lt;/code&gt;는 그렇지 않다는 점이다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;는 input의 변화를 &lt;strong&gt;subscribe&lt;/strong&gt;해서 변화에 따라 re-render가 이루어진다.&lt;/p&gt;
&lt;p&gt;반면 &lt;code class=&quot;language-text&quot;&gt;getValues&lt;/code&gt;는 RHF 내에 render와 관계없이 저장된 value를 가져올 때에 사용된다. &lt;strong&gt;re-render&lt;/strong&gt;가 이루어지지 않는다. 따라서 빠르고 cheap한 메소드이다.&lt;/p&gt;
&lt;p&gt;개발을 하다보면 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;getValeus&lt;/code&gt;의 깂이 다른 시점이 있을 수 있는데, 이 차이점에서 비롯된 것이라고 볼 수 있다.&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://react-hook-form.com/faqs/#watchvsgetValuesvsstate&quot;&gt;React Hook Form 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codesandbox.io/s/react-hook-form-watch-with-radio-buttons-and-select-examples-ovfus&quot;&gt;codesandbox&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[Jekyll 테마를 바꿔보기]]></title><description><![CDATA[Jekyll 테마 변경해보기 약 한 달간 방치하고 있던 블로그의 테마를 변경했다. 원래는 터미널 테마  이었는데 윈도우 스타일로 ㅎㅎ 터미널 테마가 썩 마음에 들어 적용한 가장 큰 이유는   compatible…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-09-29-theme-change/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-09-29-theme-change/</guid><pubDate>Fri, 20 Oct 2017 12:26:28 GMT</pubDate><content:encoded>&lt;h1&gt;Jekyll 테마 변경해보기&lt;/h1&gt;
&lt;p&gt;약 한 달간 방치하고 있던 블로그의 테마를 변경했다. 원래는 터미널 테마 &lt;code class=&quot;language-text&quot;&gt;b2a3e8/jekyll-theme-console&lt;/code&gt; 이었는데 윈도우 스타일로 ㅎㅎ&lt;/p&gt;
&lt;p&gt;터미널 테마가 썩 마음에 들어 적용한 가장 큰 이유는 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;remote_theme&lt;/code&gt; compatible이라 &lt;code class=&quot;language-text&quot;&gt;_config.yml&lt;/code&gt;에 단 한줄 추가만으로 간편하게 설치가 가능하다는 점&lt;/li&gt;
&lt;li&gt;까만 배경에 안정감을 준다는 점&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이었는데 변경을 결심하였다.&lt;/p&gt;
&lt;p&gt;그 이유는 내가 지킬 사용법을 잘 모르는데 많은 내용이 감춰져 있어서 구조를 더욱 모르는 상태에서 작업해야해서 (적어놓고 보니 좋은 점이잖아?!) 손을 댈 엄두가 나지 않았던 점이 있고 (마치 처음 프레임워크를 접할 때와 같은 막연한 심정? ㅋㅋ),
사실 메뉴 등 각 영역이 분리 되어 잘 보이지 않아서 뭐가 뭔지 잘 모르는 이유가 컸다.&lt;/p&gt;
&lt;p&gt;막상 테마의 적용은 그다지 어렵지 않았다.&lt;/p&gt;
&lt;p&gt;그냥 테마로 나와 있는 파일들을 저장소에 넣어주기만 하고 기존 &lt;code class=&quot;language-text&quot;&gt;_config.yml&lt;/code&gt;파일만 만져주면 됐다. 테마에 대한 샘플 파일들도 제공하고 있는 것 같았다. &lt;code class=&quot;language-text&quot;&gt;remote_theme&lt;/code&gt;을 처음부터 사용할 때보다 조금 더 나은 점이라고 한다면, 이 샘플 파일들이 지킬의 구조를 이해하는데 도움을 주는 것 같다.&lt;/p&gt;
&lt;p&gt;우선 &lt;code class=&quot;language-text&quot;&gt;_layout&lt;/code&gt;의 존재를 알게 되었고, &lt;code class=&quot;language-text&quot;&gt;_data/tags&lt;/code&gt;로 &lt;strong&gt;tag&lt;/strong&gt;를 &lt;strong&gt;메뉴&lt;/strong&gt;처럼 관리할 수 있다는 점, &lt;strong&gt;scss&lt;/strong&gt;도 지원한다는 점 등등.. 이러한 가이드를 엿볼 수 있는 점이 좋았다. 또 설치했기 때문에 내가 손을 볼수도 있겠구나 ㅎㅎ..&lt;/p&gt;
&lt;p&gt;좀 더 공부해서 테마도 커스터마이즈 해봐야겠다. md, 지킬도 배워야하고, 보금자리 꾸며나가는 마음으로 차근차근 ㅎㅎ&lt;/p&gt;
&lt;p&gt;추가로 개인적으로 마음에 드는 theme을 여기에 적어둔다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.base68.com/&quot;&gt;Mediator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jekyllthemes.org/themes/mere-blog-theme/&quot;&gt;mere-blog-theme&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jekyllthemes.org/themes/Pinghsu-Theme/&quot;&gt;Pinghsu-Theme&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/daattali/beautiful-jekyll&quot;&gt;beautiful-jekyll&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;refrence&lt;/h2&gt;
&lt;p&gt;블로그를 처음 시작하면서 도움이 될 만한 포스트&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://dreamgonfly.github.io/blog/jekyll-remote-theme/&quot;&gt;쉽고 빠르게 수준 급의 GitHub 블로그 만들기 - jekyll remote theme으로&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jekyllrb.com/docs/&quot;&gt;jekyll document&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/ihoneymon/652be052a0727ad59601&quot;&gt;md 정리&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gjchoi.github.io/env/Kramdown(%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4)-%EC%82%AC%EC%9A%A9%EB%B2%95/&quot;&gt;md 정리&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item></channel></rss>