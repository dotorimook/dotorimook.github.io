<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://gatsby-starter-blog-demo.netlify.com</link><generator>GatsbyJS</generator><lastBuildDate>Sat, 06 Feb 2021 04:12:53 GMT</lastBuildDate><item><title><![CDATA[에러 “error fsevents@2.0.7: The platform ”linux“ is incompatible with this module.”, ”error Found incompatible module.”를 만났을 때]]></title><description><![CDATA[cra 프로젝트를 docker를 이용해 빌드하려고  컨테이너에서 을 실행하도록 했는데 다음과 같은 에러를 마주하게 된다. 아무래도 에러는 특정 모듈이 linux…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2021-01-17-yarn-incompatible-error/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2021-01-17-yarn-incompatible-error/</guid><pubDate>Sun, 17 Jan 2021 10:03:58 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;cra&lt;/em&gt; 프로젝트를 &lt;em&gt;docker&lt;/em&gt;를 이용해 빌드하려고 &lt;code class=&quot;language-text&quot;&gt;node&lt;/code&gt; 컨테이너에서 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;을 실행하도록 했는데 다음과 같은 에러를 마주하게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;yarn install v1.21.1
[1/4] Resolving packages...
[2/4] Fetching packages...
info fsevents@2.3.1: The platform &amp;quot;linux&amp;quot; is incompatible with this module.
info &amp;quot;fsevents@2.3.1&amp;quot; is an optional dependency and failed compatibility check. Excluding it from installation.
error postcss@8.1.9: The engine &amp;quot;node&amp;quot; is incompatible with this module. Expected version &amp;quot;^10 || ^12 || &amp;gt;=14&amp;quot;. Got &amp;quot;13.8.0&amp;quot;
error Found incompatible module.
info Visit https://yarnpkg.com/en/docs/cli/install for documentation about this command.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;아무래도 에러는 특정 모듈이 linux 호환이 안된다는 것 같다? 이런 일이…
&lt;code class=&quot;language-text&quot;&gt;node:latest&lt;/code&gt; 이미지로도 동일했다.
이 문제는 &lt;code class=&quot;language-text&quot;&gt;fsevents&lt;/code&gt; 모듈의 문제로, &lt;code class=&quot;language-text&quot;&gt;fsevents&lt;/code&gt; 모듈이 MacOS를 위한 것이고, linux에서는 안되어서 인 것 같다.
그래서 &lt;strong&gt;yarn.lock&lt;/strong&gt; 파일의 &lt;code class=&quot;language-text&quot;&gt;fsevents&lt;/code&gt;가 포함된 dependency 부분을 제거하는 것으로 해결 가능하다고 한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt;파일의&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  fsevents@^1.2.7, fsevents@^2.0.6:
  version &amp;quot;2.0.7&amp;quot;
  resolved &amp;quot;https://registry.yarnpkg.com/fsevents/-/fsevents-2.0.7.tgz#382c9b443c6cbac4c57187cdda23aa3bf1ccfc2a&amp;quot;
  integrity sha512-a7YT0SV3RB+DjYcppwVDLtn13UQnmg0SWZS7ezZD0UjnLwXmy8Zm21GMVGLaFGimIqcvyMQaOJBrop8MyOp1kQ==&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;부분과&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  optionalDependencies:
    fsevents &amp;quot;^2.0.6&amp;quot;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;부분을 제거한다.&lt;/p&gt;
&lt;p&gt;더욱 같단한 방법으로는 &lt;code class=&quot;language-text&quot;&gt;--ignore-engines&lt;/code&gt; 옵션을 확용한다. 아래와 같이 커맨드를 입력하도록 하면 해결된다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;yarn install --ignore-engines&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;--ignore-engeins&lt;/code&gt; 옵션은 엔진 체크를 무시하는 옵션이다.&lt;/p&gt;
&lt;h3&gt;reference&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/40225844/why-does-yarn-say-found-incompatible-module-when-the-version-is-correct&quot;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/57082249/how-to-fix-error-fsevents2-0-7-the-platform-linux-is-incompatible-with-thi&quot;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[docker container에서 pm2가 시작하자마자 종료될 때]]></title><description><![CDATA[도커 컨테이너에서 pm2를 실행하는 데 바로 꺼질 때 node 프로젝트를 프로덕션 환경에 pm2로 올려보도록 한다. node docker image를 이용해서 docker container…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-12-20-docker-pm2/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-12-20-docker-pm2/</guid><pubDate>Sun, 20 Dec 2020 00:51:10 GMT</pubDate><content:encoded>&lt;h1&gt;도커 컨테이너에서 pm2를 실행하는 데 바로 꺼질 때&lt;/h1&gt;
&lt;p&gt;node 프로젝트를 프로덕션 환경에 &lt;strong&gt;pm2&lt;/strong&gt;로 올려보도록 한다. node docker image를 이용해서 docker container에서 &lt;code class=&quot;language-text&quot;&gt;pm2 start&lt;/code&gt;로 시작하도록 올려본다. 하지만 갑자기 시작하자마자 docker container가 종료된다. 분명 정확하게 프로세스기 실행되었는데.. 어찌된 일일까. 어떻게 해결할까?&lt;/p&gt;
&lt;p&gt;결론부터 말하자면 &lt;code class=&quot;language-text&quot;&gt;pm2&lt;/code&gt;가 아니라 &lt;code class=&quot;language-text&quot;&gt;pm2-runtime&lt;/code&gt;을 이용하면 해결된다.&lt;/p&gt;
&lt;p&gt;그러니까,&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$pm2 start ecosystem.config.js&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;라고 되어있었다면,&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$pm2-runtime start ecosystem.config.js&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;라고 해주면 된다.&lt;/p&gt;
&lt;p&gt;이유는,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;pm2&lt;/code&gt;: 일반적인 용도로 애플리케이션을 백그라운드에 보내고 실행함.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;pm2-runtime&lt;/code&gt;: 도커 컨테이너에서 사용하는 용도로, 애플리케이션을 foreground에 유지하고 컨테이너를 계속 실행하게 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이라고 한다.&lt;/p&gt;
&lt;p&gt;문서에 따르면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The goal of pm2-runtime is to wrap your applications into a proper Node.js production environment. It solves major issues when running Node.js applications inside a container like: Second Process Fallback for High Application Reliability Process Flow Control Automatic Application Monitoring to keep it always sane and high performing Automatic Source Map Discovery and Resolving Support Further than that, using PM2 as a layer between the container and the application brings PM2 powerful features like application declaration file, customizable log system and other great features to manage your Node.js application in production environment.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53962776/whats-the-difference-between-pm2-and-pm2-runtime&quot;&gt;stackOverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[yarn.lock package-lock.json 간 변환]]></title><description><![CDATA[Yarn or NPM…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-12-02-package-lock-yarn-lock-conversion/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-12-02-package-lock-yarn-lock-conversion/</guid><pubDate>Wed, 02 Dec 2020 13:11:10 GMT</pubDate><content:encoded>&lt;h1&gt;Yarn or NPM?&lt;/h1&gt;
&lt;p&gt;웹 개발시 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;이나 &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;을 패키지 매니저로 사용한다. &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;은 거의 동일하다. &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;이 더 기본값이라고 생각할 수 있다. 나는 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;을 선호한다. 내가 처음 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;을 접하던 시기에 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;보다 미세하게 더 빨랐고, 이전에는 패키지를 설치할 때에 &lt;code class=&quot;language-text&quot;&gt;npm install --save&lt;/code&gt;라고 &lt;code class=&quot;language-text&quot;&gt;--save&lt;/code&gt; 옵션을 쓰지 않으면 추가한 패키지가 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt;의 의존성에 작성되지 않았다. 그래서 항상 패키지를 설치할 때에 &lt;code class=&quot;language-text&quot;&gt;--save&lt;/code&gt;라는 옵션을 사용해야하는 번거로움이 존재했다. 그래서 &lt;code class=&quot;language-text&quot;&gt;Yarn&lt;/code&gt;을 선호했다.&lt;/p&gt;
&lt;h1&gt;&lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; or &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt;?&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;을 이용하면 &lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; 파일이 생성되고 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt;을 하게되면 &lt;code class=&quot;language-text&quot;&gt;pacakge-lock.json&lt;/code&gt;파일이 생성되는 것을 확인할 수 있다. 파일 내용을 보면 알겠지만 설치된 의존성 패키지들의 버전이 기록되어있다. 프로젝트가 개발되는 시점에 어떤 의존성이 설치되어있는가 확인할 수 있는 자료가 된다. &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt;파일의 의존성 정보에는 각 패키지의 &lt;strong&gt;특정 버전을 명시&lt;/strong&gt;해서 작성할 수도 있지만, &lt;em&gt;일정 버전 이상&lt;/em&gt;이라든지 조금 더 유연하게 작성할 수 있기 때문에, 이 &lt;strong&gt;lock&lt;/strong&gt;파일 들이 &lt;em&gt;패키지를 설치하는 시점에 어떤 버전을 설치했는지 확인할 수 있는 기준&lt;/em&gt;이 된다. 또한, 개발 하던 시점의 패키지 의존성 상태를 복원할 수 있는 자료가 된다. 즉, &lt;strong&gt;의존성 패키지들의 버전의 일관성&lt;/strong&gt;을 유지하기 위해 필요한 파일이라는 뜻이다.&lt;/p&gt;
&lt;p&gt;이 lock 파일들을 &lt;code class=&quot;language-text&quot;&gt;gitignore&lt;/code&gt;에 추가해야하는지 말아야하는지에 대한 이야기가 있곤 하는데 바로 위 이유 때문에 이 lock파일들은 무조건 유지해야하고 &lt;strong&gt;gitignore처리하면 안된다&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;&lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 간 변환&lt;/h1&gt;
&lt;p&gt;그런데 나는 yarn 개발 환경을 써왔는데, 정작 원격 빌드 환경은 npm을 쓰는 경우에는, 또는 그 반대의 경우에는 어떻게 해야하는가? 좀 황당한 질문이지만 이런 종류가 왕왕있다. 그래서 찾아봤다. 그랬더니 &lt;em&gt;&lt;a href=&quot;https://github.com/imsnif/synp&quot;&gt;synp&lt;/a&gt;&lt;/em&gt; 라는 도구가 있었다. &lt;em&gt;synp&lt;/em&gt;는 &lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; 파일을 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt;파일로 변환하거나 그 반대로 변환해주는 도구이다. &lt;code class=&quot;language-text&quot;&gt;npm install -g&lt;/code&gt; 또는 &lt;code class=&quot;language-text&quot;&gt;yarn global add&lt;/code&gt;로 글로벌로 설치해서 사용할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;yarn global add synp&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;변환은 다음과 같이 커맨드를 입력하여 변환 가능하다:&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;synp --source-file yarn.lock            # will create package-lock.json
synp --source-file package-lock.json    # will create yarn.lock&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그럼 이제 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; 고민 끝 ㅎㅎㅎ&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/50093627/how-to-convert-package-lock-json-to-yarn-lock&quot;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/imsnif/synp&quot;&gt;synp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[[nginx] nginx.conf 설정으로 프록시 서버 쿠키 설정 추가하기]]></title><description><![CDATA[nginx로 프록시 서버를 구성하게 되면, 프록시서버로 연결된 내부 백엔드 구조에서는  등 속성이 위부로 통하는 response에 적용되지 않는 문제가 발생한다. 이럴 때  nginx.conf…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-11-21-nginx-cookie-override/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-11-21-nginx-cookie-override/</guid><pubDate>Sun, 22 Nov 2020 00:01:10 GMT</pubDate><content:encoded>&lt;p&gt;nginx로 프록시 서버를 구성하게 되면, 프록시서버로 연결된 내부 백엔드 구조에서는 &lt;code class=&quot;language-text&quot;&gt;Secure&lt;/code&gt; 등 속성이 위부로 통하는 response에 적용되지 않는 문제가 발생한다. 이럴 때  &lt;strong&gt;nginx.conf&lt;/strong&gt; 파일에서 아래와 같이 &lt;code class=&quot;language-text&quot;&gt;proxy_cookie_path&lt;/code&gt;를 이용하여 설정할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;location /foo {
    proxy_pass http://localhost:4000;
    proxy_cookie_path /foo &amp;quot;/; SameSite=None; HTTPOnly; Secure&amp;quot;;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;크로스 도메인의 경우 &lt;code class=&quot;language-text&quot;&gt;SameSite=none&lt;/code&gt;처리도 필요하다.&lt;/p&gt;
&lt;h3&gt;Refernce&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/48880738/how-to-set-secure-attribute-to-set-cookie-in-nginx-through-nginx-conf-file&quot;&gt;Stackoverflow&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Portal + Hook으로 외부 DOM에 Component 생성하기]]></title><description><![CDATA[Portals - React Portal은 부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링하는 최고의 방법을 제공합니다. Why Portal? Portal은 기존 React Component가 담겨있는 DOM Tree…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-11-17-react-portal/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-11-17-react-portal/</guid><pubDate>Tue, 17 Nov 2020 08:24:48 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://ko.reactjs.org/docs/portals.html&quot;&gt;Portals - React&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Portal은 부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링하는 최고의 방법을 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Why Portal?&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Portal&lt;/strong&gt;은 기존 React Component가 담겨있는 DOM Tree 밖으로 Component를 렌더링을 할 때에 사용할 수 있는 기법이다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;React.Portal&lt;/code&gt;의 &lt;strong&gt;&lt;em&gt;대표적인 유스케이스&lt;/em&gt;&lt;/strong&gt;가 있다. 다이얼로그 처럼 전체 페이지를 덮어쓰면서 튀어나오도록 보이게 하는 컴포넌트들을 나타낼 때이다. 일반적인 경우 모달 다이얼로그는 페이지 전체를 덮어쓰는 방식이기 때문에 &lt;code class=&quot;language-text&quot;&gt;position:fixed&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;z-index&lt;/code&gt; 등 속성을 사용하게 되지만, 결국 부모 엘레멘트의 속성에 영향을 받기 때문에, 페이지 최상단 등에 두게 된다. &lt;strong&gt;redux&lt;/strong&gt;, &lt;strong&gt;mobx&lt;/strong&gt; 등을 이용해 상태관리를 하고 있는 경우에는 다이얼로그의 show/hide를 별도의 공간에서 관리하기 때문에 원격지의 컴포넌트의 상태를 관리하는 것이 간단하지만, 원격지에 있는 컴포넌트가 여간 신경쓰이는 것이 아니게 된다… 이럴 때에 &lt;strong&gt;Portal&lt;/strong&gt;을 사용하면, 기존의 DOMTree 밖으로 컴포넌트를 생성할 수 있기 때문에 부모 엘레멘트의 속성으로 부터 자유로워질 수 있다!&lt;/p&gt;
&lt;h1&gt;Portal의 사용&lt;/h1&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;ReactDOM.createPortal(child, container)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;일반적으로 &lt;code class=&quot;language-text&quot;&gt;index&lt;/code&gt;에 담겨있는 &lt;code class=&quot;language-text&quot;&gt;ReactDOM.render&lt;/code&gt;와 유사하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt;: 렌더링 할 컴포넌트&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;container&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt;를 담을 DOM 엘레멘트&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;예제&lt;/h2&gt;
&lt;p&gt;예제는 &lt;a href=&quot;https://ko.reactjs.org/docs/portals.html&quot;&gt;리액트 공식 문서&lt;/a&gt;에서 잘 제공 하고 있다. &lt;a href=&quot;https://codepen.io/gaearon/pen/jGBWpE&quot;&gt;codepen&lt;/a&gt;도 제공하고 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;app-root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;modal-root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;Portal.js&lt;/strong&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 여기 이 두 컨테이너는 DOM에서 형제 관계입니다.
const appRoot = document.getElementById(&amp;#39;app-root&amp;#39;);
const modalRoot = document.getElementById(&amp;#39;modal-root&amp;#39;);

class Modal extends React.Component {
  constructor(props) {
    super(props);
    this.el = document.createElement(&amp;#39;div&amp;#39;);
  }

  componentDidMount() {
    // Portal 엘리먼트는 Modal의 자식이 마운트된 후 DOM 트리에 삽입됩니다.
    // 요컨대, 자식은 어디에도 연결되지 않은 DOM 노드로 마운트됩니다.
    // 만약 자식 컴포넌트가 마운트될 때 그것을 즉시 DOM 트리에 연결해야만 한다면,
    // 예를 들어, DOM 노드를 계산한다든지 자식 노드에서 &amp;#39;autoFocus&amp;#39;를 사용한다든지 하는 경우에,
    // Modal에 state를 추가하고 Modal이 DOM 트리에 삽입되어 있을 때만 자식을 렌더링하십시오.
    modalRoot.appendChild(this.el);
  }

  componentWillUnmount() {
    modalRoot.removeChild(this.el);
  }

  render() {
    return ReactDOM.createPortal(
      this.props.children,
      this.el
    );
  }
}
class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {clicks: 0};
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    // 이것은 Child에 있는 버튼이 클릭 되었을 때 발생하고 Parent의 state를 갱신합니다.
    // 비록 버튼이 DOM 상에서 직계 자식이 아니라고 하더라도 말입니다.
    this.setState(state =&amp;gt; ({
      clicks: state.clicks + 1
    }));
  }
  render() {
    return (
      &amp;lt;div onClick={this.handleClick}&amp;gt;
        &amp;lt;p&amp;gt;Number of clicks: {this.state.clicks}&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;
          Open up the browser DevTools
          to observe that the button
          is not a child of the div
          with the onClick handler.
        &amp;lt;/p&amp;gt;
        &amp;lt;Modal&amp;gt;
          &amp;lt;Child /&amp;gt;
        &amp;lt;/Modal&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

function Child() {
  // 이 버튼에서의 클릭 이벤트는 부모로 버블링됩니다.
  // 왜냐하면 &amp;#39;onClick&amp;#39; 속성이 정의되지 않았기 때문입니다.
  return (
    &amp;lt;div className=&amp;quot;modal&amp;quot;&amp;gt;
      &amp;lt;button&amp;gt;Click&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}
ReactDOM.render(&amp;lt;Parent /&amp;gt;, appRoot);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;Portal Component&lt;/h2&gt;
&lt;p&gt;사용법은 간단하므로, Portal Component를 만들어서 사용하면 되겠다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React, { FC } from &amp;#39;react&amp;#39;;
import ReactDOM from &amp;#39;react-dom&amp;#39;;

const Portal:FC&amp;lt;any&amp;gt; = ({ children, className = &amp;#39;root-portal&amp;#39;, el = &amp;#39;div&amp;#39; }) =&amp;gt; {
  const [container] = React.useState(document.createElement(el));

  container.classList.add(className);

  React.useEffect(() =&amp;gt; {
    document.body.appendChild(container);
    return () =&amp;gt; {
      document.body.removeChild(container);
    };
  }, [container]);

  return ReactDOM.createPortal(children, container);
};

export default Portal;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;생성된 컴포넌트를 넣고 뺄 때 자연스럽게 &lt;code class=&quot;language-text&quot;&gt;body&lt;/code&gt;에서 사라지게 할 수 있다.&lt;/p&gt;
&lt;h3&gt;출처&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/49426474/can-a-react-portal-be-used-in-a-stateless-functional-component-sfc/59154364#59154364&quot;&gt;Stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[JQuery Uncaught TypeError: a.indexOf is not a function 에러처리]]></title><description><![CDATA[ㅎㅎㅎ 예전에 네이버 블로그에서 작성했던 글이었는데,
최근 어떤 분이 댓글을 달아두셔서 뿌듯했던 포스트라 이쪽으로 옮겨온다. ㅎㅎㅎ Uncaught TypeError: a.indexOf is not a function JQuery…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-11-13-jquery-load-error/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-11-13-jquery-load-error/</guid><pubDate>Fri, 13 Nov 2020 09:41:58 GMT</pubDate><content:encoded>&lt;p&gt;ㅎㅎㅎ 예전에 네이버 블로그에서 작성했던 글이었는데,
최근 어떤 분이 댓글을 달아두셔서 뿌듯했던 포스트라 이쪽으로 옮겨온다. ㅎㅎㅎ&lt;/p&gt;
&lt;h1&gt;Uncaught TypeError: a.indexOf is not a function&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;JQuery&lt;/strong&gt; 프로젝트 상에서 &lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;Uncaught TypeError: a.indexOf is not a function&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위와 같은 에러가 나올때에는
&lt;code class=&quot;language-text&quot;&gt;.load()&lt;/code&gt; function이 있는지 찾아보고, &lt;code class=&quot;language-text&quot;&gt;on(&amp;#39;load&amp;#39;,function(){});&lt;/code&gt;으로 바꾸어주면 됨.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;.load&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;.unload&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;.error&lt;/code&gt;가 &lt;strong&gt;deprecate&lt;/strong&gt;되었다고.&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/38871753/uncaught-typeerror-a-indexof-is-not-a-function-error-when-opening-new-foundat&quot;&gt;stackOverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[[mongoose] mongoose paranoid (soft delete) 적용하기 (feat. plugin)]]></title><description><![CDATA[mongoose는 timestamp라는 옵션을 제공한다. plugin은 스키마별로도 적용할 수 있지만,
전역 플러그인(global plugin)으로 모든 schema…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-08-mongoose-soft-delete-plugin/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-08-mongoose-soft-delete-plugin/</guid><pubDate>Sat, 24 Oct 2020 17:20:15 GMT</pubDate><content:encoded>&lt;p&gt;mongoose는 timestamp라는 옵션을 제공한다.&lt;/p&gt;
&lt;p&gt;plugin은 스키마별로도 적용할 수 있지만,
전역 플러그인(global plugin)으로 모든 schema에 대해서도 적용이 가능하다.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;remove&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;delete&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;이제부터 &lt;code class=&quot;language-text&quot;&gt;delete&lt;/code&gt;를 기록하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;delete&lt;/code&gt;만을 사용한다.
&lt;code class=&quot;language-text&quot;&gt;remove&lt;/code&gt;는 &lt;em&gt;document를 완전히 삭제&lt;/em&gt;할 때 사용한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[[mongoose] mongoose 연결하기]]></title><description><![CDATA[mongoose 시작하기 MySQL과 같은 전통적인 SQL 데이터베이스가 여전히 많이 쓰이고 있고, 나도 꽤 익숙한지라..
mongoDB는 자주 접할 기회기 없었는데, javascript…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-24-mongoose-connect/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-24-mongoose-connect/</guid><pubDate>Sat, 24 Oct 2020 16:19:25 GMT</pubDate><content:encoded>&lt;h1&gt;mongoose 시작하기&lt;/h1&gt;
&lt;p&gt;MySQL과 같은 전통적인 SQL 데이터베이스가 여전히 많이 쓰이고 있고, 나도 꽤 익숙한지라..
&lt;em&gt;mongoDB&lt;/em&gt;는 자주 접할 기회기 없었는데, &lt;em&gt;javascript&lt;/em&gt;와의 찰떡 궁합이라는 이야기에 욕심내서 공부겸.. 사용해보려고 한다.&lt;/p&gt;
&lt;h2&gt;mongoose?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;mongoose&lt;/strong&gt;는 &lt;em&gt;mongoDB&lt;/em&gt;의 &lt;em&gt;ODM&lt;/em&gt; 라이브러리이다. &lt;em&gt;ODM&lt;/em&gt;은 &lt;em&gt;Object-Document Mapper&lt;/em&gt;로, &lt;em&gt;ORM(Object-Relation Mapper)&lt;/em&gt;과 유사한 개념이라고 보면 된다.
&lt;em&gt;ODM&lt;/em&gt;을 사용하면 &lt;em&gt;ORM&lt;/em&gt;을 사용할 때와 같은 장점을 가지고 있다고 볼 수 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mongoose&lt;/em&gt;는 &lt;em&gt;mongoDB&lt;/em&gt;를 사용한다고 하면 거의 대부분 &lt;em&gt;mongoose&lt;/em&gt;를 이용한다고 보면 될 정도로 유명하고 많이 쓰이는 라이브러리 같다.
일반적으로는 &lt;em&gt;mongoDB&lt;/em&gt;를 그대로 사용한다기보다 &lt;em&gt;mongoose&lt;/em&gt;를 이용해서 사용한다.
특히, SQL에 익숙하다면 &lt;em&gt;mongoDB&lt;/em&gt;를 사용하게되면 쿼리를 작성하는 것이 달라서 낯설고 어렵게만 다가오는데, &lt;em&gt;mongoose&lt;/em&gt;를 사용하면 한결 편해진다.&lt;/p&gt;
&lt;h2&gt;mongoose의 설치.&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;mongoose&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;으로 설치하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$yarn add mongoose&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;typescript 프로젝트의 경우 아래와 같이 정의를 &lt;em&gt;devDependency&lt;/em&gt;로 설치해주자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$yarn add @types/mongoose --dev&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;mongoDB의 연결&lt;/h2&gt;
&lt;p&gt;이 포스트의 주제다. 그럼 mongoose를 이용해서 어떻게 DB에 연결하는지 알아보자.
&lt;em&gt;mongoDB&lt;/em&gt;의 연결은 &lt;code class=&quot;language-text&quot;&gt;mongoose.connect&lt;/code&gt;로 한다.
스펙은 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;mongoose.connect(&amp;#39;mongodb://username:password@host:port/database?options...&amp;#39;, {useNewUrlParser: true});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;연결에 관한 내용은 &lt;code class=&quot;language-text&quot;&gt;mongoose.connection&lt;/code&gt;이 제공한다. &lt;code class=&quot;language-text&quot;&gt;mongoose.connection&lt;/code&gt;을 이용하면 DB 연결에 대한 콜백이나 에러 핸들링 등도 가능하다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import mongoose from &amp;#39;mongoose&amp;#39;;

mongoose.connect(&amp;#39;mongodb://localhost:27017&amp;#39;, {useNewUrlParser: true});
const { connection } = mongoose;

console.log(&amp;#39;connecting db...&amp;#39;);
connection.on(&amp;#39;error&amp;#39;, console.error.bind(console, &amp;#39;connection error:&amp;#39;));
connection.once(&amp;#39;open&amp;#39;, () =&amp;gt; {
  console.log(&amp;#39;connected to mongo db&amp;#39;);
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 해주면 성공적으로 연결되었을 때, &lt;code class=&quot;language-text&quot;&gt;connected to mongo db&lt;/code&gt;라는 메시지를 콘솔에서 확인할 수 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Jira 스마트 커밋(Smart Commit) 사용하기]]></title><description><![CDATA[이슈 관리를 위해 Jira를 사용하고 있다.
일반적으로 Bitbucket과 연동해서 사용하고 있을텐데, 원격 저장소에 커밋을 할 경우 연동된 Jira 이슈에 몇가지 부가적인 기능을 하게 할 수 있다.
이것을 스마트 커밋 (Smart Commit…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-22-jira-smart-commit/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-22-jira-smart-commit/</guid><pubDate>Thu, 22 Oct 2020 13:05:21 GMT</pubDate><content:encoded>&lt;p&gt;이슈 관리를 위해 Jira를 사용하고 있다.
일반적으로 Bitbucket과 연동해서 사용하고 있을텐데, 원격 저장소에 커밋을 할 경우 연동된 Jira 이슈에 몇가지 부가적인 기능을 하게 할 수 있다.
이것을 &lt;strong&gt;스마트 커밋 (Smart Commit)&lt;/strong&gt;이라고 부른다. &lt;strong&gt;스마트 커밋(Smart Commit)&lt;/strong&gt;은 다음과 같은 몇 가지 기능을 제공한다.&lt;/p&gt;
&lt;h1&gt;스마트 커밋 문법&lt;/h1&gt;
&lt;p&gt;스마트 커밋은 다음과 같이 커밋을 작성하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;ignored text&amp;gt; &amp;lt;ISSUE_KEY&amp;gt; &amp;lt;ignored text&amp;gt; #&amp;lt;COMMAND&amp;gt; &amp;lt;optional COMMAND_ARGUMENTS&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;ignored text&amp;gt;&lt;/code&gt;는 아무 텍스트이다.
예를들면,&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;Chore: ABC-123 코멘트 테스트 #comment Hello, World!&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;라고 커밋 메시지를 작성하면, &lt;strong&gt;ABC-123&lt;/strong&gt; 이라는 Jira 이슈에 &lt;em&gt;‘Hello, World!’&lt;/em&gt;라는 댓글이 달리게 된다.&lt;/p&gt;
&lt;p&gt;스마트 커밋은 3가지 커맨드를 제공한다&lt;/p&gt;
&lt;h1&gt;댓글 - &lt;code class=&quot;language-text&quot;&gt;#comment&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;방금 위에서 알아보았던 이슈에 댓글을 달기다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;ABC-123 #comment Hello World&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;ABC-123&lt;/strong&gt;이라는 지라 이슈에 &lt;em&gt;‘Hello World’&lt;/em&gt;라는 댓글이 달린다.&lt;/p&gt;
&lt;h1&gt;소요시간 입력 - &lt;code class=&quot;language-text&quot;&gt;#time&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;소요시간 단위를 입력할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;ABC-123 #time 3m Hello World&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;라고하면 &lt;strong&gt;ABC-123&lt;/strong&gt;이라는 이슈에 &lt;strong&gt;시간추적&lt;/strong&gt; 3분 로그가 추가되고, &lt;em&gt;‘Hello World’&lt;/em&gt;라는 댓글이 달린다.
소요시간은 이슈에 일일이 입력하기 너무 번거로운 점이 있는데, 이런식으로 하면 소요시간을 입력할 수 있고, 앞으로 업무 예측하기 좋아진다.&lt;/p&gt;
&lt;h1&gt;transition&lt;/h1&gt;
&lt;p&gt;이슈의 상태를 바꿀 수 있는 커맨드이다. 워크플로우의 각 상태를 이어주는 화살표를 &lt;strong&gt;transition&lt;/strong&gt;이라고 부르고, 커밋을 통해 Jira 이슈의 상태를 바꿀 수 있다.
만약 워크플로 상에 &lt;code class=&quot;language-text&quot;&gt;close&lt;/code&gt;라는 트랜지션이 존재한다면&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;TEST-23 #close Fixed this today&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;라고 커밋을 하면 &lt;strong&gt;TEST-23&lt;/strong&gt;이라는 이슈에 &lt;em&gt;Fixed this today&lt;/em&gt;라는 댓글이 달리면서 이슈는 닫히게 된다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[스크럼의 이론과 실천에 대한 가벼운 안내서]]></title><description><![CDATA[이 글은 ScrumPrimer…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-13-scrum-overview/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-13-scrum-overview/</guid><pubDate>Tue, 13 Oct 2020 08:58:53 GMT</pubDate><content:encoded>&lt;p&gt;이 글은 &lt;a href=&quot;https://scrumprimer.org/translations&quot;&gt;ScrumPrimer&lt;/a&gt; 사이트의 스크럼의 이론과 실천에 대한 가벼운 안내서를 요약한 글입니다. 요즘 여기저기서 &lt;em&gt;애자일&lt;/em&gt;을 도입한다, &lt;em&gt;스크럼&lt;/em&gt; 도입한다고만 하면서 여러가지 이유로 실제로 잘 운영되지 못하는 경우가 많은데… 내용을 보니 정말 중요한 이야기들이 많아 공유하려 합니다.&lt;/p&gt;
&lt;h1&gt;개요 Overview&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;스크럼&lt;/em&gt;은 &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-functional_team&quot;&gt;다기능팀&lt;/a&gt;&lt;/em&gt;이 제품이나 프로젝트를 &lt;strong&gt;반복적&lt;/strong&gt;이고 &lt;strong&gt;점진적&lt;/strong&gt;인 방식으로 개발하기 위한 개발 프레임워크&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;스프린트&lt;/em&gt;라고 불리는 주기로 구성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;반복 주기는 4주를 넘지 않으며 (보통 2주)&lt;/li&gt;
&lt;li&gt;멈추지 않고 하나가 끝나면 다음것이 시작&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;시간이 고정&lt;/strong&gt; (&lt;em&gt;timeboxed)&lt;/em&gt;되어있음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일이 끝났던, 끝나지 않았던 기간이 &lt;strong&gt;절대 늘어나지 않고 정해진 날짜에 끝&lt;/strong&gt;난다.&lt;/li&gt;
&lt;li&gt;보통 스크럼 팀은 스프린트의 길이를 정해놓고 개선해서 주기를 더 짧게 할 수 있을
때 까지는 모든 스프린트를 그 길이로 진행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매 스프린트 시작 시 다기능팀(약 7명)은&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;우선순위가 매겨진 리스트에서 아이템(요구사항)을 고름&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프린트가 끝날 때 어떤 &lt;strong&gt;결과물&lt;/strong&gt;을 낼 수 있을지 합의&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;결과물은 분명하고 정말로 &lt;strong&gt;“완료”&lt;/strong&gt;라고 할 수 있는 것을 말함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프린트 동안은 &lt;strong&gt;어떤 새로운 아이템도 추가되지 않음.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;다음 스프린트&lt;/em&gt;에 대한 변화는 수용&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;현재의 짧은 스프린트&lt;/em&gt;는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;작고&lt;/li&gt;
&lt;li&gt;분명하며&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상대적으로 안정적인 목표에 집중&lt;/strong&gt;해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;매일 진척사항에 대해 간단히 점검 + 남은 일을 완료하기 위해 필요한 다음 단계 조정&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프린트가 끝날 때&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이해관계자와 해당 스프린트에 대해 검토하고 시연함&lt;/li&gt;
&lt;li&gt;다음 스프린트에 반영될 수 있는 피드백 수집&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스크럼에서는 스프린트가 끝날 때 &lt;strong&gt;작동할 수 있는 제품&lt;/strong&gt;을 만드는 것이 강조&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시스템이 통합되고&lt;/li&gt;
&lt;li&gt;완전히 테스트 되었으며&lt;/li&gt;
&lt;li&gt;최종 사용자를 위한 문서가 작성되었고&lt;/li&gt;
&lt;li&gt;잠재적으로 출시 가능한 제품&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스크럼의 주요한 주제는 &lt;strong&gt;검토&lt;/strong&gt;와 &lt;strong&gt;조정&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/2c8233265b6fc401b4e6c05417f3804b/2f8cb/scrum_diagram.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 53.37837837837838%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACCUlEQVQoz52SXW/ScBTG+/X8HN76AfwC3iwxXu3GRGPMXFCme4ksG7qROTdGCAjdxijQMimvBVb6QmmB8bOt6TKWeeNJTvo///Oc5/+cJxUWiwX3I6iju+FwiCiKVCoVEokEsVgMRVHucI+FEDXm01mAWgJrmhYSBplMJonH4w8IF5GKuxSC2nZd1k/SZJV62L+NHpnP8TwvzOA8m83C78NNovMiItSnHu9zWU7r8t2r/1rpvjWP4YRRV6OUTOFaJmJrxNpZnb7pRGNLA5OJh207uJPp301u5yEmqPUby+9PEbRshvTKCrZSY1fWebF3yVXXDAd03eHDu2Muz9UQLNdaSOVrxvZkSdVA65M9y9FtthEc20DvNMPGyBqj9nrMpi5T1+G61uT16gEf19LsJ4rsbOYQfzVCbOCnWi362AlS9juvnj9FksoIrWqKxsUh+lBDVVXaLclXYyLl48jlHSxrxkHygtS3c44OS2ROKyFh4Wibl8+e+KoUBo0O4vE+SlND6Hd/I18V0Hoa5VKdfL5Mpz1CLJz4/1+ea6XPl09Ztj6n2drIsL2R862wkEo5fuxv+tgmu18vebt+xnmxijAeOxiWhet6DPsm/Z6Oodu+sjFBbziwKF00Of0p+T7VqJTbmKaNYRjc+MSOY9HrGqy+OUaWOwhz3wvLJ/Q8l/8N23LoqD2cscsfBdo0bo3r/awAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/2c8233265b6fc401b4e6c05417f3804b/fcda8/scrum_diagram.png&quot;
        srcset=&quot;/static/2c8233265b6fc401b4e6c05417f3804b/12f09/scrum_diagram.png 148w,
/static/2c8233265b6fc401b4e6c05417f3804b/e4a3f/scrum_diagram.png 295w,
/static/2c8233265b6fc401b4e6c05417f3804b/fcda8/scrum_diagram.png 590w,
/static/2c8233265b6fc401b4e6c05417f3804b/efc66/scrum_diagram.png 885w,
/static/2c8233265b6fc401b4e6c05417f3804b/c83ae/scrum_diagram.png 1180w,
/static/2c8233265b6fc401b4e6c05417f3804b/2f8cb/scrum_diagram.png 1689w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h1&gt;스크럼에서의 역할들 (Scrum Roles)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;제품 책임자&lt;/strong&gt;와 &lt;strong&gt;팀&lt;/strong&gt;, &lt;strong&gt;스크럼마스터&lt;/strong&gt;가 있음.&lt;/p&gt;
&lt;h2&gt;제품 책임자 (Product Owner)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;투자 수익률(ROI)를 최대해야할 책임&lt;/li&gt;
&lt;li&gt;&lt;em&gt;기능(Feature)&lt;/em&gt;를 식별하고&lt;/li&gt;
&lt;li&gt;이것을 반영해 리스트의 우선순위를 수립하여&lt;/li&gt;
&lt;li&gt;어떤 것이 리스트의 가장 위에 와야하는지 결정&lt;/li&gt;
&lt;li&gt;지속적으로 리스트의 우선순위를 재조정 + 개선&lt;/li&gt;
&lt;li&gt;제품이 상업적인 경우, 제품 책임자는 &lt;strong&gt;제품의 손익에 대한 책임이 있다&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;고객과 제품책임자가 같을 수도 있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Product Manager나 Product Marketing Manager의 역활과 비슷하지만 기존 Product Manager와는 다름&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제품 책임자는 프로젝트 관리자에게 개발에 대한 결정권을 위임하는 것이 아님&lt;/li&gt;
&lt;li&gt;팀과 적극적인 소통 + 모든 이해관계자들과 협업을 통해 ⇒ 매 스프린트의 결과를 검토하며 우선순위를 정함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;스크럼의 최종 권한을 가진 책임자는 오직 1명&lt;/strong&gt;이며 업무의 가치에 대한 책임이 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;팀&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;개발팀이라고도 함&lt;/li&gt;
&lt;li&gt;제품 책임자가 지시하는 제품(App, Web, etc.)을 만든다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;다기능 (cross-functional)&lt;/strong&gt; = 필요한 모든 전문 지식을 가지고 있어야 함.&lt;/li&gt;
&lt;li&gt;높은 수준의 자율성과 책임을 가진 &lt;strong&gt;자기조직(self-organizing, self-managing)&lt;/strong&gt;이어야 함.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제품 책임자가 제안한 것들 중 한 스프린트 동안&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;몇 개의 아이템을 완성할 지&lt;/li&gt;
&lt;li&gt;목표 달성을 위한 방법을 결정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;고정된 전문가는 없으며, 매 스프린트가 진행되는 동안 스스로 정한 목표의 달성을 위해 &lt;strong&gt;어떤 방식으로든&lt;/strong&gt; 함께 일한다.&lt;/li&gt;
&lt;li&gt;오직 팀원만 있기 때문에 &lt;strong&gt;다중학습(multi-learning)&lt;/strong&gt;이어야 함.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;팀 구성은 7명~2명 안팎&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제품을 개발&lt;/li&gt;
&lt;li&gt;제품 책임자에게 어떻게 제품을 훌륭하게 만들 것인지에 대한 아이디어를 제시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스프린트 동안 하나의 제품을 위해서 100% 몰두해서 일할 수 있을 때 가장 생산적 &amp;#x26; 효율적
⇒ &lt;strong&gt;주의가 분산되거나 흐름이 바뀌면서 낭비되는 것을 막아야 함.
여러 제품이나 프로젝트에 걸쳐져서 동시에 여러 작업을 하게 되는 것을 피해야 함.
팀원이 바뀌는 것을 지양&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;하나의 팀이 고객 중심의 기능들을 완성하기 위한 모든 일(계획, 분석, 프로그래밍, 테스트)을 종종 하므로 이런 팀은 또한 &lt;em&gt;기능팀(feature team)&lt;/em&gt;이라고도 불린다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;스크럼마스터(ScrumMaster)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;제품 그룹이 사업적인 가치를 만들기 위해서 스크럼을 배우고 적용하는 것을 돕는다.&lt;/li&gt;
&lt;li&gt;팀과 제품 책임자, 조직이 성공하기 위해 가능한 모든 일을 돕는다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;관리자가 아니며, 프로젝트 관리자도 아니고 팀 리더도 아니며 팀 대표자도 아님!
단지 도움을 주는 사람&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장애물을 제거&lt;/li&gt;
&lt;li&gt;외부의 간섭으로부터 보호&lt;/li&gt;
&lt;li&gt;새로운 개발 방식에 적응할 수 있도록 도움&lt;/li&gt;
&lt;li&gt;제품 책임자와 팀 그리고 다른 조직원이 스크럼을 능숙하게 사용할 수 있도록 가르치고 지도하고 설명&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;비록 작은 팀의 경우는 팀원이 기존에 하던 일을 줄이고 이 역할을 할 수도 있지만, &lt;strong&gt;그래도 모든 시간 동안 이 일에만 전념하는 스크럼마스터가 있어야 한다&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;스크럼마스터와 제품 책임자는 &lt;strong&gt;초점이 매우 다르며&lt;/strong&gt; 병행할 경우 혼란이나 충돌이 생기기 때문에 &lt;strong&gt;같은 사람이 맡을 수 없다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;참고: 스크럼에서는 &lt;strong&gt;프로젝트 관리자의 역할이 전혀 없다.&lt;/strong&gt; 왜냐하면 전혀 필요하지 않기 때문이다. 기존의 프로젝트 매니저가 맡았던 일들은 스크럼의 세 가지 역할에 나누어 할당되는데 스크럼 마스터보다는 팀과 제품 책임자에게 대부분 할당한다. 스크럼을 하면서 프로젝트 관리자를 추가한다는 것은 &lt;strong&gt;스크럼을 근본적으로 잘못 이해하고 있다는 것&lt;/strong&gt;을 말한다. 그리고 이런 경우 일반적으로 책임들 간의 충돌, 분명하지 않은 권한, 차선의 결과 같은 것들이 발생한다. 때론 프로젝트 관리자가 스크럼마스터의 역할을 하게 될 수 있지만 이런 접근방식이 전적으로 성공할 수 있을지는 개인이 얼마나 두 역할의 근본적인 차이에 대해서 이해를 했는지, 그날그날의 역할과 성공하기 위한 마음가짐을 모두 이해했는지에 달려있다. 스크럼마스터의 역할을 완전히 이해하고 성공하기 위한 핵심 기술들을 개발하기 위한 좋은 방법은 Scrum Alliance의 Certified ScrumMaster 교육을 받는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;기타 역할&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;제품의 성공에 기여하는 다른 이해관계자들&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;직무 관리자&lt;/li&gt;
&lt;li&gt;공학 관리자 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스크럼을 적용할 때에는 변해야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그들은 스크럼의 규칙들과 참뜻을 존중함으로써 팀을 지원한다.&lt;/li&gt;
&lt;li&gt;그들은 팀과 제품 책임자가 찾은 장애물을 제거하는 것을 돕는다.&lt;/li&gt;
&lt;li&gt;그들은 그들의 전문 지식과 경험을 쓸 수 있도록 한다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;⇒ 업무를 할당하고 현황 보고서를 받고 다른 형태의 세세한 관리 → 멘토링, 코칭, 장애물 제거를 돕기, 문제를 해결하는 것을도와주기, 창의적인 조언 제공, 팀원들의 기술 개발 지도&lt;/strong&gt; 로 변화&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;제품 백로그 (Product Backlog)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;스프린트 시작 전에 제품 백로그가 있어야 함&lt;/li&gt;
&lt;li&gt;사용자 중심의 기능들을 우선순위를 매겨 리스트화&lt;/li&gt;
&lt;li&gt;제품 수명기간 동안 계속 존재하고 개선되면서 &lt;strong&gt;해당 제품의 로드맵 역할&lt;/strong&gt;을 함&lt;/li&gt;
&lt;li&gt;우선 순위에 따라 기록된 것이 한눈에 명확히 드러나야 함&lt;/li&gt;
&lt;li&gt;하나의 제품에 대해 오직 하나의 제품 백로그만 존재: &lt;strong&gt;제품 책임자는 팀을 포함해 이해관계자들의 관심사를 전반적으로 반영하여 우선순위를 결정해야함.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/20a8024431aa0a40929923dd5535f3b7/5a3c9/scrum_backlog.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 95.94594594594595%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAAEIElEQVQ4y12U21NTVxTG8yf1oX9BO9OHvvShM+1M7YxObTt1HBvlLkkDxATIlYSQREyAAEGEChTQarVWndqOtR3FYriIXARygYSEcIvc5te9DqR2ema+s/bes9b3ffvsfZZuc3OT9fV1DTIWbG9vs7W19e98Y2ODnZ0dbV1iPp/nyZMnPHv2jIWFBdbW1rR8iTp5ZTIZdnd3OTw85ODgQCORBBnv7++zt7dHPB7XIGRSk06nSaVSrK6uks1mNVGJuvn5eWZnZ1laWtIKVlZWNFWBJEiBIBaLMTk5qeUsLi5qZMlkUkMikdDWJepEaXl5mfHxca1AIAKvXr3i5cuXzM3NaWJCKs4kimiRrIiigE4SpGBqaoqZmRmNSEjEoUTZgURJFnFxIcWCFYV4IsnS8hFhSghFTRxOT08zMTGhbUcEZE22nFOQKHnyrYuEMhekUuI2dTxOoZPCeeXg7+fP1XYnNMj2x8bGeK7WxLnkiJC4nJPvrcayJohrURk4NqE5TCiFpUSK/OYWO4U3FAq72hUpolAoKLzRkN9Q10jlFZHPqxuxvaPqCtpJ63Z398ilU6TnYsRn1YFMv2Bi/A9ik+pUpyaVw0l1ONMsvJ4lmXhNPpOksJFhfzvHQSEPhztkU0skF18jj24tm+PxnRHue0u45asmYDqHqfRzSr/+gm/PnqWsspzaSyZaGixcb/Pz8HY/47/dYuav+yRijyisTnC328P1Vs9bwvu3hhl0lXGvzcqAr46Qsw6bXo+5sgJLvQW318kVayN9gQA/XO/h56Fr/H57kNivN1kcf8Tj4TBPfxk6Iszmcvx0Y5jWWj19zbX0eGuJuEz4G00E3JcINtsJBz10dwTpu9rOYLSN0f4ID0Z7+fPOAC8e/ciNriZmxh4UCdcZGRrk4tlTOIwXsFXrtdhsMRBssnK5xUGr30Mo6KM9HKTjip/erhCj33dxdyjKvdFr3OxpIbPw9O2WhxVh+TcncdRU4airxnnJgFsRehxmWjyNCg78viaCijQUaKazrZW+aDsD0RADvRHCbjMPR6JHhJm1HH39/ei/PIGjVhEqskazEWe9CbfDisfVSJPLhs/jIhBs4UrAR6TtMt2dYbpV7O3p5MLpT7ErM8eEWaLRq5w5+RlWQxVm40XMNUZM1eV8Z6yipsZAvdVIQ4MZm92G2+3E63Xj9TiVmA2/38dXH3+It+6YcDWdIRRq4/SJTzCUlVBZcp7SkgtUlJ2nolzNqyowGPWYag2YrVYaHXYcLgWHDbu9HpcSeO/dd7BU6N867OnppfTcGewWM5a6GhqsZpyOBlwuB+4mF26Pl2a/n9ZwmPbOTiLdXUS6IkQ6O+iIdPDR+x9gqa4+Iix2Wvnp06rzJBJx7SeXWOwu0hz+27H/j7zq9tuKR55/AEgx5OV6+n5GAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/20a8024431aa0a40929923dd5535f3b7/fcda8/scrum_backlog.png&quot;
        srcset=&quot;/static/20a8024431aa0a40929923dd5535f3b7/12f09/scrum_backlog.png 148w,
/static/20a8024431aa0a40929923dd5535f3b7/e4a3f/scrum_backlog.png 295w,
/static/20a8024431aa0a40929923dd5535f3b7/fcda8/scrum_backlog.png 590w,
/static/20a8024431aa0a40929923dd5535f3b7/efc66/scrum_backlog.png 885w,
/static/20a8024431aa0a40929923dd5535f3b7/5a3c9/scrum_backlog.png 1169w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;백로그는 아래 내용들을 모두 포함한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;새로운 기능 (e.g. 모든 사용자는 장바구니에 책을 담을 수 있다)&lt;/li&gt;
&lt;li&gt;개발에 대한 발전적인 목표 (e.g. 시스템을 C++ 에서 Java기반으로 변환한다)&lt;/li&gt;
&lt;li&gt;팀의 개선 목표 (e.g. 테스트 속도를 향상시킨다)&lt;/li&gt;
&lt;li&gt;연구 업무 (e.g. 신용 카드 인증 속도를 향상하기 위한 해결책 조사)&lt;/li&gt;
&lt;li&gt;결함 (결함이 많을 경우 별도의 추적 시스템을 사용)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아이템은 어떤 방식으로든 분명하고 계속 유지될 수 있도록 표현&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대부분의 아이템들은 고객 가치 전달에 초점이 맞추어져 작성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DEEP&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Detailed appropriately&lt;/strong&gt;
최우선 순위의 아이템은 낮은 우선순위의 아이템보다 먼저 진행되기 때문에 &lt;strong&gt;상세하고 세밀하게 기술&lt;/strong&gt;되어야 함&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Estimated&lt;/strong&gt;
팀은 제품 책임자에게 제품 백로그의 각 아이템에 대해 해당하는 &lt;strong&gt;일의 양 (effort)와 기술적인 위험성(technical risk)에 대한 추정치를 제공&lt;/strong&gt;해야 함.
사업적 이해관계자들은 제품 &lt;strong&gt;요구사항의 가치에 대한 정보&lt;/strong&gt;(수익, 비용절감, 사업적 리스크, 중요성 등)를 다양한 이해관계자들에게 전달해야 함.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Emergent&lt;/strong&gt;
제품 책임자는 학습 내용, 변동사항에 따라 제품 백로그는 자주 개선해야 함.
매 스프린트마다 우선순위에 따라 추가/제거/수정 등 변경을 거침&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Prioritized&lt;/strong&gt;
제품 백로그의 최우선 순위 아이템부터 1에서 N까지 순서로 우선순위가 매겨져야 함.
최우선 순위의 아이템들은 &lt;strong&gt;적은 비용으로 큰 가치를 내는 것&lt;/strong&gt;이어야함
&lt;em&gt;큰 위험을 포함하고 아이템의 우선순위를 높게 잡는 방법(tackle high risks early, before the risks atack you)&lt;/em&gt;도 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스크럼마스터는 사업적 가치를 가늠하는 법을 배울 수 있게 도와야 함&lt;/li&gt;
&lt;li&gt;스크럼에는 매 스프린트마다 일이 얼마나 끝났는지 추적하는 기술이 있음 ⇒ 속도velocity&lt;/li&gt;
&lt;li&gt;다가오는 스프린트의 제품 백로그 아이템들은 팀이 이 아이템들에 대해서 이해할 수 있을 만큼 &lt;strong&gt;충분히 세분화되어서 스프린트 계획 때 팀이 유의미한 예측&lt;/strong&gt;을 할 수 있어야 함 ⇒ &lt;strong&gt;“실행가능한(actionable)” 크기&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시간과 비용이 많이 드는 주요한 기술 개선사항은 제품 백로그에 포함돼야함.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가벼운 기술사항에 대해서는 독자적으로 맡아 진행할 수 있더라도, 매 스프린트마다 팀은 대부분 시간을 내부적인 기술 업무 보다는 제품 책임자가 정한 목표를 위해 사용해야함.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;무엇이 중요한지를 최소한으로 명시해야 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;완료 기준 (Definition of Done)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;매 스프린트의 산출물 = 잠재적으로 출시 가능한 제품 증분 (Potentionally Shippable Product Increment)&lt;/li&gt;
&lt;li&gt;제품을 출시하기 위해 필요한 모든 활동 = 잠재적으로 출시 가능이라는 말의 정의에 포함되어야 함 (그러므로 스프린트 동안 끝나야 함)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매 스프린트마다 잠재적으로 출시 가능한 제품을 전달하는데 실패할 경우&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀이 자동화가 덜 되었거나&lt;/li&gt;
&lt;li&gt;충분히 다기능적이지 않기 때문&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스프린트 시작 전 제품 책임자와 팀은 완료 기준에 대해 합의를 봐야함.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좋은 제품 책임자?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;완료기준이 가능하면 잠재적으로 출시할 수 있을 수준&lt;/li&gt;
&lt;li&gt;개발이 투명해지고 지연되는 경우가 줄어들며 리스크가 감소&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;스프린트 계획(Sprint Planning)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;매 스프린트 시작 전 스프린트를 준비하기 위한 회의로, 2개의 파트로 나뉜다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파트1: &lt;strong&gt;“무엇(what)”&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;파트2: &lt;strong&gt;“어떻게(how)”&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;참가자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파트1: 제품 책임자, 팀, 스크럼마스터&lt;/li&gt;
&lt;li&gt;파트2: 팀, 스크럼마스터, 제품 책임자(optional)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;기간: 각 파트는 스프린트의 한 주당 한 시간 이내로 제한&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;스프린트 계획 파트1&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;제품 책임자와 팀이 제품 백로그 중 제품 책임자가 이번 스프린트에서 진행되길 원하는 우선순위가 높은 아이템들을 검토&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;지난 스프린트에서 제품 백로그 개선을 하는 동안 분석되었으므로 간단히 질문에 대해서 한 번 명확히 하는 작업만 진행&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;우선순위가 높은 아이템에 대한 목표와 내용에 대해서 정의&lt;/li&gt;
&lt;li&gt;제품 책임자의 의도 파악&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;제품 책임자가 무엇을 원하고 그것이 왜 필요한지 초점&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;스프린트 목표&lt;/strong&gt;를 정한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이상적으로는 짜임새가 있는 주제를 담고 있을 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;아이템의 이상적인 규모 = 전체 스프린트에 비해 현저히 작게 쪼개질 것 (스프린트 기간의 1/4 이내에 완수될 수 있을 정도의 크기)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;스프린트 계획 파트2&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;아이템을 &lt;strong&gt;어떻게 수행&lt;/strong&gt;할 지에 대해서 초점&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;팀은 제품 백로그의 우선순위가 높은 것부터 순차적으로 해당 스프린트가 끝날 때까지 할 수
있는 아이템의 수를 예측&lt;/strong&gt; ⇒ 핵심!
&lt;strong&gt;스크럼에서는 완수해야 할 작업을 제품 책임자가 팀에 할당하는 것이 아니라, 팀이 스스로 할 수 있는 작업의 양을 결정하는 것을 중요&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;팀은 우선순위가 아래에 있는 제품에 대해서도 영향력을 행사할 수 있음 (보통 팀과 제품 책임자 둘 다 현재 우선순위가 아래에 있는 아이템이 더 위에 있는 것이 적절하다고 생각하는 경우)&lt;/li&gt;
&lt;li&gt;스프린트 계획 회의는 2주 단위의 스프린트를 기준으로 4시간을 넘지 않도록 제한&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;수용 능력을 활용하는 방식으로 목표치 결정하기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;업무 수행에 얼만큼의 시간을 쓸지 추정&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스프린트와 관련된 업무를 수행하는데 쓸 시간 = 회의 참석, 메일, 휴식시간 등은 제외하는 개념&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;일반적으로 하루 4~6시간 정도 = 스프린트에 대한 수용 능력&lt;/li&gt;
&lt;li&gt;수용 능력이 정해지고 나면 기간동안 제품 백로그에 있는 아이템 몇개를 할지, 완수할지 검토&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아이템 선정&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;지난 스프린트의 회고 때 나온 개선 목표를 위한 작업&lt;/li&gt;
&lt;li&gt;제품 백로그에서 제품 책임자가 가장 우선순위를 높게 설정해놓은 아이템을 골라서 ‘충분’할 때까지 세분화&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스프린트 동안 해야 하는 일에 대한 리스트 = &lt;strong&gt;스프린트 백로그(Sprint Backlog)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/78cd45d8006a8f0496e47a5a124cbfd1/a9965/scrum_sprint_backlog.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 31.08108108108108%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA80lEQVQY0z1R16qEQBTz/79M0BdlFffae++KWCCXHHAfwmmZzMmMsm0biGmasCwL9n3Hfd84z1Nqzpgfx4F1XWXe9z3SNEWSJPh8PrBtG3meYxxHKCRQrCxLabyC13WhrmvpPc8josMwCNq2heM4aJpGhIqikJxQXkJVVXKz7/vQNA2WZSEIAmRZ9ptzIwrEcSwz1oxhGMo55gptzPP8245kVVWh6zpM05RD3JQOaJN5FEUiQi4j6xcK7RLclMJsUsgwDHkb3kohClKA8RVh9DxPONyQUF6xruvEMi19v39wXVfI7PFzyGPOSC7fizWfg/WLf9mYvNrFWn5uAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/78cd45d8006a8f0496e47a5a124cbfd1/fcda8/scrum_sprint_backlog.png&quot;
        srcset=&quot;/static/78cd45d8006a8f0496e47a5a124cbfd1/12f09/scrum_sprint_backlog.png 148w,
/static/78cd45d8006a8f0496e47a5a124cbfd1/e4a3f/scrum_sprint_backlog.png 295w,
/static/78cd45d8006a8f0496e47a5a124cbfd1/fcda8/scrum_sprint_backlog.png 590w,
/static/78cd45d8006a8f0496e47a5a124cbfd1/efc66/scrum_sprint_backlog.png 885w,
/static/78cd45d8006a8f0496e47a5a124cbfd1/a9965/scrum_sprint_backlog.png 1171w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;계획회의의 결과 = &lt;strong&gt;스프린트 약속 (Sprint Commitment): 스프린트가 끝날 때 어떤 결과물을 내놓을 것인지에 대한 현실적인 목표&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;스크럼의 기본적인 하나의 특징은 &lt;strong&gt;팀이 스프린트의 목표를 한 번 설정하면, 모든 추가사항이나 변경사항들은 다음 스프린트까지 미뤄져야 한다는 것&lt;/strong&gt;이다. 이 말은 만일 제품 책임자가 스프린트 중에 팀이 했으면 하는 새로운 아이템을 결정해도 &lt;strong&gt;다음 스프린트가 시작할 때 까지는 바꿀 수 없다는 뜻&lt;/strong&gt;이다. 만약 외부 상황에 의해서 우선순위가 많이 바뀌거나 이 일을 계속 했을 경우 팀이 시간을
낭비하는 꼴이 된다면 제품 책임자나 팀은 &lt;strong&gt;스프린트를 중단&lt;/strong&gt;할 수 있다. 팀이 스프린트를 중단하면 새로운 스프린트 계획 회의를 통해서 새로운 스프린트를 시작한다. 보통 이런 일이 일어나는 것을 막는 것이 좋다. 왜냐하면 이런 경우 제품 책임자와 팀이 사기가 하락해서 극단적인 결정에 의지하도록 하기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프린트 동안 목표가 바뀌지 않는 긍정적인 효과&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;팀&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀은 목표가 바뀌지 않을 것임을 확실하게 알고 일을 하기 대문에 확실하게 완료하는데 초점을 둘 수 있음&lt;/li&gt;
&lt;li&gt;스프린트에 자신이 제품 백로그에 우선순위를 매기고 팀에게 준 아이템들에 대해서 제대로 생각해 보게 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제품 책임자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀이 실질적이고 분명한 일들을 끝내기 위해서 최선을 다 한다는 것을 알게 된 것에 확신&lt;/li&gt;
&lt;li&gt;다음 스프린트가 시작하기 전에는 어떤 변경이든 제품 백로그에 반영할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;데일리 스크럼(Daily Scrum)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;팀원 사이의 최근 정보 공유와 협력&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;참가자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀(required)&lt;/li&gt;
&lt;li&gt;제품 책임자(optional)&lt;/li&gt;
&lt;li&gt;스크럼마스터 (팀에도 이 역할을 할 사람이 있어야함)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;기간: 최대 15분 이내&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;팀원&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;각자 한 업무에 대해 서로 맞추고 장애 요소에 대해서 공유&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;지난 회의 이후로 무엇을 완료했는가?&lt;/li&gt;
&lt;li&gt;다음 회의 전에 무엇을 완료할 것인가?&lt;/li&gt;
&lt;li&gt;이것을 하는데 장애 요소는 무엇인가?&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;보고 자리가 아닌, 진행사항에 대한 공유/협력의 시간&lt;/li&gt;
&lt;li&gt;누군가 장애 요소를 말했다면, 스크럼 마스터는 팀원들이 그것을 해결할 수 있도록 도와주는 역할&lt;/li&gt;
&lt;li&gt;회의가 필요하다면 종료 후 이어서 회의 진행&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;팀이 스크럼을 처음 한다면 일반적으로 &lt;strong&gt;관리자나 또는 권한이 있다고 여겨지는 사람들이 데일리 스크럼에 들어오지 않기를 권장&lt;/strong&gt;한다. 이런 위험한 행동을 통해 팀은“ 감시”당하고 있다고 생각하게 되어서 매일 비현실적인 기대치에 대한 주요 진척도를 보고해야 한다는 압박을 느끼게 된다. 또한 팀은 문제점을 보고하는 것에 대해서 억제를 당한다고 느끼며 팀이 스스로 잘 관리하지 못하고 세부사항까지 관리를 받게 된다. 이해관계자들은 팀의 회의에 따라가기 보다는 팀의 진척을 느리게 하는 장애 요소들을 제거해 주는 것이 더 유익할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;스프린트 동안 진척도 추적(Tracking Progress during the Sprint)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;스크럼에서 팀은 스스로 관리한다.&lt;/li&gt;
&lt;li&gt;스프린트 백로그에 있는 현재 작업을 완료하기 위해서 얼마나 남았는지 새로 추정&lt;/li&gt;
&lt;li&gt;스프린트 번다운 차트에 표시&lt;/li&gt;
&lt;li&gt;지속적으로 효율적으로 일할 방향을 찾아서 조정해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e28160e-4cc9-4ac2-8018-8045f9664aad/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e28160e-4cc9-4ac2-8018-8045f9664aad/Untitled.png&quot;&gt;&lt;/p&gt;
&lt;h2&gt;제품 백로그 개선(Product Backlog Refinement)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;미래의 스프린트를 위해 큰 아이템을 쪼개고 아이템을 분석하고 재추정하고 우선순위 재조정&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;참가자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀&lt;/li&gt;
&lt;li&gt;제품 책임자(optional, 세부적 개선에 도움을 줄 수 있는 전문가라면)&lt;/li&gt;
&lt;li&gt;요구사항을 이해하고 팀에 도움을 줄 수 있는 사람들 참가.&lt;/li&gt;
&lt;li&gt;스크럼마스터(효과적으로 진행할 수 있도록 지도하기 위해서 참가하고 나머지 부분은 참가하지 않을 수도 있음.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기간&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 팀이 사용 가능한 시간의 10% 넘지 않도록 함&lt;/li&gt;
&lt;li&gt;분석이 작업이 많은 아이템이기 때문에 오래 걸릴수는 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가치있는 스크럼 가이드라인 중 하나는 매 스프린트의 일정 부분은 팀 전체가 미래의 스프린트들을 위해 제품 백로그를 개선해야하는데 써야 한다는 것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;세부적인 요구사항 분석&lt;/li&gt;
&lt;li&gt;아이템 쪼개기&lt;/li&gt;
&lt;li&gt;새로운 아이템에 대한 추정&lt;/li&gt;
&lt;li&gt;현재 아이템 재추정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이 과정을 통해 스프린트 계획이 상대적으로 간단해짐&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;스프린트 리뷰(Sprint Review)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;제품 증분의 기능성에 관한 검토와 조정&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;참가자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀&lt;/li&gt;
&lt;li&gt;제품 책임자&lt;/li&gt;
&lt;li&gt;스크럼 마스터&lt;/li&gt;
&lt;li&gt;제품 책임자가 초대한 적합한 이해관계자들&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스프린트의 한 주당 한 시간으로 제약 (2주 길이 스프린트 = 최대 2시간)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프린트를 검토&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데모 x, 중요한 개념은 &lt;em&gt;검토&lt;/em&gt;와 &lt;em&gt;조정&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;제품 책임자: 제품과 팀에 대한 상황을 배움&lt;/li&gt;
&lt;li&gt;팀: 제품 책임자와 시장에 대해 배움&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;실제 제품으로 데모를 할 것&lt;/li&gt;
&lt;li&gt;리뷰 준비에 30분 이상을 사용하지 않을 것 (그렇다면 뭔가 잘못된 것)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;스프린트 회고(Sprint Retrospective)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;프로세스와 환경에 관련된 것을 검토하고 조정하는 활동&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;참가자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀&lt;/li&gt;
&lt;li&gt;스크럼 마스터&lt;/li&gt;
&lt;li&gt;제품 책임자 (optional)&lt;/li&gt;
&lt;li&gt;팀이 초대하지 않은 이해관계자들은 &lt;strong&gt;참석 불가&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스프린트 한 주당 45분으로 제한&lt;/li&gt;
&lt;li&gt;&lt;em&gt;프로세스&lt;/em&gt;와 &lt;em&gt;환경&lt;/em&gt;에 대해서 검토하고 조정&lt;/li&gt;
&lt;li&gt;스크럼 마스터는 회고에서 퍼실리테이터 역할을 할 수도 있으나, 외부 퍼실리테이터를 찾는 것이 더 나을 수 있음&lt;/li&gt;
&lt;li&gt;기법은 &lt;a href=&quot;https://agile.2ia.net/Agile%20Retrospectives.pdf&quot;&gt;Agile Rerospectives(Derby, Larsen 2006)&lt;/a&gt; 참고&lt;/li&gt;
&lt;li&gt;긍정적인 부분 부정적인 부분 모두 집중할 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;다음 스프린트의 시작(Starting the next Sprint)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;새로운 시각으로 새로운 아이템을 추가, 기존 아이템 제거 등 수정하여 제품 백로그 업데이트&lt;/li&gt;
&lt;li&gt;애자일 개발의 한 가지 원칙은 “지속 가능한 속도”이며 탐은 합리적인 수준으로 적절히 일해야 이 주기를 계속 이어나갈 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;생산성은 팀의 실천방식이 발전하고 &lt;strong&gt;팀의 생산성에 방해가 되는
요소들을 제거해 가며 계속해서 오르는 것&lt;/strong&gt;이지, 잔업이나 품질에 대해서 타협하며 오르는 것이 아니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;스프린트는 제품 책임자가 제품을 출시할 준비가 되었다고 판단할 때까지 계속&lt;/li&gt;
&lt;li&gt;완벽한 스크럼에서 제품은 매 스프린트가 끝날 때 마다 잠재적으로 출시가 가능한 상태&lt;/li&gt;
&lt;li&gt;하지만 많은 조직들은 개발 방법, 툴, 인프라가 약하고 이런 완벽한 스크럼은 할 수 없으며 그렇기 때문에 남은 일을 처리하기 위해서 &lt;strong&gt;“릴리즈 스프린트(Release Sprint)”&lt;/strong&gt;가 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;릴리즈 관리(Managing Release)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;반복적인 모델의 경우 장기적인 출시 계획을 어떻게 해야 하는가?&lt;/li&gt;
&lt;li&gt;첫번째 릴리즈를 위한 새로운 제품&lt;/li&gt;
&lt;li&gt;추후의 릴리즈를 위한 현재의 제품&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;새로운 제품의 경우나 현재의 제품에 단지 스크럼만 적용하는 경우&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;첫 번째 스프린트 전에 제품 백로그 개선을 시작 = &lt;strong&gt;제품 백로그 제작 or 릴리즈 계획&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;모든 아이템에 대한 추정도 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;확실히 정해진 제품 백로그가 있는 제품의 경우는 다음 릴리즈를 위한 어떤 특별하거나 큰 릴리즈 계획이 필요 없음 (= 매 스프린트마다 5~10% 정도의 시간을 백로그 개선, 추후를 위한 준비에 사용)&lt;/li&gt;
&lt;li&gt;스크럼은 매 스프린트마다 잠재적으로 출시 가능한 코드를 만드는 것을 강조하기 때문에 제품 책임자는 중간 릴리즈를 하기로 할 수도 있고, 고객이 완료된 작업에 대한 수혜를 더 빨리 받을 수 있게 할 수도 있다.&lt;/li&gt;
&lt;li&gt;계획을 세우고 개선하는 것을 통해서 릴리즈에 대한 큰 방향성을 제시하고 어떻게 결정들의 균형을 맞출지(예를 들면 범위냐 일정이냐 같은)를 명확히 하는 것이 핵심&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;애플리케이션 또는 제품에서의 관점&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;스크럼은 더 이상 시작, 중간, 끝이 있는 프로젝트는 없다.&lt;/li&gt;
&lt;li&gt;기존의 프로젝트 관리자도 없다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;필요한 모든 프로젝트 관리 업무는 팀과 제품 책임자가 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제품 책임자는 내부적인 사업 고객이거나 제품 관리와 관련된 사람&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;때로는 앞의 방법으로도 해결하기 힘들 정도로 새로운 일이 적어서 팀이 한 스프린트 내에 여러 애플리케이션의 아이템들을 담당할 수도 있다. 그러나 이런 방법은 &lt;strong&gt;다양한 애플리케이션에 걸쳐서 비생산적인 멀티태스크를 만들 수도 있으니 주의&lt;/strong&gt;해야 한다. 스크럼에서 생산성에 대한 기본적인 &lt;strong&gt;한 가지는 팀은 한 스프린트에 한 개의 제품이나 애플리케이션에 집중해야 한다&lt;/strong&gt;는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;공통 과제(Common Challenge)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;도전적인 스크럼 실천 방법을 할 때의 한 가지 &lt;strong&gt;흔한 실수는 스크럼을 변형시키는 것&lt;/strong&gt;이다. 예를 들어 산출물을 만드는데 문제가 있는 팀은 스프린트의 기간을 늘일 수도 있고 그래서 절대 시간이 다 되지 않을 것이다. 그리고 그런 프로세스에서는 추정하고 시간을 관리하는 것을 어떻게 하면 더 잘할지 절대 배울 필요가 없을 것이다. 이런 식으로 경험이 있는 스크럼마스터의 코칭이나 지원 없이 조직은 그들의 약점과 장애와는 반대로 스크럼을 변형시킬 수도 있고 스크럼이 주는 진정한 혜택을 약하게 만들 수도 있다. 여기서 말하는 스크럼이 주는 진정한 혜택은 &lt;strong&gt;장점과 단점을 눈에 보이도록 하고 조직이 더 높은 수준으로 나아가기 위한 선택 사항을 제시하는 것&lt;/strong&gt;을 뜻한다.
다른 흔한 실수는 스크럼이 &lt;strong&gt;특정 실천 사항을 분명하게 요구하지 않는다&lt;/strong&gt;는 이유로 어떤 실천 사항을 피하거나 금지해야 한다고 생각하는 것이다. 예를 들면, 스크럼에서는 제품 책임자가 제품을 위한 장기적인 전략을 세우는 것을 요구하지 않는다. 또한 스크럼에서는 엔지니어가 복잡한 기술적인 문제에 대해서 더 경험이 많은 엔지니어에게 조언을 구하는 것을 요구하지도 않는다. 스크럼에서는 이런 부분들은 개인이 올바른 결정을 하도록 남겨둔다. 대부분의 경우는 위의 두 실천 사항은 하는 것이 더 낫다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://scrumprimer.org/translations&quot;&gt;Scrum Primer&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[로컬에서 Jekyll 확인하기 - 기본 Jekyll 커맨드]]></title><description><![CDATA[로멀에서 Jekyll을 설치해서 블로그를 꾸며보기 최근 여유가 좀 있어서 Jekyll…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-09-jekyll-preview-local/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-09-jekyll-preview-local/</guid><pubDate>Fri, 09 Oct 2020 22:19:11 GMT</pubDate><content:encoded>&lt;h1&gt;로멀에서 Jekyll을 설치해서 블로그를 꾸며보기&lt;/h1&gt;
&lt;p&gt;최근 여유가 좀 있어서 &lt;em&gt;Jekyll&lt;/em&gt; 본격적으로 꾸며 나가보려는 마음에 이것저것 시도를 해보고 있다.
새롭게 찾은 테마가 처음 마음에 들긴 했지만, 보다보니 마음에 안들거나 개선시켜 보고 싶은 부분들도 느껴지고, 개인적으로 좀 욕심도 생겨서 지금 테마를 진화시켜나가보려고 마음을 먹었다.
기본적으로 &lt;em&gt;Jekyll&lt;/em&gt;은 원하는 플러그인을 붙이거나 &lt;em&gt;js&lt;/em&gt;나 &lt;em&gt;scss&lt;/em&gt;도 지원하는 등 손쉽게 원하는 커스터마이즈가 가능하다. (본 테마를 적용하게 되면서 알게된 사실이다..ㅎㅎ)&lt;/p&gt;
&lt;p&gt;그래서 처음엔 간단한 수정을 하기 위해서… 로컬에 별도의 프로젝트에서 js와 scss를 테스트 한 다음 이 블로그에 내용을 업데이트해서 푸시해서 확인하는 형식으로 업데이트 했다.
하지만 이런식으로 계속 하려니 좀 불편했다. 그래서 결국 &lt;em&gt;Jekyll&lt;/em&gt;을 설치했다..ㅋㅋ..&lt;/p&gt;
&lt;p&gt;로컬에 &lt;strong&gt;Jekyll&lt;/strong&gt;을 굳이 설치한다는 것은 약간의 귀찮음을 동반하지만 몇 가지 장점이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;푸시하기 전에 로컬에서 포스트를 미리보기할 수 있다.&lt;/li&gt;
&lt;li&gt;블로그를 로컬에서 확인할 수 있기 때문에, 테마 수정을 하기 용이하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그럼 본격적으로 &lt;strong&gt;Jekyll&lt;/strong&gt;을 설치하고, 사용하는 커맨드를 소개하고자 한다.&lt;/p&gt;
&lt;h2&gt;Jekyll 설치하기&lt;/h2&gt;
&lt;p&gt;Jekyll을 설치하는 방법은 [공식홈페이지][ref]에서 너무 잘 안내되어 있다. 그냥 따라하면 쉽게 설치할 수 있다. 간단하게 적자면 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Ruby&lt;/em&gt; 설치하기&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Homebrew&lt;/em&gt; 설치하기&lt;/li&gt;
&lt;li&gt;&lt;em&gt;rbenv&lt;/em&gt; 설치 (여러 버전의 ruby를 관리하는데 사용된다고 한다.)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Jekyll&lt;/em&gt; 설치&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이렇게 로컬에 &lt;em&gt;Jekyll&lt;/em&gt;을 설치한 다음에 새로운 블로그 프로젝트를 만들어 실행하는 방법은 다음과 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ jekyll new myblog
$ cd myblog
$ bundle exec jekyll serve&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게하면 새로운 블로그를 만들어 로컬 서버로 띄울수가 있고 &lt;code class=&quot;language-text&quot;&gt;localhost:4000&lt;/code&gt;으로 접속할 수 있다. clone한 github 블로그 프로젝트에 &lt;code class=&quot;language-text&quot;&gt;bundle exec jekyll serve&lt;/code&gt;를 하게 되면 &lt;code class=&quot;language-text&quot;&gt;Could not locate Gemfile or .bundle/ directory&lt;/code&gt; 오류가 난다.
깃헙 프로젝트에서는 다음 커맨드들을 이용하면 된다.&lt;/p&gt;
&lt;h2&gt;Jekyll 빌드&lt;/h2&gt;
&lt;p&gt;소스를 빌드하려면 다음 커맨드를 입력한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ jekyll build&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;커맨드를 실행하면 &lt;strong&gt;_site&lt;/strong&gt;폴더, &lt;strong&gt;.jekyll-cache&lt;/strong&gt;폴더 등이 생성되며, 만들어둔 &lt;strong&gt;md&lt;/strong&gt;과 에셋들이 빌드된 형태로 만들어진다.&lt;/p&gt;
&lt;h2&gt;Jekyll 서버 띄우기&lt;/h2&gt;
&lt;p&gt;블로그를 로컬 서버에 띄우려면 다음과 같이 입력한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ jekyll serve&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 하면 &lt;code class=&quot;language-text&quot;&gt;localhost:4000&lt;/code&gt;으로 로컬에서 블로그를 확인할 수 있다.&lt;/p&gt;
&lt;h2&gt;Jekyll 빌드 클린&lt;/h2&gt;
&lt;p&gt;빌드 결과물들을 지우려면 다음과 같이 입력한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ jekyll clean&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하면 캐시 등이 사라 진다.&lt;/p&gt;
&lt;p&gt;이제 남은 것은 뭐다? &lt;strong&gt;해피 해킹!!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[ref]:[https://jekyllrb-ko.github.io/docs/installation/macos/]&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Mac OS mds_store 리소스 점유율 문제 해결하기]]></title><description><![CDATA[Mac OS mds_store 리소스 점유율 문제 맥북이 점점 느려져서 활성 상태를 보니 mds_store가 CPU, 메모리 등 꽤 리소스를 점유하고 있었다.. 찾아보니 이렇게 mds_store의 리소스 점유율이 높은것은 spotlight…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-09-mds_store/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-09-mds_store/</guid><pubDate>Fri, 09 Oct 2020 18:01:58 GMT</pubDate><content:encoded>&lt;h1&gt;Mac OS mds_store 리소스 점유율 문제&lt;/h1&gt;
&lt;p&gt;맥북이 점점 느려져서 활성 상태를 보니 &lt;strong&gt;mds_store&lt;/strong&gt;가 CPU, 메모리 등 꽤 리소스를 점유하고 있었다..&lt;/p&gt;
&lt;p&gt;찾아보니 이렇게 &lt;strong&gt;mds_store&lt;/strong&gt;의 리소스 점유율이 높은것은 &lt;strong&gt;spotlight&lt;/strong&gt; 인덱싱 기능과 관련있는 모양.&lt;/p&gt;
&lt;p&gt;어차피 &lt;strong&gt;alfred&lt;/strong&gt;를 시용하고 있는 입장에서는 인덱싱을 비활성화되도 되어서 비활성화 처리했다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo mdutil -a -i off&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다시 활성화 하고 싶다면 아래와 같이 입력하면 된다. 꽤 낮아진다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo mdutil -a -i on&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;</content:encoded></item><item><title><![CDATA[node.js express 서버에 Swagger 끼얹기]]></title><description><![CDATA[Express 프로젝트에 Swagger를 달아보자. Swager? Swagger는 RESTful 웹 서비스에서 설계, 구축, 문서화 등을 도와주는 오픈소스 프레임워크라고 볼 수 있다.
Spring 프로젝트에서 적용된 사례를 많이 접했는데, node…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-08-swagger-ui-express/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-08-swagger-ui-express/</guid><pubDate>Thu, 08 Oct 2020 12:45:52 GMT</pubDate><content:encoded>&lt;h1&gt;Express 프로젝트에 Swagger를 달아보자.&lt;/h1&gt;
&lt;h2&gt;Swager?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Swagger&lt;/strong&gt;는 RESTful 웹 서비스에서 설계, 구축, 문서화 등을 도와주는 오픈소스 프레임워크라고 볼 수 있다.
Spring 프로젝트에서 적용된 사례를 많이 접했는데, node.js도 지원하고 있었다.&lt;/p&gt;
&lt;h2&gt;Swagger Tools&lt;/h2&gt;
&lt;p&gt;Swagger는 다음과 같은 것들이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://swagger.io/tools/swagger-editor/&quot;&gt;Swagger Editor&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Swagger Editor&lt;/strong&gt;는 RESTful API를 Swagger 스펙에 맞게 설계, 정의, 문서화할 수 있는 오픈소스 에디터이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://swagger.io/tools/swagger-codegen/&quot;&gt;Swagger Codegen&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Swagger Codegen&lt;/strong&gt;은 OpenAPI 스펙을 기반으로 API 클라이언트 라이브러리(SDK generation), server stubs, 문서화 등을 자동으로 해준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://swagger.io/tools/swagger-ui/&quot;&gt;Swagger UI&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Swagger UI&lt;/strong&gt;는 API 스펙들을 가시적으로 볼 수 있고, 실제 API를 테스트해볼 수 있게 해준다. API에 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://swagger.io/tools/swagger-inspector/&quot;&gt;Swagger Inspector&lt;/a&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;자동 생성된 OpenAPI 문서를 테스트 할 수 있는 툴이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;현업에서 일반적으로 &lt;strong&gt;Swagger&lt;/strong&gt;라고 하면 &lt;strong&gt;swager-ui&lt;/strong&gt;를 많이 지칭하는 것 같다. &lt;strong&gt;swagger-ui&lt;/strong&gt;는 백엔드 - 프론트 개발자 간 소통하는 문서로 많이 사용되고 있는데,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프론트 작업자 입장에서는  API 스펙을 볼 수 있고, 테스트도 해볼 수 있기 때문에&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;백엔드 작업자를 찾아가서 물어보지 않을 수 있고,&lt;/li&gt;
&lt;li&gt;백엔드 프로젝트를 들춰서 VO 소스코드를 보지 않아도 작업을 할 수 있는 장점이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;백엔드 개발자 입장에서는 &lt;strong&gt;swagger-ui&lt;/strong&gt; 자체가 문서가 되기 때문에&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;별도의 문서가 필요하지 않다는 점,&lt;/li&gt;
&lt;li&gt;프로젝트 소스와 연동되어있기 때문에 &lt;em&gt;가장 신선한&lt;/em&gt; 문서라고 볼 수 있다는 장점이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;실제로 Spring 개발자들은 &lt;strong&gt;swagger-ui&lt;/strong&gt;를 많이 도입해서 사용하는 사례들을 자주 보았다. 쓰는 프로젝트와 안쓰는 프로젝트의 차이? 말모말모.. 없으면 너무 불편한 정도다.&lt;/p&gt;
&lt;p&gt;그렇다면 node.js에는 어떻게 적용할 수 있을까?&lt;/p&gt;
&lt;h2&gt;express 프로젝트에 &lt;code class=&quot;language-text&quot;&gt;swagger-ui&lt;/code&gt;를 적용하기&lt;/h2&gt;
&lt;p&gt;express로 개발된 node.js 프로젝트에 &lt;code class=&quot;language-text&quot;&gt;swagger-ui&lt;/code&gt;를 적용해보자.&lt;/p&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;swagger-ui-express&lt;/code&gt; 설치&lt;/h3&gt;
&lt;p&gt;프로젝트에 &lt;code class=&quot;language-text&quot;&gt;swagger-ui-express&lt;/code&gt;를 설치한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;swagger-ui-express&lt;/code&gt;는 swagger-ui를 사용할 수 있게 하는 express 미들웨어이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;bash&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ yarn add swagger-ui-express&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;swagger.json&lt;/code&gt; 생성&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;swagger.json&lt;/code&gt;파일을 프로젝트 루트에 생성한다.&lt;/p&gt;
&lt;p&gt;이 JSON 파일에 OpenAPI 정의를 작성한다.&lt;/p&gt;
&lt;p&gt;swagger open api 스펙은 다음링크에서 확인 가능: &lt;a href=&quot;https://swagger.io/docs/specification/basic-structure/&quot;&gt;https://swagger.io/docs/specification/basic-structure/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;swagger 기본 구조&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;info&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API의 정보들을 정의: &lt;code class=&quot;language-text&quot;&gt;title&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;description&lt;/code&gt;(optional), &lt;code class=&quot;language-text&quot;&gt;version&lt;/code&gt;, …&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Paths&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 endpoint path를 나타냄&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Parameters&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URL에 포함된 파라미터나 Query String들을 정의함.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Request Body&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;requestBody&lt;/code&gt;로 body content와 media type을 정의할 수 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Responses&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가능한 status code와 response body &lt;code class=&quot;language-text&quot;&gt;schema&lt;/code&gt;를 정의할 수있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래와 같이 &lt;code class=&quot;language-text&quot;&gt;swagger,json&lt;/code&gt;파일을 작성한다. 참고로 아래 &lt;code class=&quot;language-text&quot;&gt;version&lt;/code&gt;은 OpenAPI 스펙의 버전이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;swagger&amp;quot;: &amp;quot;2.0&amp;quot;,
  &amp;quot;info&amp;quot;: {
    &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;, //version of the OpenAPI Specification
    &amp;quot;title&amp;quot;: &amp;quot;My User Project CRUD&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;My User Project Application API&amp;quot;,
    &amp;quot;license&amp;quot;: {
      &amp;quot;name&amp;quot;: &amp;quot;MIT&amp;quot;,
      &amp;quot;url&amp;quot;: &amp;quot;https://opensource.org/licenses/MIT&amp;quot;
    }
  },
  &amp;quot;host&amp;quot;: &amp;quot;localhost:8000&amp;quot;,
  &amp;quot;basePath&amp;quot;: &amp;quot;/&amp;quot;,
  &amp;quot;tags&amp;quot;: [
    {
      &amp;quot;name&amp;quot;: &amp;quot;Users&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;API for users in the system&amp;quot;
    }
  ],
  &amp;quot;schemes&amp;quot;: [
    &amp;quot;http&amp;quot;
  ],
  &amp;quot;consumes&amp;quot;: [
    &amp;quot;application/json&amp;quot;
  ],
  &amp;quot;produces&amp;quot;: [
    &amp;quot;application/json&amp;quot;
  ]
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;swagger-ui-express&lt;/code&gt; 연동하기&lt;/h3&gt;
&lt;p&gt;아래와같이 &lt;code class=&quot;language-text&quot;&gt;swagger-ui-express&lt;/code&gt;와 작성한 &lt;code class=&quot;language-text&quot;&gt;swagger.json&lt;/code&gt;을 import 하여&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const swaggerUi = require(‘swagger-ui-express’),
swaggerDocument = require(‘./swagger.json’);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;app.listen()&lt;/code&gt;앞에 아래 코드를 추가한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;app.use(&amp;#39;/api-docs&amp;#39;, swaggerUi.serve, swaggerUi.setup(swaggerDocument));&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게하면 호스트에서 &lt;code class=&quot;language-text&quot;&gt;{{host}}/api-docs&lt;/code&gt;를 통해서 Swagger 문서를 볼 수있는 것을 확인할 수 있다.&lt;/p&gt;
&lt;h3&gt;API 정의 완성하기&lt;/h3&gt;
&lt;p&gt;이제 &lt;code class=&quot;language-text&quot;&gt;swagger.json&lt;/code&gt;을 사용하는 API로 완성하면 된다. &lt;code class=&quot;language-text&quot;&gt;paths&lt;/code&gt; 필드에 api 스펙을 추가해나가면 된다. &lt;code class=&quot;language-text&quot;&gt;definitions&lt;/code&gt;에는 API에서 사용하게되는 object 형태를 제공 할 수 있다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;endpoint&lt;/code&gt; 명과 method type이 key가 되고, 각 값들을 정의할 수 있다. &lt;code class=&quot;language-text&quot;&gt;parameters&lt;/code&gt;로 파라미터의 타이&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;..
&amp;quot;paths&amp;quot;: {
    &amp;quot;/users&amp;quot;: {
      &amp;quot;get&amp;quot;: {
        &amp;quot;tags&amp;quot;: [
          &amp;quot;Users&amp;quot;
        ],
        &amp;quot;summary&amp;quot;: &amp;quot;Get all users in system&amp;quot;,
        &amp;quot;responses&amp;quot;: {
          &amp;quot;200&amp;quot;: {
            &amp;quot;description&amp;quot;: &amp;quot;OK&amp;quot;,
            &amp;quot;schema&amp;quot;: {
              &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/Users&amp;quot;
            }
          }
        }
      }
    },
    &amp;quot;/addUser&amp;quot;: {
      &amp;quot;post&amp;quot;: {
        &amp;quot;tags&amp;quot;: [
          &amp;quot;Users&amp;quot;
        ],
        &amp;quot;description&amp;quot;: &amp;quot;Create new user in system&amp;quot;,
        &amp;quot;parameters&amp;quot;: [
          {
            &amp;quot;name&amp;quot;: &amp;quot;user&amp;quot;,
            &amp;quot;in&amp;quot;: &amp;quot;body&amp;quot;,
            &amp;quot;description&amp;quot;: &amp;quot;User that we want to create&amp;quot;,
            &amp;quot;schema&amp;quot;: {
              &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/User&amp;quot;
            }
          }
        ],
        &amp;quot;produces&amp;quot;: [
          &amp;quot;application/json&amp;quot;
        ],
        &amp;quot;responses&amp;quot;: {
          &amp;quot;200&amp;quot;: {
            &amp;quot;description&amp;quot;: &amp;quot;New user is created&amp;quot;,
            &amp;quot;schema&amp;quot;: {
            &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/User&amp;quot;
            }
          }
        }
      }
    },
    &amp;quot;/user/{id}&amp;quot;: {
      &amp;quot;put&amp;quot;: {
        &amp;quot;summary&amp;quot;: &amp;quot;Update user with given ID&amp;quot;,
        &amp;quot;tags&amp;quot;: [
          &amp;quot;Users&amp;quot;
        ],
        &amp;quot;parameters&amp;quot;: [
          {
            &amp;quot;name&amp;quot;: &amp;quot;id&amp;quot;,
            &amp;quot;in&amp;quot;: &amp;quot;path&amp;quot;,
            &amp;quot;rquired&amp;quot;: true,
            &amp;quot;description&amp;quot;: &amp;quot;ID of user that we want to find&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;
          },
          {
            &amp;quot;name&amp;quot;: &amp;quot;user&amp;quot;,
            &amp;quot;in&amp;quot;: &amp;quot;body&amp;quot;,
            &amp;quot;description&amp;quot;: &amp;quot;User with new values of properties&amp;quot;,
            &amp;quot;schema&amp;quot;: {
              &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/User&amp;quot;
            }
          }
        ],
        &amp;quot;responses&amp;quot;: {
          &amp;quot;200&amp;quot;: {
            &amp;quot;description&amp;quot;: &amp;quot;User is updated&amp;quot;,
            &amp;quot;schema&amp;quot;: {
              &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/User&amp;quot;
            }
          }
        }
      }
    }
  },
  &amp;quot;definitions&amp;quot;: {
    &amp;quot;User&amp;quot;: {
      &amp;quot;required&amp;quot;: [
        &amp;quot;name&amp;quot;,
        &amp;quot;_id&amp;quot;,
        &amp;quot;companies&amp;quot;
      ],
      &amp;quot;properties&amp;quot;: {
        &amp;quot;_id&amp;quot;:{
          &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;,
          &amp;quot;uniqueItems&amp;quot;: true
        },
        &amp;quot;isPublic&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;boolean&amp;quot;
        },
        &amp;quot;name&amp;quot;: {
          &amp;quot;types&amp;quot;: &amp;quot;string&amp;quot;
        },
        &amp;quot;books&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;array&amp;quot;,
          &amp;quot;items&amp;quot;: {
            &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
            &amp;quot;properties&amp;quot;: {
              &amp;quot;name&amp;quot;: {
                &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;
              },
              &amp;quot;amount&amp;quot;: {
                &amp;quot;type&amp;quot;: &amp;quot;number&amp;quot;
              }
            }
          }
        },
        &amp;quot;companies&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;array&amp;quot;,
          &amp;quot;items&amp;quot;: {
            &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;
          }
        }
      }
    },
    &amp;quot;Users&amp;quot;: {
      &amp;quot;type&amp;quot; :&amp;quot;array&amp;quot;,
      &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/User&amp;quot;
    }
  }
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;대략적으로 형태들이 파악이 가능하다.&lt;/p&gt;
&lt;p&gt;그런데… 이 모든 API에 대해서 &lt;code class=&quot;language-text&quot;&gt;swagger.json&lt;/code&gt;을 작성해야하나?!!
이럴거면 단순 문서를 위해서라면 JSDoc, TSDoc, docz 등을 차라리 사용했겠죠..&lt;/p&gt;
&lt;p&gt;그럼 다음 포스트에서 좀 더 쉽게 작성할 수 잇는 방법을 소개한다!&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;p&gt;참고가 된 사이트&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md&quot;&gt;Open API Spec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@kirtikau/how-to-add-swagger-ui-to-existing-node-js-and-express-js-project-2c8bad9364ce&quot;&gt;how-to-add-swagger-ui-to-existing-node-js-and-express-js-project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://levelup.gitconnected.com/the-simplest-way-to-add-swagger-to-a-node-js-project-c2a4aa895a3c&quot;&gt;the-simplest-way-to-add-swagger-to-a-node-js-project&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[MySQL Field를 이용해서 원하는 순서로 정렬하기]]></title><description><![CDATA[쿼리를 짜다보면 일정 특정 필드에 대해 오름차순이나 내림차순 뿐만 아니라 특정 순서를 만들어서 정렬하고 싶을 경우가 있다. 이럴 때 MySQL…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-06-mysql-field-function/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-06-mysql-field-function/</guid><pubDate>Tue, 06 Oct 2020 13:43:59 GMT</pubDate><content:encoded>&lt;p&gt;쿼리를 짜다보면 일정 특정 필드에 대해 오름차순이나 내림차순 뿐만 아니라 특정 순서를 만들어서 정렬하고 싶을 경우가 있다.&lt;/p&gt;
&lt;p&gt;이럴 때 &lt;strong&gt;MySQL&lt;/strong&gt;에서 제공하고 있는 &lt;code class=&quot;language-text&quot;&gt;FIELD&lt;/code&gt; 함수를 이용하면 굉장히 간단하게 쿼리를 작성할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;SELECT name FROM city
ORDER BY FIELD(name, &amp;#39;london&amp;#39;, &amp;#39;milano&amp;#39;, &amp;#39;paris&amp;#39;, &amp;#39;new york&amp;#39;, &amp;#39;tokyo&amp;#39;);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;FIELD&lt;/code&gt;의 파라미터로 넘긴 값 외 다른 값의 정렬은 &lt;code class=&quot;language-text&quot;&gt;DESC&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;ASC&lt;/code&gt;로 설정 가능하다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;SELECT name FROM city
ORDER BY FIELD(name, &amp;#39;london&amp;#39;, &amp;#39;milano&amp;#39;, &amp;#39;paris&amp;#39;, &amp;#39;new york&amp;#39;, &amp;#39;tokyo&amp;#39;) DESC;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다른 필드를 섞어서 정렬도 가능하다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;SELECT name FROM city
ORDER BY FIELD(name, &amp;#39;london&amp;#39;, &amp;#39;milano&amp;#39;, &amp;#39;paris&amp;#39;, &amp;#39;new york&amp;#39;, &amp;#39;tokyo&amp;#39;) DESC, poularity;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;만약 &lt;code class=&quot;language-text&quot;&gt;FIELD&lt;/code&gt;를 사용하지 않는다고 한다면? &lt;code class=&quot;language-text&quot;&gt;CASE&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;DESC&lt;/code&gt;를 줄줄 늘려서 쓸 수도 있다고 한다.
약간 지저분해 보인다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;select name FROM city
ORDER BY CASE
  WHEN name = &amp;#39;london&amp;#39; then 1 else 2
end, city ASC&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;SELECT * FROM table ORDER BY id=&amp;#39;8&amp;#39; DESC, id=&amp;#39;5&amp;#39; DESC, id=&amp;#39;4&amp;#39; DESC, id=&amp;#39;3&amp;#39; DESC&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;FIELD&lt;/code&gt;를 이용하면 보기 좋게 쿼리 작성이 가능하므로 잘 알아두고 요긴하게 써먹자.&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;p&gt;1.[stackoverflow][ref1]&lt;/p&gt;
&lt;p&gt;[ref1]:[https://stackoverflow.com/questions/14104055/ordering-by-specific-field-value-first]&lt;/p&gt;</content:encoded></item><item><title><![CDATA[아직도 console.log만 쓰니? 내 콘솔창과 디버깅 생활에 생기를 불어넣어줄 console API]]></title><description><![CDATA[, 진짜 그것만으로 충분할까? 아주 오래전 웹 개발에서 Chrome Insepctor…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-javascript-console/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-javascript-console/</guid><pubDate>Tue, 06 Oct 2020 13:37:00 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;code class=&quot;language-text&quot;&gt;console.log()&lt;/code&gt;, 진짜 그것만으로 충분할까?&lt;/h1&gt;
&lt;p&gt;아주 오래전 웹 개발에서 &lt;em&gt;Chrome Insepctor&lt;/em&gt; 같은 강력한 도구가 없던 시절 자바스크립트 디버깅엔 &lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;가 필수였다.
그 때의 습관 탓일까, 디버깅 하면서 간단한 값 확인은 중단점을 걸고 스텝을 넘겨가며 로직을 확인하기보다 로그를 찍어 확인하는 것이 훨씬 빠르게 느껴져서 여전히 많이 사용하고 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.log()&lt;/code&gt;는 사실 유용하다. C나 JAVA와 같은 컴파일 언어는 로그를 찍는 코드가 추가되면 컴파일을 필수적으로 해야하는 시간이 걸리지만, javascript같은 인터프리터 언어는 굳이 신경쓸 필요가 없기 때문이다. (&lt;em&gt;Typescript&lt;/em&gt; 같은 전처리가 들어간다면 좀 다른 얘기가 되어버리지만..)
여하튼 &lt;code class=&quot;language-text&quot;&gt;console.log()&lt;/code&gt;는 굉장히 유용하고 자주 쓰이게 된다.&lt;/p&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;console.log()&lt;/code&gt;만 있는 것이 아니다.
디버깅에 유용한, 당신의 디버깅을 다채롭게 할 몇가지 console API를 소개한다.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.debug()&lt;/code&gt;&lt;/h2&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  const greeting = &amp;#39;hello world&amp;#39;;
  console.debug(greeting);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;와 거의 차이가 없는 &lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;의 alias라고 보면 될 것 같다.&lt;/p&gt;
&lt;p&gt;하지만 다른 점이 있다. &lt;em&gt;Chrome Insepctor&lt;/em&gt; 상의 &lt;em&gt;level&lt;/em&gt;이 &lt;strong&gt;Default levels&lt;/strong&gt;로 설정되어있을 경우에 &lt;code class=&quot;language-text&quot;&gt;console.debug&lt;/code&gt;에 의한 로그는 나타나지 않는다. &lt;code class=&quot;language-text&quot;&gt;Verbose&lt;/code&gt;를 체크해주어야 &lt;code class=&quot;language-text&quot;&gt;console.debug&lt;/code&gt;의 로그가 나타난다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/83252004a1964a187bb03dc00259cf86/3684f/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 225px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 93.91891891891892%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAACEUlEQVQ4y5VUy47TQBCcG1z4ApA475HP5caVAyc4IiHOGxR5s2yCveT9cJ52bOdlJy6qZuMIiU1iRiq1Zzxd0z1T3SaKlhj5PsbEZDLFYrGAP/IRhCGazSaWyyXiOEYURaVgwmCBu7t7/H708PP+AY+eh+qPKoY8wHEchCROksSSloFZzOdoNVsYjUbodDrodruMTHMfc/4LgqA0lI2ZzWbYbrdYrVZI0/QErW02m9KRCePxGEasGnmeYzqdQgcIWtd9/s+QPwlDOzkcMrjuLzQaDxaOU0Wv1zsdVpowCJbQ/iwTKey37H4vm9MKB2J/EQc6TSYTEQ7J3eCCTzsn6oRDDAhtTHhYepVQsIRx/J0X+pIv+ga+/xaDwSu+9Ate8GvOb7DbvSNx75hUfj3lOP5GR0NSQzIDzzNotQylY1CvG76+4VbXXkWeH+x9PocTYRj2+fmZqX2k/UR8Ib4SH4j31uZ5dDbCfwiTZI1+f0UhbxhZiNtbj/PYbtDDFA/85IjrhJJNmq65mNFusF7HFPXqGM3+iIKsRIQq6IyakZWgpfjdbmeFrWoRJIlzenwm5YQp9m1VuK6LSqVCYTdsY6jVanauUixNqG5ybhR1fala/iZUhpZQglSURbdpt9uU0ODkoJTPyaX4ryE/oy5TdBqRqw0p9EuRnxtqgUaRKUJfXZvtR9BcdjgcloKIlJF8/gB8cKo5rfwA7gAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/83252004a1964a187bb03dc00259cf86/3684f/1.png&quot;
        srcset=&quot;/static/83252004a1964a187bb03dc00259cf86/12f09/1.png 148w,
/static/83252004a1964a187bb03dc00259cf86/3684f/1.png 225w&quot;
        sizes=&quot;(max-width: 225px) 100vw, 225px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;이는 아래에서 소개하는 다양한 기능이 없는 심플한 &lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt; 같은 로그이면서도 &lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;와 기능적으로 분리하여 사용할 수 있게 만든다.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.error()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;굉장히 많이 사용하는 기능이다. 원하는 &lt;em&gt;에러 메시지&lt;/em&gt;를 콘솔에 찍을 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  const error = new Error(&amp;#39;you are not loggined&amp;#39;);
  console.error(error);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그 결과는 굉장히 에러스러운 메시지를 출력하게 만든다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f2ac69b6c7913c11df78aad8562fbc9e/dea13/2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 514px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 14.18918918918919%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAnUlEQVQI112OyRKCQAxE+f/PU0oWGYYddQaBi1pszwzqxUPXq0q6O/EeUcSiNSQJS12zKPVRmrLqdJ9zPEAcsRnDNgwguuc5bRxjxOd4k8xkLd7a97zalkmCTRhS+T5NEFCeIjFpnu2V6WKYjQXx/gqXrtsLHGfhLNxk77lBJx/aLNuvjGXBRWWkZ0uhDLmy6MRiqw7GYQ858S3+1xsgAODBzj3PigAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/f2ac69b6c7913c11df78aad8562fbc9e/dea13/2.png&quot;
        srcset=&quot;/static/f2ac69b6c7913c11df78aad8562fbc9e/12f09/2.png 148w,
/static/f2ac69b6c7913c11df78aad8562fbc9e/e4a3f/2.png 295w,
/static/f2ac69b6c7913c11df78aad8562fbc9e/dea13/2.png 514w&quot;
        sizes=&quot;(max-width: 514px) 100vw, 514px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;console.debug&lt;/code&gt;와의 큰 차이점은 이미지의 &lt;strong&gt;▼&lt;/strong&gt;에서 보면 알 수 있듯이 stack trace가 가능하다. 어느 지점에서 해당 로그가 나왔는지 확인 가능하므로 어떤 경로로 에러가 나왔는지 추적하기가 굉장히 수월하다.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.warn()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.error&lt;/code&gt;와 유사하지만 warning(경고)를 위해 사용한다.
&lt;code class=&quot;language-text&quot;&gt;console.error&lt;/code&gt;에 비해 많이 사용되지는 않지만, 라이브러리나 프레임워크와 같이 여러 사람들과 협업하는 과정에서 무언가를 알려야할 때에 꽤 유용하게 사용할 수 있다. 예를들면 다음 버전에서 deprecate 될 것이라든지, 동작은 하지만 올바른 사용방법이 따로 있다든지.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0b47199d2b70693f8627e595490b45b0/dea13/3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 514px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 10.81081081081081%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAc0lEQVQI123MywrCMABE0f7/t4lCq3YhImmetpqKEa2J9dpU3Lk4w8DAFGNY0Lcl3q4I5w3eLQm+Jg2aOCji4ytNnZRpxqfkqEtaU81yv1128DIUOe7XPSe3prMVvttOaoQ+IG2Dcg3CCHwv57N3VH/9tg9iVpZb88JkZwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/0b47199d2b70693f8627e595490b45b0/dea13/3.png&quot;
        srcset=&quot;/static/0b47199d2b70693f8627e595490b45b0/12f09/3.png 148w,
/static/0b47199d2b70693f8627e595490b45b0/e4a3f/3.png 295w,
/static/0b47199d2b70693f8627e595490b45b0/dea13/3.png 514w&quot;
        sizes=&quot;(max-width: 514px) 100vw, 514px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.warn&lt;/code&gt;도 trace를 확인할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.assert()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.assert&lt;/code&gt;도 꽤 유용하게 사용할 수 있는 메소드다..&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  const undef = undefined;
  const emptyStr = &amp;#39;&amp;#39;;
  const greeting = &amp;#39;Hello World&amp;#39;;
  console.assert(undef);
  console.assert(emptyStr);
  console.assert(greeting);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;&amp;#39;&amp;#39;&lt;/code&gt; 같은 &lt;code class=&quot;language-text&quot;&gt;falsy&lt;/code&gt; 값에 대한 error 로그를 나타난다. 아닌 경우에는 로그가 나타나지 않는다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/9f94e729a7227c1cf66a6a214fcf2249/267f6/4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 513px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 21.62162162162162%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAz0lEQVQY01WP0W6DMAxF+f+v26RtrDTACISVQIAitRsgcXah2qQ9XNmxnePraH155ZZlLHHMkiSsec6Spsxv7yylYzY588mwZh9gDJQl2zDgNdPo3ervRXGqKrheiZgmvpqGIFAnjdYySNY02LTD5R2FaQlVgHEUbAQB9/yfVNsXRcvTM3eBju3ahmAUBZwTqJ1yOctS1Qu2fUb9re8fBjT/G291fYAj1Lw7R6dzW2lQsxfAxhWl8bjzBXv6lHMPoWML/eHk2/s/7Reu4XHBD7XiKvlPdjwYAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/9f94e729a7227c1cf66a6a214fcf2249/267f6/4.png&quot;
        srcset=&quot;/static/9f94e729a7227c1cf66a6a214fcf2249/12f09/4.png 148w,
/static/9f94e729a7227c1cf66a6a214fcf2249/e4a3f/4.png 295w,
/static/9f94e729a7227c1cf66a6a214fcf2249/267f6/4.png 513w&quot;
        sizes=&quot;(max-width: 513px) 100vw, 513px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.time()&lt;/code&gt; &amp;#x26; &lt;code class=&quot;language-text&quot;&gt;console.timeLog()&lt;/code&gt; &amp;#x26; &lt;code class=&quot;language-text&quot;&gt;console.timeEnd()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;벤치 마킹 등 코드 실행을 측정할 때 사용할 수 있는 API이다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  console.time(&amp;#39;timer #1&amp;#39;);
  let count = 0;
  const timerId = setInterval(() =&amp;gt; {
    console.timeLog(&amp;#39;timer #1&amp;#39;);
    count++;
    if(count &amp;gt; 2) {
      clearInterval(timerId);
      console.timeEnd(&amp;#39;timer #1&amp;#39;);
    }
  },1000);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/aba5c4dcee47c557f7ec7bfaab809c28/2fd48/5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 508px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 20.945945945945947%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAm0lEQVQY01WPCQrFIAxEvf81axe7b7SotPm8AQs/IDHkOTO6lJJt22bzPNu6rnYch3VdZ9M0qXPattXuvm8rBR9CsGEY1Jmf5zGHIPA4jhI+z1MAgt573Zdl0S7n/AnCN02jPYYw7/uaizFq6PteLvu+W13XAnlAQlJc1yUhUlAYFkGYv4S4A5Qv44hIVVXqxQyOFFQJQVI6OwR/0rowwF1HjmQAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/aba5c4dcee47c557f7ec7bfaab809c28/2fd48/5.png&quot;
        srcset=&quot;/static/aba5c4dcee47c557f7ec7bfaab809c28/12f09/5.png 148w,
/static/aba5c4dcee47c557f7ec7bfaab809c28/e4a3f/5.png 295w,
/static/aba5c4dcee47c557f7ec7bfaab809c28/2fd48/5.png 508w&quot;
        sizes=&quot;(max-width: 508px) 100vw, 508px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;위와 같이 사용해서 타임스탬프를 확인할 수 있다.
파라미터로 &lt;code class=&quot;language-text&quot;&gt;label&lt;/code&gt;을 받는다.&lt;/p&gt;
&lt;p&gt;참고로 [&lt;code class=&quot;language-text&quot;&gt;console.timeStamp()&lt;/code&gt;][ref-timestamp]는 표준이 아니라고 함.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.trace()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.trace()&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;console.log()&lt;/code&gt;와 유사하지만 콜스택 정보를 함께 콘솔에 나타낸다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  console.trace(&amp;#39;hello world&amp;#39;);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b66abd7438facc929336b746611412c8/13a9a/6.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 9.45945945945946%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAX0lEQVQI122L2wrCMBAF+//fGUkkl62xwbhxM9L4aAeGAwdmK6XgnMN7zz0EHs+OHB/2Y9DfBkzm/PfEzBCRZa11/VtrjRgjKSVKzqT9xS0rQZTWbYW//JoxBqq69uQL+gSbu5tVSRcAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/b66abd7438facc929336b746611412c8/fcda8/6.png&quot;
        srcset=&quot;/static/b66abd7438facc929336b746611412c8/12f09/6.png 148w,
/static/b66abd7438facc929336b746611412c8/e4a3f/6.png 295w,
/static/b66abd7438facc929336b746611412c8/fcda8/6.png 590w,
/static/b66abd7438facc929336b746611412c8/13a9a/6.png 637w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.group()&lt;/code&gt; &amp;#x26; &lt;code class=&quot;language-text&quot;&gt;console.groupEnd()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.group()&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;console.groupEnd()&lt;/code&gt;는 로그를 그룹해서 몪어준다. 콘솔창을 정리할 때 유용하다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  console.group();
  console.log(&amp;#39;hello&amp;#39;);
  console.log(&amp;#39;world&amp;#39;);
  console.groupEnd();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/c12cdf6c4222b1b23f6575ed32edc1a5/68de2/7.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 16.216216216216214%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAWklEQVQI15XPSwrAIAwE0Nz/oEaELBTR+olj47rQdmDIah6EYoxwzoGZEUJAKQWWtdZrLWOMs7WaRXNO5JwhIp+QJ9B7f8CUEuhqDb13tPv+Ba2qilrr+cycDT++6zI1Tj9OAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/c12cdf6c4222b1b23f6575ed32edc1a5/fcda8/7.png&quot;
        srcset=&quot;/static/c12cdf6c4222b1b23f6575ed32edc1a5/12f09/7.png 148w,
/static/c12cdf6c4222b1b23f6575ed32edc1a5/e4a3f/7.png 295w,
/static/c12cdf6c4222b1b23f6575ed32edc1a5/fcda8/7.png 590w,
/static/c12cdf6c4222b1b23f6575ed32edc1a5/68de2/7.png 677w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;console.table()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.table()&lt;/code&gt;은 표 형태로 로그를 나타낸다.
&lt;code class=&quot;language-text&quot;&gt;Object&lt;/code&gt;형태로 파라미터를 넘길 수도 있고, &lt;code class=&quot;language-text&quot;&gt;Array&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;Object[]&lt;/code&gt;형태도 가능하다. &lt;code class=&quot;language-text&quot;&gt;Object[]&lt;/code&gt; 형태로 파라미터를 넘겼을 경우는 두 번째 파라미터에 프로퍼티명을 파라미터로 넣어서 원하는 속성만을 확인할 수도 있다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;  console.table({name: &amp;#39;apple&amp;#39;, amount: 10});
  console.table([&amp;#39;apple&amp;#39;, &amp;#39;orange&amp;#39;]);
  const fruits = [
    {
      name: &amp;#39;apple&amp;#39;,
      amount: 10,
    }, {
      name: &amp;#39;orange&amp;#39;,
      amount: 12,
    }, {
      name: &amp;#39;strawberry&amp;#39;,
      amount: 15,
    }
  ];
  console.table(fruits);
  console.table(fruits, [&amp;#39;name&amp;#39;]);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/62314419ff1fce6292eb7d631bd24dd1/31493/8.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 89.86486486486487%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACRUlEQVQ4y3WUiXKDMAxE+f+vbJuUQA7C4duY7UpAmvSYyY6MJTv4aU01DgMOhwO62w3TNGEaR8ZN21hqTp9HXM9nmL1GcxOGvsflclFZY1D1nPj4+MA4DnDOwVn7KmdhWHg+vON2PML/rJFnynIcQuCGo0HdXuFTQchgXF4U8gIbCroLF04ePi+/anbFXFBNk8GpOcO6gDwvSJxM86b8HSP/jOE1/6NmZqzkNeXY8topJaQYX5UiIqPl0b33j5qouaQ42rbFmXxlj2ok3LZtMAz9N0O36YlhS34dF3rvXvgKO2MmbVYInhsap+xELpY/ZcKM6XzDeKj5phEuyfz8yPu0xphmMjQW167HvR8ROJF2jspm2fhRhBhYG7ea/KtO5sgw55WDHFfGqzIy+QhfHe+aZ40xBj26jOXogkx8KJZSH9Z1jf5+V2MKC/mDgWb+fHvDQMObfX7L1Z8NmqZR0+/8ZCxNq4zzagkiYVxWzVAupqH76dE1t2vBrePx0/MaqF/l+JWxNCszcWelolFZZa4dTN3A3QcEPq+LZ24Y+fxaH5UnmyLs5K7Ka5fCv1wW/jaRUSHHQmYyv+cK4S+P58J1qxaqEnPKJbfcOG6GfYi5KE1gdOQTfuR3Yzf0Z9ue1ZPalBObMmy3RSaf5Tbjnt7fcWc3n2vco87oxvpxEIa7sf+79FbMfekwHU/K2/9Tqx8Hyy6roXP5ffHn1bSS9zS+PTXwtzsiW5z++JBkaYq8snxc5cjznBVs+UvMFTJT0eDln7ovY3x3/3X7to4AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Image&quot;
        title=&quot;&quot;
        src=&quot;/static/62314419ff1fce6292eb7d631bd24dd1/fcda8/8.png&quot;
        srcset=&quot;/static/62314419ff1fce6292eb7d631bd24dd1/12f09/8.png 148w,
/static/62314419ff1fce6292eb7d631bd24dd1/e4a3f/8.png 295w,
/static/62314419ff1fce6292eb7d631bd24dd1/fcda8/8.png 590w,
/static/62314419ff1fce6292eb7d631bd24dd1/31493/8.png 664w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;console.debug()&lt;/code&gt;에서 부터 &lt;code class=&quot;language-text&quot;&gt;console.tabel()&lt;/code&gt;까지 다양한 Console API를 확인해보았다.
다양한 Console API를 이용해서 좀 더 세련되고 풍성한 디버깅을 즐겨보자!&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;[MDN][ref-mdn]&lt;/li&gt;
&lt;li&gt;[There’s more than just console.log()…other useful ways to use the console in javascript][ref-dev-to]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[ref-timestamp]: [https://developer.mozilla.org/en-US/docs/Web/API/Console/timeStamp]
[ref-mdn]: [https://developer.mozilla.org/en-US/docs/Web/API/Console]
[ref-dev-to]: [https://dev.to/developer_buddy/there-s-more-than-just-console-log-other-useful-ways-to-use-the-console-in-javascript-17l8]&lt;/p&gt;</content:encoded></item><item><title><![CDATA[날짜 입력을 편하게 해주는 vscode extension Insert Date String]]></title><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-vscode-ext-insert-date-string/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-vscode-ext-insert-date-string/</guid><pubDate>Mon, 05 Oct 2020 15:14:25 GMT</pubDate><content:encoded></content:encoded></item><item><title><![CDATA[Jekyll 포스트를 숨기고 싶을 땐 published!]]></title><description><![CDATA[작성중인 포스트 보여주고 싶지 않아! github에서 Jekyll기반 블로그로 갈아타기 시작하며 몇 가지 장점? 특징?이 있다. 나름 재미를 느끼고 있다. 깃헙의 무료 포스트 테마 등 자유도가 높음 사용하는 IDE를 이용해서 작업하고 github…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-jekyll-front-matter-published/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-jekyll-front-matter-published/</guid><pubDate>Mon, 05 Oct 2020 14:12:15 GMT</pubDate><content:encoded>&lt;h1&gt;작성중인 포스트 보여주고 싶지 않아!&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;github&lt;/strong&gt;에서 &lt;strong&gt;Jekyll&lt;/strong&gt;기반 블로그로 갈아타기 시작하며 몇 가지 장점? 특징?이 있다. 나름 재미를 느끼고 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;깃헙의 무료 포스트&lt;/li&gt;
&lt;li&gt;테마 등 자유도가 높음&lt;/li&gt;
&lt;li&gt;사용하는 IDE를 이용해서 작업하고 github으로 바로 올리면 된다.&lt;/li&gt;
&lt;li&gt;마크다운 문법 (장점이자 단점이다..!!)&lt;/li&gt;
&lt;li&gt;CLI처럼 다 외우거나 자주 쓰지 않는 문법을 이용할 경우에는 치트시트가 필요함.&lt;/li&gt;
&lt;li&gt;하지만 문서가 규격화 되어 서식을 일괄적으로 조정하거나 관리할 수 있고, 예상 가능한 수준의 규격을 지니게 된다.&lt;/li&gt;
&lt;li&gt;뭘 추가하려면 직접 구성해야함. (좀 귀찮아 보이긴 하지만 의외로 찾아보면 방법들이 잘 정리되어있다.)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이러한 느낌들을 느끼는 중..
오래전에 사용했던 태터툴즈나 워드프레스, 네이버 블로그 등 다양한 블로그 서비스들에 비해 받았던 첫 인상 중 하나는 &lt;strong&gt;관리자 페이지&lt;/strong&gt;가 없다는 것이었다.
(찾아보니 &lt;a href=&quot;https://github.com/jekyll/jekyll-admin&quot;&gt;jekyll-admin&lt;/a&gt; 이라는 모듈이 있긴 한 듯 하다. 하지만 아직까지 이정도의 필요성은 못느끼겠다..)&lt;/p&gt;
&lt;p&gt;기존 블로그 서비스들의 관리자 기능에서 가장 많이 사용하는 기능중 하나가 &lt;em&gt;포스트의 show/hide를 관리&lt;/em&gt;하는 것이었다.
jekyll 블로그를 사용하게 되면서 다른 것보다도 제일 먼저 필요를 느낀 기능이다.&lt;/p&gt;
&lt;p&gt;짬짬이 블로그 포스트를 작성하다보면, 한 포스트가 완성되기 전까지 여러번 커밋을 거쳐야할 경우가 발생한다. 당연 작성중인 포스트를 걸기엔 너무 챙피해.. 완성된 뒤에 보여주고 싶어! 하지만 그전까지 커밋을 참기엔..? 환경을 옮겨서 작성해야한다면? 이럴 때엔 어쩌면 좋을까?&lt;/p&gt;
&lt;h1&gt;답은 front-matter에 있다.&lt;/h1&gt;
&lt;p&gt;세상에 필요한 것은 이미 다 있다고 했던가.. 역시나 필요하던 기능이 있었다. 답은 &lt;strong&gt;front-matter&lt;/strong&gt;에 있었다.&lt;/p&gt;
&lt;p&gt;일반적으로 설정하게 되는 front-matter는 다음과 같다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;layout: post
title: &amp;quot;Jekyll 포스트를 숨기고 싶을 땐 published&amp;quot;
date: 2020-10-05 14:12:15
categories: jekyll
tags: jekyll&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서 블로그에서 글을 내리고 싶다면 어떨까?
바로 아래 한 줄을 추가하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;...
published: false
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;front-matter&lt;/strong&gt;에 추가할 수 있는 &lt;code class=&quot;language-text&quot;&gt;published&lt;/code&gt;는 특정 포스트를 보여주고싶지 않을 때에 사용할 수 있는 속성이다. &lt;code class=&quot;language-text&quot;&gt;published&lt;/code&gt;의 값을 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;로 해두면 블로그에서 해당 포스트가 사라져 보이게 된다.&lt;/p&gt;
&lt;p&gt;역시 이미 편리하게 사용할 수 있는 다양한 기능을 제공하고 있다.&lt;/p&gt;
&lt;p&gt;이로써 &lt;code class=&quot;language-text&quot;&gt;jekyll-admin&lt;/code&gt; 설치는 잠시 미뤄두기로 한다… (ㅋㅋㅋ)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Hook Form의 watch() vs getValues]]></title><description><![CDATA[React Hook Form은 14.7k에 빛나는 리액트용 폼 라이브러리이다.
폼 생성과 검증 등 개발 과정을 간소화할 수 있고, 폼 생성 과정과 코드를 좀 더 규격화 할 수 있다는 장점이 있다.
다른 폼 라이브러리에 비해서 React Hooks…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-rhf-watch-vs-getvalues/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-10-05-rhf-watch-vs-getvalues/</guid><pubDate>Mon, 05 Oct 2020 14:11:13 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;React Hook Form&lt;/strong&gt;은 14.7k에 빛나는 리액트용 폼 라이브러리이다.
폼 생성과 검증 등 개발 과정을 간소화할 수 있고, 폼 생성 과정과 코드를 좀 더 규격화 할 수 있다는 장점이 있다.
다른 폼 라이브러리에 비해서 React Hooks 형태로 사용할 수 있다는 점과 빠르다는 장점도 있다.
또한, 문서가 &lt;strong&gt;굉장히&lt;/strong&gt; 잘 구성되어있다.ㅎㅎ (완벽하지는 않지만 번역도 되어있는 듯 하다.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React Hook Form&lt;/strong&gt;사용에 필수적인 &lt;code class=&quot;language-text&quot;&gt;getValues&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;의 차이점에 대하여 메모해두고자 한다.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt; vs &lt;code class=&quot;language-text&quot;&gt;getValues&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;getValues&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;는 &lt;strong&gt;React Hook Form&lt;/strong&gt;을 값을 나타내거나 확인하는 등에 사용하기 때문에 필수적으로 사용하게 된다.
&lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;를 대부분 사용하지만…&lt;/p&gt;
&lt;p&gt;이미 &lt;a href=&quot;https://react-hook-form.com/faqs/#watchvsgetValuesvsstate&quot;&gt;공식 문서&lt;/a&gt;에서는 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;getVAlues&lt;/code&gt;에 대한 차이점을 아래와 같이 설명하고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;watch: subscribe to either all inputs or the specified inputs changes via event listener and re-render based on which fields that are subscribed. Check out this codesandbox for actual behaviour.
getValues: get values that are stored inside the custom hook as reference, fast and cheap. This method doesn’t trigger re-render.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아주 친절하게 &lt;a href=&quot;https://codesandbox.io/s/react-hook-form-watch-with-radio-buttons-and-select-examples-ovfus&quot;&gt;codesandbox&lt;/a&gt;로 예제도 제공하고 있다.&lt;/p&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/react-hook-form-watch-with-radio-buttons-and-select-examples-ovfus?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
  style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
  title=&quot;React Hook Form - watch with Radio Buttons and Select examples&quot;
  allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
  sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
&gt;&lt;/iframe&gt;
&lt;p&gt;핵심은 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;는 &lt;strong&gt;값 변화에 대해 컴포넌트가 re-render가 이루어지고&lt;/strong&gt; &lt;code class=&quot;language-text&quot;&gt;getValues&lt;/code&gt;는 그렇지 않다는 점이다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;는 input의 변화를 &lt;strong&gt;subscribe&lt;/strong&gt;해서 변화에 따라 re-render가 이루어진다.&lt;/p&gt;
&lt;p&gt;반면 &lt;code class=&quot;language-text&quot;&gt;getValues&lt;/code&gt;는 RHF 내에 render와 관계없이 저장된 value를 가져올 때에 사용된다. &lt;strong&gt;re-render&lt;/strong&gt;가 이루어지지 않는다. 따라서 빠르고 cheap한 메소드이다.&lt;/p&gt;
&lt;p&gt;개발을 하다보면 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;getValeus&lt;/code&gt;의 깂이 다른 시점이 있을 수 있는데, 이 차이점에서 비롯된 것이라고 볼 수 있다.&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://react-hook-form.com/faqs/#watchvsgetValuesvsstate&quot;&gt;React Hook Form 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codesandbox.io/s/react-hook-form-watch-with-radio-buttons-and-select-examples-ovfus&quot;&gt;codesandbox&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[Jekyll 테마를 바꿔보기]]></title><description><![CDATA[Jekyll 테마 변경해보기 약 한 달간 방치하고 있던 블로그의 테마를 변경했다. 원래는 터미널 테마  이었는데 윈도우 스타일로 ㅎㅎ 터미널 테마가 썩 마음에 들어 적용한 가장 큰 이유는   compatible…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/post/2020-09-29-theme-change/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/post/2020-09-29-theme-change/</guid><pubDate>Fri, 20 Oct 2017 12:26:28 GMT</pubDate><content:encoded>&lt;h1&gt;Jekyll 테마 변경해보기&lt;/h1&gt;
&lt;p&gt;약 한 달간 방치하고 있던 블로그의 테마를 변경했다. 원래는 터미널 테마 &lt;code class=&quot;language-text&quot;&gt;b2a3e8/jekyll-theme-console&lt;/code&gt; 이었는데 윈도우 스타일로 ㅎㅎ&lt;/p&gt;
&lt;p&gt;터미널 테마가 썩 마음에 들어 적용한 가장 큰 이유는 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;remote_theme&lt;/code&gt; compatible이라 &lt;code class=&quot;language-text&quot;&gt;_config.yml&lt;/code&gt;에 단 한줄 추가만으로 간편하게 설치가 가능하다는 점&lt;/li&gt;
&lt;li&gt;까만 배경에 안정감을 준다는 점&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이었는데 변경을 결심하였다.&lt;/p&gt;
&lt;p&gt;그 이유는 내가 지킬 사용법을 잘 모르는데 많은 내용이 감춰져 있어서 구조를 더욱 모르는 상태에서 작업해야해서 (적어놓고 보니 좋은 점이잖아?!) 손을 댈 엄두가 나지 않았던 점이 있고 (마치 처음 프레임워크를 접할 때와 같은 막연한 심정? ㅋㅋ),
사실 메뉴 등 각 영역이 분리 되어 잘 보이지 않아서 뭐가 뭔지 잘 모르는 이유가 컸다.&lt;/p&gt;
&lt;p&gt;막상 테마의 적용은 그다지 어렵지 않았다.&lt;/p&gt;
&lt;p&gt;그냥 테마로 나와 있는 파일들을 저장소에 넣어주기만 하고 기존 &lt;code class=&quot;language-text&quot;&gt;_config.yml&lt;/code&gt;파일만 만져주면 됐다. 테마에 대한 샘플 파일들도 제공하고 있는 것 같았다. &lt;code class=&quot;language-text&quot;&gt;remote_theme&lt;/code&gt;을 처음부터 사용할 때보다 조금 더 나은 점이라고 한다면, 이 샘플 파일들이 지킬의 구조를 이해하는데 도움을 주는 것 같다.&lt;/p&gt;
&lt;p&gt;우선 &lt;code class=&quot;language-text&quot;&gt;_layout&lt;/code&gt;의 존재를 알게 되었고, &lt;code class=&quot;language-text&quot;&gt;_data/tags&lt;/code&gt;로 &lt;strong&gt;tag&lt;/strong&gt;를 &lt;strong&gt;메뉴&lt;/strong&gt;처럼 관리할 수 있다는 점, &lt;strong&gt;scss&lt;/strong&gt;도 지원한다는 점 등등.. 이러한 가이드를 엿볼 수 있는 점이 좋았다. 또 설치했기 때문에 내가 손을 볼수도 있겠구나 ㅎㅎ..&lt;/p&gt;
&lt;p&gt;좀 더 공부해서 테마도 커스터마이즈 해봐야겠다. md, 지킬도 배워야하고, 보금자리 꾸며나가는 마음으로 차근차근 ㅎㅎ&lt;/p&gt;
&lt;p&gt;추가로 개인적으로 마음에 드는 theme을 여기에 적어둔다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.base68.com/&quot;&gt;Mediator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jekyllthemes.org/themes/mere-blog-theme/&quot;&gt;mere-blog-theme&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jekyllthemes.org/themes/Pinghsu-Theme/&quot;&gt;Pinghsu-Theme&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/daattali/beautiful-jekyll&quot;&gt;beautiful-jekyll&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;refrence&lt;/h2&gt;
&lt;p&gt;블로그를 처음 시작하면서 도움이 될 만한 포스트&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://dreamgonfly.github.io/blog/jekyll-remote-theme/&quot;&gt;쉽고 빠르게 수준 급의 GitHub 블로그 만들기 - jekyll remote theme으로&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jekyllrb.com/docs/&quot;&gt;jekyll document&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/ihoneymon/652be052a0727ad59601&quot;&gt;md 정리&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gjchoi.github.io/env/Kramdown(%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4)-%EC%82%AC%EC%9A%A9%EB%B2%95/&quot;&gt;md 정리&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item></channel></rss>