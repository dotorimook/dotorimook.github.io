{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/post/2021-07-31-useeffect-infinite-loop/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog","author":"Kyle Mathews"}},"markdownRemark":{"id":"50f225e4-31d4-5ea1-816a-08a9a0d7d372","excerpt":"useEffect 무한루프를 막는 5가지 패턴에 대해 잘 정리된 블로그 포스트를 보았다. 이미 리액트 개발자는 알고 있는 사실일테지만 위 글을 요약하면, 의 무한 루프는 dependency로 인해서 발생한다 , , 를 이용해서 dependency…","html":"<p><a href=\"https://javascript.plainenglish.io/5-useeffect-infinite-loop-patterns-2dc9d45a253f\">useEffect 무한루프를 막는 5가지 패턴에 대해 잘 정리된 블로그 포스트를 보았다.</a></p>\n<p>이미 리액트 개발자는 알고 있는 사실일테지만 위 글을 요약하면,</p>\n<ol>\n<li><code class=\"language-text\">useEffect</code>의 무한 루프는 dependency로 인해서 발생한다</li>\n<li><code class=\"language-text\">useCallback</code>, <code class=\"language-text\">useRef</code>, <code class=\"language-text\">useMemo</code>를 이용해서 dependency로 인한 무한루프 상태를 막을 수 있다.</li>\n</ol>\n<p>라는 것이다.</p>\n<h1>useEffect의 동작 원리</h1>\n<p><code class=\"language-text\">useEffect</code>의 사용방법은 다음과 같다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">useEffect(callback, dependencies);</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">const SomeComponent = () =&gt; {\n\tuseEffect(() =&gt; {\n\t\tsomeEffect();\n\t}, [dependency]);\n}</code>\n        </deckgo-highlight-code>\n<p>그래서 <code class=\"language-text\">useEffect</code> 사용은 이런식으로 하고, <code class=\"language-text\">dependency</code> 가 바뀌었을 경우 콜백을 실행해서 <code class=\"language-text\">someEffect()</code>가 실행된다. dependency의 비교는 <strong>얕은 비교(shallow comparison)</strong>이다.</p>\n<h1>무한루프를 제거하는 Dependency작성법</h1>\n<h2>Dependency를 없앤다?</h2>\n<p>Dependency를 없애면 무한루프로 이어진다. 사실 dependency를 빈 배열 <code class=\"language-text\">[]</code> 로 전달하는 방법도 있다. 이 방법은 특정 값에 효과(effect)를 만들어낼 수 있는 방법은 아니다. <code class=\"language-text\">componentDidMount</code>같은 효과를 낼 때 사용하는 것으로 알려져있는데, 사실 안에 외부 값들을 사용하고 있다면, <em>exhaustive-deps</em> 워닝을 만날 수 있다.</p>\n<h2>무한 루프를 일으키는 다른 dependency 패턴</h2>\n<p><code class=\"language-text\">useCallback</code>의 dependency로 작성했을 때 무한루프를 일으키는 경우는 다음과 같다:</p>\n<ol>\n<li>dependencies가 아예 없을 때 (위에서 설명)</li>\n<li>function으로 설정 (FC 내에서 정의된 함수를 의미)</li>\n<li>array로 설정</li>\n<li>Object로 설정</li>\n</ol>\n<p>당연함. 이 경우들은 모두 서로 비교를 했을 때 <code class=\"language-text\">false</code> 이므로 callback을 부르게 된다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">const func1 = () =&gt; &#39;something&#39;;\nconst func2 = () =&gt; &#39;something&#39;;\n\nconsole.log(func1 === func2); // false</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">console.log ([] === []); //false</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">console.log ({} === {}); //false</code>\n        </deckgo-highlight-code>\n<p>그럼 각 경우에 무한루프를 막을 수 있는 방법은?</p>\n<h2>무한루프를 막는 dependency 작성하기</h2>\n<p>그럼 각 상황을 어떻게 막을 것인가?</p>\n<ol>\n<li>dependencies가 아예 없을 때 → <code class=\"language-text\">[]</code></li>\n<li>function으로 설정 → <code class=\"language-text\">useCallback</code></li>\n<li>array로 설정 → <code class=\"language-text\">useRef</code></li>\n<li>Object로 설정 → <code class=\"language-text\">useMemo</code></li>\n</ol>\n<p>이렇게 해결할 수 있다. <code class=\"language-text\">useCallback</code>, <code class=\"language-text\">useRef</code>, <code class=\"language-text\">useMemo</code> 의 특징은 dependency가 바뀌어야 자신이 변경되거나 mutual object 를 생성 한다는 점이다.</p>\n<h2>Reference</h2>\n<ol>\n<li><a href=\"https://javascript.plainenglish.io/5-useeffect-infinite-loop-patterns-2dc9d45a253f\">5 useEffect Infinite Loop Patterns</a></li>\n</ol>","frontmatter":{"title":"useEffect 무한루프를 방지하는 5가지 패턴","date":"July 05, 2021","description":null}}},"pageContext":{"next":null,"previous":{"fields":{"slug":"/post/2021-07-05-honey-key-cap-review/"},"frontmatter":{"title":"앤 프로2 Honey and Milk XDA 키캡 교체 후기"}},"slug":"/post/2021-07-31-useeffect-infinite-loop/"}},"staticQueryHashes":["2880150720","63159454"]}