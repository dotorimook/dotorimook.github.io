{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/post/2020-11-17-react-portal/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog","author":"Kyle Mathews"}},"markdownRemark":{"id":"400f17e7-7722-5814-8b83-9aa8336ed074","excerpt":"Portals - React Portal은 부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링하는 최고의 방법을 제공합니다. Why Portal? Portal은 기존 React Component가 담겨있는 DOM Tree 밖으로 Component…","html":"<p><a href=\"https://ko.reactjs.org/docs/portals.html\">Portals - React</a></p>\n<blockquote>\n<p>Portal은 부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링하는 최고의 방법을 제공합니다.</p>\n</blockquote>\n<h1>Why Portal?</h1>\n<p><strong>Portal</strong>은 기존 React Component가 담겨있는 DOM Tree 밖으로 Component를 렌더링을 할 때에 사용할 수 있는 기법이다.</p>\n<p><code class=\"language-text\">React.Portal</code>의 <strong><em>대표적인 유스케이스</em></strong>가 있다. 다이얼로그 처럼 전체 페이지를 덮어쓰면서 튀어나오도록 보이게 하는 컴포넌트들을 나타낼 때이다. 일반적인 경우 모달 다이얼로그는 페이지 전체를 덮어쓰는 방식이기 때문에 <code class=\"language-text\">position:fixed</code>나 <code class=\"language-text\">z-index</code> 등 속성을 사용하게 되지만, 결국 부모 엘레멘트의 속성에 영향을 받기 때문에, 페이지 최상단 등에 두게 된다. <strong>redux</strong>, <strong>mobx</strong> 등을 이용해 상태관리를 하고 있는 경우에는 다이얼로그의 show/hide를 별도의 공간에서 관리하기 때문에 원격지의 컴포넌트의 상태를 관리하는 것이 간단하지만, 원격지에 있는 컴포넌트가 여간 신경쓰이는 것이 아니게 된다… 이럴 때에 <strong>Portal</strong>을 사용하면, 기존의 DOMTree 밖으로 컴포넌트를 생성할 수 있기 때문에 부모 엘레멘트의 속성으로 부터 자유로워질 수 있다!</p>\n<h1>Portal의 사용</h1>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">ReactDOM.createPortal(child, container)</code>\n        </deckgo-highlight-code>\n<p>일반적으로 <code class=\"language-text\">index</code>에 담겨있는 <code class=\"language-text\">ReactDOM.render</code>와 유사하다.</p>\n<ul>\n<li><code class=\"language-text\">child</code>: 렌더링 할 컴포넌트</li>\n<li><code class=\"language-text\">container</code> : <code class=\"language-text\">child</code>를 담을 DOM 엘레멘트</li>\n</ul>\n<h2>예제</h2>\n<p>예제는 <a href=\"https://ko.reactjs.org/docs/portals.html\">리액트 공식 문서</a>에서 잘 제공 하고 있다. <a href=\"https://codepen.io/gaearon/pen/jGBWpE\">codepen</a>도 제공하고 있다.</p>\n<p><strong>index.html</strong></p>\n<deckgo-highlight-code language=\"html\"  >\n          <code slot=\"code\">&lt;html&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;app-root&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;modal-root&quot;&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p><strong>Portal.js</strong></p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// 여기 이 두 컨테이너는 DOM에서 형제 관계입니다.\nconst appRoot = document.getElementById(&#39;app-root&#39;);\nconst modalRoot = document.getElementById(&#39;modal-root&#39;);\n\nclass Modal extends React.Component {\n  constructor(props) {\n    super(props);\n    this.el = document.createElement(&#39;div&#39;);\n  }\n\n  componentDidMount() {\n    // Portal 엘리먼트는 Modal의 자식이 마운트된 후 DOM 트리에 삽입됩니다.\n    // 요컨대, 자식은 어디에도 연결되지 않은 DOM 노드로 마운트됩니다.\n    // 만약 자식 컴포넌트가 마운트될 때 그것을 즉시 DOM 트리에 연결해야만 한다면,\n    // 예를 들어, DOM 노드를 계산한다든지 자식 노드에서 &#39;autoFocus&#39;를 사용한다든지 하는 경우에,\n    // Modal에 state를 추가하고 Modal이 DOM 트리에 삽입되어 있을 때만 자식을 렌더링하십시오.\n    modalRoot.appendChild(this.el);\n  }\n\n  componentWillUnmount() {\n    modalRoot.removeChild(this.el);\n  }\n\n  render() {\n    return ReactDOM.createPortal(\n      this.props.children,\n      this.el\n    );\n  }\n}\nclass Parent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {clicks: 0};\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    // 이것은 Child에 있는 버튼이 클릭 되었을 때 발생하고 Parent의 state를 갱신합니다.\n    // 비록 버튼이 DOM 상에서 직계 자식이 아니라고 하더라도 말입니다.\n    this.setState(state =&gt; ({\n      clicks: state.clicks + 1\n    }));\n  }\n  render() {\n    return (\n      &lt;div onClick={this.handleClick}&gt;\n        &lt;p&gt;Number of clicks: {this.state.clicks}&lt;/p&gt;\n        &lt;p&gt;\n          Open up the browser DevTools\n          to observe that the button\n          is not a child of the div\n          with the onClick handler.\n        &lt;/p&gt;\n        &lt;Modal&gt;\n          &lt;Child /&gt;\n        &lt;/Modal&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nfunction Child() {\n  // 이 버튼에서의 클릭 이벤트는 부모로 버블링됩니다.\n  // 왜냐하면 &#39;onClick&#39; 속성이 정의되지 않았기 때문입니다.\n  return (\n    &lt;div className=&quot;modal&quot;&gt;\n      &lt;button&gt;Click&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\nReactDOM.render(&lt;Parent /&gt;, appRoot);</code>\n        </deckgo-highlight-code>\n<h2>Portal Component</h2>\n<p>사용법은 간단하므로, Portal Component를 만들어서 사용하면 되겠다.</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">import React, { FC } from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\n\nconst Portal:FC&lt;any&gt; = ({ children, className = &#39;root-portal&#39;, el = &#39;div&#39; }) =&gt; {\n  const [container] = React.useState(document.createElement(el));\n\n  container.classList.add(className);\n\n  React.useEffect(() =&gt; {\n    document.body.appendChild(container);\n    return () =&gt; {\n      document.body.removeChild(container);\n    };\n  }, [container]);\n\n  return ReactDOM.createPortal(children, container);\n};\n\nexport default Portal;</code>\n        </deckgo-highlight-code>\n<p>생성된 컴포넌트를 넣고 뺄 때 자연스럽게 <code class=\"language-text\">body</code>에서 사라지게 할 수 있다.</p>\n<h3>출처</h3>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/49426474/can-a-react-portal-be-used-in-a-stateless-functional-component-sfc/59154364#59154364\">Stackoverflow</a></li>\n</ul>","frontmatter":{"title":"React Portal + Hook으로 외부 DOM에 Component 생성하기","date":"November 17, 2020","description":null}}},"pageContext":{"next":{"fields":{"slug":"/post/2020-11-21-nginx-cookie-override/"},"frontmatter":{"title":"[nginx] nginx.conf 설정으로 프록시 서버 쿠키 설정 추가하기"}},"previous":{"fields":{"slug":"/post/2020-11-13-jquery-load-error/"},"frontmatter":{"title":"JQuery Uncaught TypeError: a.indexOf is not a function 에러처리"}},"slug":"/post/2020-11-17-react-portal/"}},"staticQueryHashes":["2880150720","63159454"]}